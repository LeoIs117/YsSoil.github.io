<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>springBoot面经</title>
    <link href="/2024/04/10/springBoot%E9%9D%A2%E7%BB%8F/"/>
    <url>/2024/04/10/springBoot%E9%9D%A2%E7%BB%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="什么是-Spring-Boot？"><a href="#什么是-Spring-Boot？" class="headerlink" title="什么是 Spring Boot？"></a>什么是 Spring Boot？</h2><p>Spring Boot 是 Spring 开源组织下的子项目，是 Spring 组件一站式解决方案，主要是简化了使用 Spring 的难度，简省了繁重的配置，提供了各种启动器，开发者能快速上手。</p><h2 id="Spring-Boot-有哪些优点？"><a href="#Spring-Boot-有哪些优点？" class="headerlink" title="Spring Boot 有哪些优点？"></a>Spring Boot 有哪些优点？</h2><p>Spring Boot 主要有如下优点：</p><ol><li><p>容易上手，提升开发效率，为 Spring 开发提供一个更快、更广泛的入门体验。</p></li><li><p>开箱即用，远离繁琐的配置。</p></li><li><p>提供了一系列大型项目通用的非业务性功能，例如：内嵌服务器、安全管理、运行数据监控、运行状况检查和外部化配置等。</p></li><li><p>没有代码生成，也不需要XML配置。</p></li><li><p>避免大量的 Maven 导入和各种版本冲突。</p></li></ol><h2 id="Spring-Boot-的核心注解是哪个？它主要由哪几个注解组成的？"><a href="#Spring-Boot-的核心注解是哪个？它主要由哪几个注解组成的？" class="headerlink" title="Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？"></a>Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？</h2><p>启动类上面的注解是@SpringBootApplication，它也是 Spring Boot 的核心注解，主要组合包含了以下 3 个注解：</p><p>@SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。</p><p>@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项，如关闭数据源自动配置功能： @SpringBootApplication(exclude </p><p>&#x3D; { DataSourceAutoConfiguration.class })。</p><p>@ComponentScan：Spring组件扫描。</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="什么是-JavaConfig？"><a href="#什么是-JavaConfig？" class="headerlink" title="什么是 JavaConfig？"></a>什么是 JavaConfig？</h2><p>Spring JavaConfig 是 Spring 社区的产品，它提供了配置 Spring IoC 容器的纯Java 方法。因此它有助于避免使用 XML 配置。使用 JavaConfig 的优点在于：</p><p>（1）  面向对象的配置。由于配置被定义为 JavaConfig 中的类，因此用户可以</p><p>充分利用 Java 中的面向对象功能。一个配置类可以继承另一个，重写它的</p><p>@Bean 方法等。</p><p>（2）  减少或消除 XML 配置。基于依赖注入原则的外化配置的好处已被证明。</p><p>但是，许多开发人员不希望在 XML 和 Java 之间来回切换。JavaConfig 为开发人员提供了一种纯 Java 方法来配置与 XML 配置概念相似的 Spring 容器。从</p><p>技术角度来讲，只使用 JavaConfig 配置类来配置容器是可行的，但实际上很多人认为将JavaConfig 与 XML 混合匹配是理想的。（3）类型安全和重构友好。JavaConfig 提供了一种类型安全的方法来配置 </p><p>Spring容器。由于 Java 5.0 对泛型的支持，现在可以按类型而不是按名称检索 bean，不需要任何强制转换或基于字符串的查找。</p><h2 id="Spring-Boot-自动配置原理是什么？"><a href="#Spring-Boot-自动配置原理是什么？" class="headerlink" title="Spring Boot 自动配置原理是什么？"></a>Spring Boot 自动配置原理是什么？</h2><p>BFPP：BeanFactoryPostProcessor</p><p>BPP：BeanPostProcessor</p><p>BDRPP:BeanDefinitionRegistryPostProcessor</p><p>表达的总体思路是：总-分-总</p><p>1、springboot自动装配是什么，解决了什么问题</p><p>2、自动装配实现的原理：</p><p>​1、当启动springboot应用程序的时候， 会先创建SpringApplication的对象，在对象的构造方法中会进行某些参数的初始化工作，最主要的是判断当前应用程序的类型以及初始化器和监听器，在这个过程中会加载整个应用程序中的spring.factories文件，将文件的内容放到缓存对象中，方便后续获取。</p><p>​2、SpringApplication对象创建完成之后，开始执行run方法，来完成整个启动，启动过程中最主要的有两个方法，第一个叫做prepareContext，第二个叫做refreshContext,在这两个关键步骤中完整了自动装配的核心功能，前面的处理逻辑包含了上下文对象的创建，banner的打印，异常报告期的准备等各个准备工作，方便后续来进行调用。</p><p>​3、在prepareContext方法中主要完成的是对上下文对象的初始化操作，包括了属性值的设置，比如环境对象，在整个过程中有一个非常重要的方法，叫做load，load主要完成一件事，将当前启动类做为一个beanDefinition注册到registry中，方便后续在进行BeanFactoryPostProcessor调用执行的时候，找到对应的主类，来完成@SpringBootApplicaiton,@EnableAutoConfiguration等注解的解析工作</p><p>​4、在refreshContext方法中会进行整个容器刷新过程，会调用中spring中的refresh方法，refresh中有13个非常关键的方法，来完成整个spring应用程序的启动，在自动装配过程中，会调用invokeBeanFactoryPostProcessor方法，在此方法中主要是对ConfigurationClassPostProcessor类的处理，这次是BFPP的子类也是BDRPP的子类，在调用的时候会先调用BDRPP中的postProcessBeanDefinitionRegistry方法，然后调用postProcessBeanFactory方法，在执行postProcessBeanDefinitionRegistry的时候回解析处理各种注解，包含@PropertySource,@ComponentScan,@ComponentScans，@Bean,@Import等注解，最主要的是@Import注解的解析</p><p>​5、在解析@Import注解的时候，会有一个getImports的方法，从主类开始递归解析注解，把所有包含@Import的注解都解析到，然后在processImport方法中对Import的类进行分类，此处主要识别的时候AutoConfigurationImportSelect归属于ImportSelect的子类，在后续过程中会调用deferredImportSelectorHandler中的process方法，来完整EnableAutoConfiguration的加载。</p><p>​6、上面是我对springboot自动装配的简单理解，面试官您看一下，我回答有没有问题，帮我指点一下！</p><h2 id="你如何理解-Spring-Boot-配置加载顺序？"><a href="#你如何理解-Spring-Boot-配置加载顺序？" class="headerlink" title="你如何理解 Spring Boot 配置加载顺序？"></a>你如何理解 Spring Boot 配置加载顺序？</h2><p>在 Spring Boot 里面，可以使用以下几种方式来加载配置。</p><p>1）     properties文件；</p><p>2）     YAML文件；</p><p>3）     系统环境变量；</p><p>等等……</p><h2 id="4）命令行参数；-什么是-YAML？"><a href="#4）命令行参数；-什么是-YAML？" class="headerlink" title="4）命令行参数； 什么是 YAML？"></a>4）命令行参数； 什么是 YAML？</h2><p>YAML 是一种人类可读的数据序列化语言。它通常用于配置文件。与属性文件相比，如果我们想要在配置文件中添加复杂的属性，YAML 文件就更加结构化，而且更少混淆。可以看出 YAML 具有分层配置数据。</p><h2 id="YAML-配置的优势在哪里"><a href="#YAML-配置的优势在哪里" class="headerlink" title="YAML 配置的优势在哪里 ?"></a>YAML 配置的优势在哪里 ?</h2><p>YAML 现在可以算是非常流行的一种配置文件格式了，无论是前端还是后端，都可以见到 YAML 配置。那么 YAML 配置和传统的 properties 配置相比到底有哪些优势呢？</p><ol><li><p>配置有序，在一些特殊的场景下，配置有序很关键</p></li><li><p>支持数组，数组中的元素可以是基本数据类型也可以是对象</p></li><li><p>简洁</p></li></ol><p>相比 properties 配置文件，YAML 还有一个缺点，就是不支持 @PropertySource 注解导入自定义的 YAML 配置。</p><h2 id="Spring-Boot-是否可以使用-XML-配置"><a href="#Spring-Boot-是否可以使用-XML-配置" class="headerlink" title="Spring Boot 是否可以使用 XML 配置 ?"></a>Spring Boot 是否可以使用 XML 配置 ?</h2><p>Spring Boot 推荐使用 Java 配置而非 XML 配置，但是 Spring Boot 中也可以使用 XML 配置，通过 @ImportResource 注解可以引入一个 XML 配置。 spring boot 核心配置文件是什么？</p><p>bootstrap.properties 和 application.properties 有何区别 ?</p><p>单纯做 Spring Boot 开发，可能不太容易遇到 bootstrap.properties 配置文</p><p>件，但是在结合 Spring Cloud 时，这个配置就会经常遇到了，特别是在需要加载一些远程配置文件的时侯。</p><p>spring boot 核心的两个配置文件：</p><p> bootstrap (. yml 或者 . properties)：boostrap 由父 ApplicationContext 加载的，比 applicaton 优先加载，配置在应用程序上下文的引导阶段生效。一般来说我们在 Spring Cloud Config 或者 Nacos 中会用到它。且 boostrap 里面的属性不</p><p>能被覆盖；</p><p> application (. yml 或者 . properties)： 由ApplicatonContext 加载，用于 spring boot 项目的自动化配置。</p><h2 id="什么是-Spring-Profiles？"><a href="#什么是-Spring-Profiles？" class="headerlink" title="什么是 Spring Profiles？"></a>什么是 Spring Profiles？</h2><p>Spring Profiles 允许用户根据配置文件（dev，test，prod 等）来注册 bean。因此，当应用程序在开发中运行时，只有某些 bean 可以加载，而在</p><p>PRODUCTION中，某些其他 bean 可以加载。假设我们的要求是 Swagger 文档仅适用于 QA 环境，并且禁用所有其他文档。这可以使用配置文件来完成。Spring Boot 使得使用配置文件非常简单。</p><h2 id="如何在自定义端口上运行-Spring-Boot-应用程序？"><a href="#如何在自定义端口上运行-Spring-Boot-应用程序？" class="headerlink" title="如何在自定义端口上运行 Spring Boot 应用程序？"></a>如何在自定义端口上运行 Spring Boot 应用程序？</h2><p>为了在自定义端口上运行 Spring Boot 应用程序，您可以在</p><p>application.properties 中指定端口。server.port &#x3D; 8090</p><h1 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h1><h2 id="如何实现-Spring-Boot-应用程序的安全性？"><a href="#如何实现-Spring-Boot-应用程序的安全性？" class="headerlink" title="如何实现 Spring Boot 应用程序的安全性？"></a>如何实现 Spring Boot 应用程序的安全性？</h2><p>为了实现 Spring Boot 的安全性，我们使用 spring-boot-starter-security 依赖项，并且必须添加安全配置。它只需要很少的代码。配置类将必须扩展</p><p>WebSecurityConfigurerAdapter 并覆盖其方法。</p><h2 id="Spring-Boot-中如何解决跨域问题"><a href="#Spring-Boot-中如何解决跨域问题" class="headerlink" title="Spring Boot 中如何解决跨域问题 ?"></a>Spring Boot 中如何解决跨域问题 ?</h2><p>跨域可以在前端通过 JSONP 来解决，但是 JSONP 只可以发送 GET 请求，无法发送其他类型的请求，在 RESTful 风格的应用中，就显得非常鸡肋，因此我们推荐在后端通过 （CORS，Cross-origin resource sharing） 来解决跨域问题。这种解决方案并非 Spring Boot 特有的，在传统的 SSM 框架中，就可以通过 CORS 来解决跨域问题，只不过之前我们是在 XML 文件中配置 CORS ，现在可以通过实现WebMvcConfigurer接口然后重写addCorsMappings方法解决跨域问题。</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span> @Configuration<br><span class="hljs-symbol">2 </span> public class CorsConfig implements WebMvcConfigurer &#123; <span class="hljs-number">3</span><br><span class="hljs-symbol">4 </span>  @Override<br><span class="hljs-symbol">5 </span>  public void addCorsMappings(CorsRegistry registry) &#123;<br><span class="hljs-symbol">6 </span>  registry.addMapping(<span class="hljs-string">&quot;/**&quot;</span>)<br><span class="hljs-symbol">7 </span>  .allowedOrigins(<span class="hljs-string">&quot;*&quot;</span>)<br><span class="hljs-symbol">8 </span>  .allowCredentials(true)<br><span class="hljs-symbol">9 </span>  .allowedMethods(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;POST&quot;</span>, <span class="hljs-string">&quot;PUT&quot;</span>, <span class="hljs-string">&quot;DELETE&quot;</span>, <span class="hljs-string">&quot;OPTIONS&quot;</span>)<br><span class="hljs-symbol">10 </span>  .maxAge(<span class="hljs-number">3600</span>);<br><span class="hljs-symbol">11 </span>  &#125; <br><span class="hljs-number">12</span><br><span class="hljs-symbol">13 </span> &#125;<br></code></pre></td></tr></table></figure><p>项目中前后端分离部署，所以需要解决跨域的问题。</p><p>我们使用cookie存放用户登录的信息，在spring拦截器进行权限控制，当权限不符合时，直接返回给用户固定的json结果。</p><p>当用户登录以后，正常使用；当用户退出登录状态时或者token过期时，由于拦截器和跨域的顺序有问题，出现了跨域的现象。</p><p>我们知道一个http请求，先走filter，到达servlet后才进行拦截器的处理，如果我们把cors放在filter里，就可以优先于权限拦截器执行。</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span> @Configuration<br><span class="hljs-symbol">2 </span> public class CorsConfig &#123; <span class="hljs-number">3</span><br><span class="hljs-symbol">4 </span>  @Bean<br><span class="hljs-symbol">5 </span>  public CorsFilter corsFilter() &#123;<br><span class="hljs-symbol">6 </span>  CorsConfiguration corsConfiguration = <span class="hljs-keyword">new</span> CorsConfiguration();<br><span class="hljs-symbol">7 </span>  corsConfiguration.addAllowedOrigin(<span class="hljs-string">&quot;*&quot;</span>);<br><span class="hljs-symbol">8 </span>  corsConfiguration.addAllowedHeader(<span class="hljs-string">&quot;*&quot;</span>);<br><span class="hljs-symbol">9 </span>  corsConfiguration.addAllowedMethod(<span class="hljs-string">&quot;*&quot;</span>);<br><span class="hljs-symbol">10 </span>  corsConfiguration.setAllowCredentials(true);<br><span class="hljs-symbol">11 </span>  UrlBasedCorsConfigurationSource urlBasedCorsConfigurationSource = <span class="hljs-keyword">new</span> U rlBasedCorsConfigurationSource();<br><span class="hljs-symbol">12 </span>  urlBasedCorsConfigurationSource.registerCorsConfiguration(<span class="hljs-string">&quot;/**&quot;</span>, corsCo nfiguration);<br><span class="hljs-symbol">13 </span>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CorsFilter(urlBasedCorsConfigurationSource);<br><span class="hljs-symbol">14 </span>  &#125; <br><span class="hljs-number">15</span><br><span class="hljs-symbol">16 </span> &#125;<br></code></pre></td></tr></table></figure><h2 id="什么是-CSRF-攻击？"><a href="#什么是-CSRF-攻击？" class="headerlink" title="什么是 CSRF 攻击？"></a>什么是 CSRF 攻击？</h2><p>CSRF 代表跨站请求伪造。这是一种攻击，迫使 终用户在当前通过身份验证的 Web 应用程序上执行不需要的操作。CSRF 攻击专门针对状态改变请求，而不是数据窃取，因为攻击者无法查看对伪造请求的响应。</p><h1 id="监视器"><a href="#监视器" class="headerlink" title="监视器"></a>监视器</h1><h2 id="Spring-Boot-中的监视器是什么？"><a href="#Spring-Boot-中的监视器是什么？" class="headerlink" title="Spring Boot 中的监视器是什么？"></a>Spring Boot 中的监视器是什么？</h2><p>Spring boot actuator 是 spring 启动框架中的重要功能之一。Spring boot 监视器可帮助您访问生产环境中正在运行的应用程序的当前状态。有几个指标必须在生产环境中进行检查和监控。即使一些外部应用程序可能正在使用这些服务来向相关人员触发警报消息。监视器模块公开了一组可直接作为 HTTP URL 访问 的REST 端点来检查状态。</p><p>如何在 Spring Boot 中禁用 Actuator 端点安全性？</p><p>默认情况下，所有敏感的 HTTP 端点都是安全的，只有具有 ACTUATOR 角色</p><p>的用户才能访问它们。安全性是使用标准的 HttpServletRequest.isUserInRole 方法实施的。 我们可以使用来禁用安全性。只有在执行机构端点在防火墙后访问时，才建议禁用安全性。</p><h2 id="我们如何监视所有-Spring-Boot-微服务？"><a href="#我们如何监视所有-Spring-Boot-微服务？" class="headerlink" title="我们如何监视所有 Spring Boot 微服务？"></a>我们如何监视所有 Spring Boot 微服务？</h2><p>Spring Boot 提供监视器端点以监控各个微服务的度量。这些端点对于获取有关应用程序的信息（如它们是否已启动）以及它们的组件（如数据库等）是否正常运行很有帮助。但是，使用监视器的一个主要缺点或困难是，我们必须单独打开应用程序的知识点以了解其状态或健康状况。想象一下涉及 50 个应用程序的微服务，管理员将不得不击中所有 50 个应用程序的执行终端。为了帮助我们处理这种情况，我们将使用位于的开源项目。 它建立在 Spring Boot Actuator 之上，它提供了一个 Web UI，使我们能够可视化多个应用程序的度量。</p><h1 id="整合第三方项目"><a href="#整合第三方项目" class="headerlink" title="整合第三方项目"></a>整合第三方项目</h1><h2 id="什么是-WebSockets？"><a href="#什么是-WebSockets？" class="headerlink" title="什么是 WebSockets？"></a>什么是 WebSockets？</h2><p>WebSocket 是一种计算机通信协议，通过单个 TCP 连接提供全双工通信信道。</p><p>1、     WebSocket 是双向的 -使用 WebSocket 客户端或服务器可以发起消息发送。</p><p>2、     WebSocket 是全双工的 -客户端和服务器通信是相互独立的。</p><p>3、     单个 TCP 连接 -初始连接使用 HTTP，然后将此连接升级到基于套接字的连接。然后这个单一连接用于所有未来的通信</p><p>4、     Light -与 http 相比，WebSocket 消息数据交换要轻得多。</p><p>什么是 Spring Data ?</p><p>Spring Data 是 Spring 的一个子项目。用于简化数据库访问，支持NoSQL 和 关系数据存储。其主要目标是使数据库的访问变得方便快捷。Spring Data 具有如下特点：</p><p>SpringData 项目支持 NoSQL 存储：</p><ol><li><p>MongoDB （文档数据库）</p></li><li><p>Neo4j（图形数据库）</p></li><li><p>Redis（键&#x2F;值存储）</p></li><li><p>Hbase（列族数据库）</p></li></ol><p>SpringData 项目所支持的关系数据存储技术：</p><ol><li><p>JDBC</p></li><li><p>JPA</p></li></ol><p>Spring Data Jpa 致力于减少数据访问层 (DAO) 的开发量. 开发者唯一要做的，就是声明持久层的接口，其他都交给 Spring Data JPA 来帮你完成！Spring Data JPA 通过规范方法的名字，根据符合规范的名字来确定方法需要实现什么样的逻辑。</p><h2 id="什么是-Spring-Batch？"><a href="#什么是-Spring-Batch？" class="headerlink" title="什么是 Spring Batch？"></a>什么是 Spring Batch？</h2><p>Spring Boot Batch 提供可重用的函数，这些函数在处理大量记录时非常重要，包括日志&#x2F;跟踪，事务管理，作业处理统计信息，作业重新启动，跳过和资源管理。它还提供了更先进的技术服务和功能，通过优化和分区技术，可以实现极高批量和高性能批处理作业。简单以及复杂的大批量批处理作业可以高度可扩展的方式利用框架处理重要大量的信息。</p><h2 id="什么是-FreeMarker-模板？"><a href="#什么是-FreeMarker-模板？" class="headerlink" title="什么是 FreeMarker 模板？"></a>什么是 FreeMarker 模板？</h2><p>FreeMarker 是一个基于 Java 的模板引擎，  初专注于使用 MVC 软件架构进行动态网页生成。使用 Freemarker 的主要优点是表示层和业务层的完全分离。程序员可以处理应用程序代码，而设计人员可以处理 html 页面设计。 后使用 freemarker 可以将这些结合起来，给出  终的输出页面。</p><h2 id="如何集成-Spring-Boot-和-ActiveMQ？"><a href="#如何集成-Spring-Boot-和-ActiveMQ？" class="headerlink" title="如何集成 Spring Boot 和 ActiveMQ？"></a>如何集成 Spring Boot 和 ActiveMQ？</h2><p>对于集成 Spring Boot 和 ActiveMQ，我们使用依赖关系。 它只需要很少的配置，并且不需要样板代码。</p><h2 id="什么是-Apache-Kafka？"><a href="#什么是-Apache-Kafka？" class="headerlink" title="什么是 Apache Kafka？"></a>什么是 Apache Kafka？</h2><p>Apache Kafka 是一个分布式发布 - 订阅消息系统。它是一个可扩展的，容错的发布 - 订阅消息系统，它使我们能够构建分布式应用程序。这是一个 Apache 顶级项目。Kafka 适合离线和在线消息消费。</p><h2 id="什么是-Swagger？你用-Spring-Boot-实现了它吗？"><a href="#什么是-Swagger？你用-Spring-Boot-实现了它吗？" class="headerlink" title="什么是 Swagger？你用 Spring Boot 实现了它吗？"></a>什么是 Swagger？你用 Spring Boot 实现了它吗？</h2><p>Swagger 广泛用于可视化 API，使用 Swagger UI 为前端开发人员提供在线沙箱。Swagger 是用于生成 RESTful Web 服务的可视化表示的工具，规范和完整框架实现。它使文档能够以与服务器相同的速度更新。当通过 Swagger 正确定义时，消费者可以使用 少量的实现逻辑来理解远程服务并与其进行交互。因此，Swagger消除了调用服务时的猜测。</p><p>前后端分离，如何维护接口文档 ?</p><p>前后端分离开发日益流行，大部分情况下，我们都是通过 Spring Boot 做前后端分离开发，前后端分离一定会有接口文档，不然会前后端会深深陷入到扯皮中。一个比较笨的方法就是使用 word 或者 md 来维护接口文档，但是效率太低，接口一变，所有人手上的文档都得变。在 Spring Boot 中，这个问题常见</p><p>的解决方案是 Swagger ，使用 Swagger 我们可以快速生成一个接口文档网</p><p>站，接口一旦发生变化，文档就会自动更新，所有开发工程师访问这一个在线网站就可以获取到 新的接口文档，非常方便。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="如何重新加载-Spring-Boot-上的更改，而无需重新启动服务器？Spring-Boot项目如何热部署？"><a href="#如何重新加载-Spring-Boot-上的更改，而无需重新启动服务器？Spring-Boot项目如何热部署？" class="headerlink" title="如何重新加载 Spring Boot 上的更改，而无需重新启动服务器？Spring Boot项目如何热部署？"></a>如何重新加载 Spring Boot 上的更改，而无需重新启动服务器？Spring Boot项目如何热部署？</h2><p>这可以使用 DEV 工具来实现。通过这种依赖关系，您可以节省任何更改，嵌入式tomcat 将重新启动。Spring Boot 有一个开发工具（DevTools）模块，它有助于提高开发人员的生产力。Java 开发人员面临的一个主要挑战是将文件更改自动部署到服务器并自动重启服务器。开发人员可以重新加载 Spring Boot 上的更改，而无需重新启动服务器。这将消除每次手动部署更改的需要。</p><p>Spring Boot 在发布它的第一个版本时没有这个功能。这是开发人员 需要的功能。DevTools 模块完全满足开发人员的需求。该模块将在生产环境中被禁用。</p><p>它还提供 H2 数据库控制台以更好地测试应用程序。</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>&lt;dependency&gt;<br><span class="hljs-symbol">2 </span>  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br><span class="hljs-symbol">3 </span>  &lt;artifactId&gt;spring‐boot‐devtools&lt;/artifactId&gt;<br><span class="hljs-symbol">4 </span> &lt;/dependency&gt;<br></code></pre></td></tr></table></figure><h2 id="您使用了哪些-starter-maven-依赖项？"><a href="#您使用了哪些-starter-maven-依赖项？" class="headerlink" title="您使用了哪些 starter maven 依赖项？"></a>您使用了哪些 starter maven 依赖项？</h2><p>使用了下面的一些依赖项</p><p>spring-boot-starter-activemq</p><p>spring-boot-starter-security</p><p>这有助于增加更少的依赖关系，并减少版本的冲突。</p><p>Spring Boot 中的 starter 到底是什么 ?</p><p>首先，这个 Starter 并非什么新的技术点，基本上还是基于 Spring 已有功能来实现的。首先它提供了一个自动化配置类，一般命名为 XXXAutoConfiguration </p><p>，在这个配置类中通过条件注解来决定一个配置是否生效（条件注解就是 </p><p>Spring 中原本就有的），然后它还会提供一系列的默认配置，也允许开发者根据实际情况自定义相关配置，然后通过类型安全的属性注入将这些配置属性注入进来，新注入的属性会代替掉默认属性。正因为如此，很多第三方框架，我们只需要引入依赖就可以直接使用了。当然，开发者也可以自定义 Starter spring-boot-starter-parent 有什么用 ?</p><p>我们都知道，新创建一个 Spring Boot 项目，默认都是有 parent 的，这个 </p><p>parent 就是 spring-boot-starter-parent ，spring-boot-starter-parent 主要有如下作用：</p><ol><li><p>定义了 Java 编译版本为 1.8 。</p></li><li><p>使用 UTF-8 格式编码。</p></li><li><p>继承自 spring-boot-dependencies，这个里边定义了依赖的版本，也正是因为继承了这个依赖，所以我们在写依赖时才不需要写版本号。</p></li><li><p>执行打包操作的配置。</p></li><li><p>自动化的资源过滤。</p></li><li><p>自动化的插件配置。</p></li><li><p>针对 application.properties 和 application.yml 的资源过滤，包括通过 profile 定义的不同环境的配置文件，例如 applicationdev.properties 和 application-dev.yml。</p></li></ol><p>Spring Boot 打成的 jar 和普通的 jar 有什么区别 ?</p><p>Spring Boot 项目  终打包成的 jar 是可执行 jar ，这种 jar 可以直接通过 java jar xxx.jar 命令来运行，这种 jar 不可以作为普通的 jar 被其他项目依赖，即使依赖了也无法使用其中的类。</p><p>Spring Boot 的 jar 无法被其他项目依赖，主要还是他和普通 jar 的结构不同。普通的 jar 包，解压后直接就是包名，包里就是我们的代码，而 Spring Boot </p><p>打包成的可执行 jar 解压后，在 \BOOT-INF\classes 目录下才是我们的代码，因此无法被直接引用。如果非要引用，可以在 pom.xml 文件中增加配置，将 Spring Boot 项目打包成两个 jar ，一个可执行，一个可引用。</p><h2 id="运行-Spring-Boot-有哪几种方式？"><a href="#运行-Spring-Boot-有哪几种方式？" class="headerlink" title="运行 Spring Boot 有哪几种方式？"></a>运行 Spring Boot 有哪几种方式？</h2><p>1）     打包用命令或者放到容器中运行</p><p>2）     用 Maven&#x2F; Gradle 插件运行</p><p>3）直接执行 main 方法运行</p><h2 id="Spring-Boot-需要独立的容器运行吗？"><a href="#Spring-Boot-需要独立的容器运行吗？" class="headerlink" title="Spring Boot 需要独立的容器运行吗？"></a>Spring Boot 需要独立的容器运行吗？</h2><h2 id="开启-Spring-Boot-特性有哪几种方式？"><a href="#开启-Spring-Boot-特性有哪几种方式？" class="headerlink" title="开启 Spring Boot 特性有哪几种方式？"></a>开启 Spring Boot 特性有哪几种方式？</h2><p>1）     继承spring-boot-starter-parent项目</p><p>2）     导入spring-boot-dependencies项目依赖</p><h2 id="如何使用-Spring-Boot-实现异常处理？"><a href="#如何使用-Spring-Boot-实现异常处理？" class="headerlink" title="如何使用 Spring Boot 实现异常处理？"></a>如何使用 Spring Boot 实现异常处理？</h2><p>Spring 提供了一种使用 ControllerAdvice 处理异常的非常有用的方法。 我们通过实现一个 ControlerAdvice 类，来处理控制器类抛出的所有异常。</p><h2 id="如何使用-Spring-Boot-实现分页和排序？"><a href="#如何使用-Spring-Boot-实现分页和排序？" class="headerlink" title="如何使用 Spring Boot 实现分页和排序？"></a>如何使用 Spring Boot 实现分页和排序？</h2><p>使用 Spring Boot 实现分页非常简单。使用 Spring Data-JPA 可以实现将可分页的传递给存储库方法。</p><p>微服务中如何实现 session 共享 ?</p><p>在微服务中，一个完整的项目被拆分成多个不相同的独立的服务，各个服务独立部署在不同的服务器上，各自的 session 被从物理空间上隔离开了，但是经</p><p>常，我们需要在不同微服务之间共享 session ，常见的方案就是 Spring </p><p>Session + Redis 来实现 session 共享。将所有微服务的 session 统一保存在 Redis 上，当各个微服务对 session 有相关的读写操作时，都去操作 Redis 上的 session 。这样就实现了 session 共享，Spring Session 基于 Spring 中的代理过滤器实现，使得 session 的同步操作对开发人员而言是透明的，非常简便。</p><h2 id="Spring-Boot-中如何实现定时任务"><a href="#Spring-Boot-中如何实现定时任务" class="headerlink" title="Spring Boot 中如何实现定时任务 ?"></a>Spring Boot 中如何实现定时任务 ?</h2><p>定时任务也是一个常见的需求，Spring Boot 中对于定时任务的支持主要还是来自 Spring 框架。</p><p>在 Spring Boot 中使用定时任务主要有两种不同的方式，一个就是使用 Spring 中的 @Scheduled 注解，另一个则是使用第三方框架 Quartz。</p><p>使用 Spring 中的 @Scheduled 的方式主要通过 @Scheduled 注解来实现。</p><p>使用 Quartz ，则按照 Quartz 的方式，定义 Job 和 Trigger 即可。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>spring面经</title>
    <link href="/2024/04/10/spring%E9%9D%A2%E7%BB%8F/"/>
    <url>/2024/04/10/spring%E9%9D%A2%E7%BB%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring面试专题"><a href="#Spring面试专题" class="headerlink" title="Spring面试专题"></a>Spring面试专题</h1><p>答题技巧：</p><p>总：当前问题回答的是那些具体的点</p><p>分：以1，2，3，4，5的方式分细节取描述相关的知识点，如果有哪些点不清楚，直接忽略过去</p><p>​突出一些技术名词（核心概念，接口，类，关键方法）</p><p>​避重就轻：没有重点</p><p>一个问题能占用面试官多少时间？问的越多可能露馅越多</p><p>当面试官问到一个你熟悉的点的时候，一定要尽量拖时间</p><h1 id="1-谈谈你对SpringIOC的理解，原理和实现两方面"><a href="#1-谈谈你对SpringIOC的理解，原理和实现两方面" class="headerlink" title="1.谈谈你对SpringIOC的理解，原理和实现两方面"></a>1.谈谈你对SpringIOC的理解，原理和实现两方面</h1><p><strong>总：</strong></p><p>控制反转：理论思想，原来的对象是由使用者来进行控制，有了spring之后，可以把整个对象交给spring来帮我们进行管理</p><p>​DI：依赖注入，把对应的属性的值注入到具体的对象中，@Autowired，populateBean完成属性值的注入</p><p>容器：存储对象，使用map结构来存储，在spring中一般存在三级缓存，singletonObjects存放完整的bean对象,</p><p>​整个bean的生命周期，从创建到使用到销毁的过程全部都是由容器来管理（bean的生命周期）</p><p><strong>分：</strong></p><p>1、一般聊ioc容器的时候要涉及到容器的创建过程（beanFactory,DefaultListableBeanFactory）,向bean工厂中设置一些参数（BeanPostProcessor,Aware接口的子类）等等属性</p><p>2、加载解析bean对象，准备要创建的bean对象的定义对象beanDefinition,(xml或者注解的解析过程)</p><p>3、beanFactoryPostProcessor的处理，此处是扩展点，PlaceHolderConfigurSupport,ConfigurationClassPostProcessor</p><p>4、BeanPostProcessor的注册功能，方便后续对bean对象完成具体的扩展功能</p><p>5、通过反射的方式讲BeanDefinition对象实例化成具体的bean对象，</p><p>6、bean对象的初始化过程（填充属性，调用aware子类的方法，调用BeanPostProcessor前置处理方法，调用init-mehtod方法，调用BeanPostProcessor的后置处理方法）</p><p>7、生成完整的bean对象，通过getBean方法可以直接获取</p><p>8、销毁过程</p><p>面试官，这是我对ioc的整体理解，包含了一些详细的处理过程，您看一下有什么问题，可以指点我一下（允许你把整个流程说完）</p><p>您由什么想问的？</p><p>​老师，我没看过源码怎么办？</p><p>​具体的细节我记不太清了，但是spring中的bean都是通过反射的方式生成的，同时其中包含了很多的扩展点，比如最常用的对BeanFactory的扩展，对bean的扩展（对占位符的处理），我们在公司对这方面的使用是比较多的，除此之外，ioc中最核心的也就是填充具体bean的属性，和生命周期（背一下）。</p><h1 id="2-谈谈你对Spring中Bean对象生命周期的理解"><a href="#2-谈谈你对Spring中Bean对象生命周期的理解" class="headerlink" title="2.谈谈你对Spring中Bean对象生命周期的理解"></a>2.谈谈你对Spring中Bean对象生命周期的理解</h1><p>底层实现：工作原理，过程，数据结构，流程，设计模式，设计思想</p><p>你对他的理解和你了解过的实现过程</p><p>反射，工厂，设计模式（会的说，不会的不说），关键的几个方法</p><p>createBeanFactory，getBean,doGetBean,createBean,doCreateBean,createBeanInstance(getDeclaredConstructor,newinstance),populateBean,initializingBean</p><p>1、先通过createBeanFactory创建出一个Bean工厂（DefaultListableBeanFactory）</p><p>2、开始循环创建对象，因为容器中的bean默认都是单例的，所以优先通过getBean,doGetBean从容器中查找，找不到的话，</p><p>3、通过createBean,doCreateBean方法，以反射的方式创建对象，一般情况下使用的是无参的构造方法（getDeclaredConstructor，newInstance）</p><p>4、进行对象的属性填充populateBean</p><p>5、进行其他的初始化操作（initializingBean）</p><h1 id="3-谈谈你对Spring中Bean对象生命周期的理解"><a href="#3-谈谈你对Spring中Bean对象生命周期的理解" class="headerlink" title="3.谈谈你对Spring中Bean对象生命周期的理解"></a>3.谈谈你对Spring中Bean对象生命周期的理解</h1><p>背图：记住图中的流程</p><p>在表述的时候不要只说图中有的关键点，要学会扩展描述</p><p>1、实例化bean：反射的方式生成对象</p><p>2、填充bean的属性：populateBean(),循环依赖的问题（三级缓存）</p><p>3、调用aware接口相关的方法：invokeAwareMethod(完成BeanName,BeanFactory,BeanClassLoader对象的属性设置)</p><p>4、调用BeanPostProcessor中的前置处理方法：使用比较多的有（ApplicationContextPostProcessor,设置ApplicationContext,Environment,ResourceLoader,EmbeddValueResolver等对象）</p><p>5、调用initmethod方法：invokeInitmethod(),判断是否实现了initializingBean接口，如果有，调用afterPropertiesSet方法，没有就不调用</p><p>6、调用BeanPostProcessor的后置处理方法：spring的aop就是在此处实现的，AbstractAutoProxyCreator</p><p>​注册Destuction相关的回调接口：钩子函数</p><p>7、获取到完整的对象，可以通过getBean的方式来进行对象的获取</p><p>8、销毁流程，1；判断是否实现了DispoableBean接口，2，调用destroyMethod方法</p><h1 id="4-谈谈你对Spring中解决循环依赖的理解"><a href="#4-谈谈你对Spring中解决循环依赖的理解" class="headerlink" title="4.谈谈你对Spring中解决循环依赖的理解"></a>4.谈谈你对Spring中解决循环依赖的理解</h1><p>三级缓存，提前暴露对象，aop</p><p>总：什么是循环依赖问题，A依赖B,B依赖A</p><p>分：先说明bean的创建过程：实例化，初始化（填充属性）</p><p>​1、先创建A对象，实例化A对象，此时A对象中的b属性为空，填充属性b</p><p>​2、从容器中查找B对象，如果找到了，直接赋值不存在循环依赖问题（不通），找不到直接创建B对象</p><p>​3、实例化B对象，此时B对象中的a属性为空，填充属性a</p><p>​4、从容器中查找A对象，找不到，直接创建</p><p>​形成闭环的原因</p><p>​此时，如果仔细琢磨的话，会发现A对象是存在的，只不过此时的A对象不是一个完整的状态，只完成了实例化但是未完成初始化，如果在程序调用过程中，拥有了某个对象的引用，能否在后期给他完成赋值操作，可以优先把非完整状态的对象优先赋值，等待后续操作来完成赋值，相当于提前暴露了某个不完整对象的引用，所以解决问题的核心在于实例化和初始化分开操作，这也是解决循环依赖问题的关键，</p><p>​当所有的对象都完成实例化和初始化操作之后，还要把完整对象放到容器中，此时在容器中存在对象的几个状态，完成实例化&#x3D;但未完成初始化，完整状态，因为都在容器中，所以要使用不同的map结构来进行存储，此时就有了一级缓存和二级缓存，如果一级缓存中有了，那么二级缓存中就不会存在同名的对象，因为他们的查找顺序是1，2，3这样的方式来查找的。一级缓存中放的是完整对象，二级缓存中放的是非完整对象</p><p>​为什么需要三级缓存？三级缓存的value类型是ObjectFactory,是一个函数式接口，存在的意义是保证在整个容器的运行过程中同名的bean对象只能有一个。</p><p>​如果一个对象需要被代理，或者说需要生成代理对象，那么要不要优先生成一个普通对象？要</p><p>​普通对象和代理对象是不能同时出现在容器中的，因此当一个对象需要被代理的时候，就要使用代理对象覆盖掉之前的普通对象，在实际的调用过程中，是没有办法确定什么时候对象被使用，所以就要求当某个对象被调用的时候，优先判断此对象是否需要被代理，类似于一种回调机制的实现，因此传入lambda表达式的时候，可以通过lambda表达式来执行对象的覆盖过程，getEarlyBeanReference()</p><p>​因此，所有的bean对象在创建的时候都要优先放到三级缓存中，在后续的使用过程中，如果需要被代理则返回代理对象，如果不需要被代理，则直接返回普通对象</p><h1 id="5-谈谈你对Spring中三级缓存和二级缓存的理解"><a href="#5-谈谈你对Spring中三级缓存和二级缓存的理解" class="headerlink" title="5.谈谈你对Spring中三级缓存和二级缓存的理解"></a>5.谈谈你对Spring中三级缓存和二级缓存的理解</h1><p>​三级缓存：createBeanInstance之后：addSingletonFactory</p><p>​二级缓存：第一次从三级缓存确定对象是代理对象还是普通对象的时候，同时删除三级缓存 getSingleton</p><p>​一级缓存：生成完整对象之后放到一级缓存，删除二三级缓存:addSingleton</p><h1 id="6-谈谈你对Bean-Factory和FactoryBean的理解"><a href="#6-谈谈你对Bean-Factory和FactoryBean的理解" class="headerlink" title="6.谈谈你对Bean Factory和FactoryBean的理解"></a>6.谈谈你对Bean Factory和FactoryBean的理解</h1><p>相同点：都是用来创建bean对象的</p><p>不同点：使用BeanFactory创建对象的时候，必须要遵循严格的生命周期流程，太复杂了，，如果想要简单的自定义某个对象的创建，同时创建完成的对象想交给spring来管理，那么就需要实现FactroyBean接口了</p><p>​isSingleton:是否是单例对象</p><p>​getObjectType:获取返回对象的类型</p><p>​getObject:自定义创建对象的过程(new，反射，动态代理)</p><h1 id="7-Spring中用到了哪些设计模式"><a href="#7-Spring中用到了哪些设计模式" class="headerlink" title="7.Spring中用到了哪些设计模式?"></a>7.Spring中用到了哪些设计模式?</h1><p>单例模式：bean默认都是单例的</p><p>原型模式：指定作用域为prototype</p><p>工厂模式：BeanFactory</p><p>模板方法：postProcessBeanFactory,onRefresh,initPropertyValue</p><p>策略模式：XmlBeanDefinitionReader,PropertiesBeanDefinitionReader</p><p>观察者模式：listener，event，multicast</p><p>适配器模式：Adapter</p><p>装饰者模式：BeanWrapper</p><p>责任链模式：使用aop的时候会先生成一个拦截器链</p><p>代理模式：动态代理</p><p>委托者模式：delegate</p><p>。。。。。。。。。</p><h1 id="8-谈谈你对Spring中AOP的理解"><a href="#8-谈谈你对Spring中AOP的理解" class="headerlink" title="8.谈谈你对Spring中AOP的理解"></a>8.谈谈你对Spring中AOP的理解</h1><p>动态代理</p><p>aop是ioc的一个扩展功能，先有的ioc，再有的aop，只是在ioc的整个流程中新增的一个扩展点而已：BeanPostProcessor</p><p>总：aop概念，应用场景，动态代理</p><p>分：</p><p>​bean的创建过程中有一个步骤可以对bean进行扩展实现，aop本身就是一个扩展功能，所以在BeanPostProcessor的后置处理方法中来进行实现</p><p>​1、代理对象的创建过程（advice，切面，切点）</p><p>​2、通过jdk或者cglib的方式来生成代理对象</p><p>​3、在执行方法调用的时候，会调用到生成的字节码文件中，直接回找到DynamicAdvisoredInterceptor类中的intercept方法，从此方法开始执行</p><p>​4、根据之前定义好的通知来生成拦截器链</p><p>​5、从拦截器链中依次获取每一个通知开始进行执行，在执行过程中，为了方便找到下一个通知是哪个，会有一个CglibMethodInvocation的对象，找的时候是从-1的位置一次开始查找并且执行的。</p><h1 id="9-谈谈你对Spring中事务这块的理解"><a href="#9-谈谈你对Spring中事务这块的理解" class="headerlink" title="9.谈谈你对Spring中事务这块的理解"></a>9.谈谈你对Spring中事务这块的理解</h1><p>​spring的事务管理是如何实现的？</p><p>​总：spring的事务是由aop来实现的，首先要生成具体的代理对象，然后按照aop的整套流程来执行具体的操作逻辑，正常情况下要通过通知来完成核心功能，但是事务不是通过通知来实现的，而是通过一个TransactionInterceptor来实现的，然后调用invoke来实现具体的逻辑</p><p>​分：1、先做准备工作，解析各个方法上事务相关的属性，根据具体的属性来判断是否开始新事务</p><p>​2、当需要开启的时候，获取数据库连接，关闭自动提交功能，开起事务</p><p>​3、执行具体的sql逻辑操作</p><p>​4、在操作过程中，如果执行失败了，那么会通过completeTransactionAfterThrowing看来完成事务的回滚操作，回滚的具体逻辑是通过doRollBack方法来实现的，实现的时候也是要先获取连接对象，通过连接对象来回滚</p><p>​5、如果执行过程中，没有任何意外情况的发生，那么通过commitTransactionAfterReturning来完成事务的提交操作，提交的具体逻辑是通过doCommit方法来实现的，实现的时候也是要获取连接，通过连接对象来提交</p><p>​6、当事务执行完毕之后需要清除相关的事务信息cleanupTransactionInfo</p><p>如果想要聊的更加细致的话，需要知道TransactionInfo,TransactionStatus,</p><h1 id="10-具体谈谈你对Spring中事务传播行为的理解"><a href="#10-具体谈谈你对Spring中事务传播行为的理解" class="headerlink" title="10.具体谈谈你对Spring中事务传播行为的理解"></a>10.具体谈谈你对Spring中事务传播行为的理解</h1><p>​传播特性有几种？7种</p><p>​Required,Requires_new,nested,Support,Not_Support,Never,Mandatory</p><p>​某一个事务嵌套另一个事务的时候怎么办？</p><p>​A方法调用B方法，AB方法都有事务，并且传播特性不同，那么A如果有异常，B怎么办，B如果有异常，A怎么办？</p><hr><p>​总：事务的传播特性指的是不同方法的嵌套调用过程中，事务应该如何进行处理，是用同一个事务还是不同的事务，当出现异常的时候会回滚还是提交，两个方法之间的相关影响，在日常工作中，使用比较多的是required，Requires_new,nested</p><p>​分：1、先说事务的不同分类，可以分为三类：支持当前事务，不支持当前事务，嵌套事务</p><p>​2、如果外层方法是required，内层方法是，required,requires_new,nested</p><p>​3、如果外层方法是requires_new，内层方法是，required,requires_new,nested</p><p>​4、如果外层方法是nested，内层方法是，required,requires_new,nested</p><p>​</p><hr><p>找工作：</p><p>1、面试之前一定要调整好心态，不管你会多少东西，干就完了，出去面试就一个心态，老子天下第一，让自己超常发挥</p><p>2、得失心不要太重，全中国企业很多，好公司也有很多，没必要在一棵树上吊死，你可以有心仪的公司，留到最后，等你准备充分再去</p><p>3、找工作永远不可能准备好，很多同学怂，心态不好，不敢出去面试，我要准备，先按照你的技术储备取尝试一些公司（我就是来试水的）面试回来之后做总结，做好准备，不断总结，复盘，这样才能成长</p><p>4、希望大家保持好信息互通，乐于分享</p><blockquote></blockquote><h1 id="Spring面试专题-1"><a href="#Spring面试专题-1" class="headerlink" title="Spring面试专题"></a>Spring面试专题</h1><h1 id="1-Spring应该很熟悉吧？来介绍下你的Spring的理解"><a href="#1-Spring应该很熟悉吧？来介绍下你的Spring的理解" class="headerlink" title="1.Spring应该很熟悉吧？来介绍下你的Spring的理解"></a>1.Spring应该很熟悉吧？来介绍下你的Spring的理解</h1><p>  有些同学可能会抢答，不熟悉!!!</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/1462/1646114654000/5dc1f730b32a4fc49922745f43a5c614.png" alt="image.png"></p><p>  好了，不开玩笑，面对这个问题我们应该怎么来回答呢？我们给大家梳理这个几个维度来回答</p><h2 id="1-1-Spring的发展历程"><a href="#1-1-Spring的发展历程" class="headerlink" title="1.1 Spring的发展历程"></a>1.1 Spring的发展历程</h2><p>  先介绍Spring是怎么来的，发展中有哪些核心的节点，当前的最新版本是什么等</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/1462/1646114654000/f401749c6b6c435d932f949067f0b252.png" alt="image.png"></p><p> 通过上图可以比较清晰的看到Spring的各个时间版本对应的时间节点了。也就是Spring从之前单纯的xml的配置方式，到现在的完全基于注解的编程方式发展。</p><h2 id="1-2-Spring的组成"><a href="#1-2-Spring的组成" class="headerlink" title="1.2 Spring的组成"></a>1.2 Spring的组成</h2><p>&emsp;&emsp;Spring是一个轻量级的IoC和AOP容器框架。是为Java应用程序提供基础性服务的一套框架，目的是用于简化企业应用程序的开发，它使得开发者只需要关心业务需求。常见的配置方式有三种：基于XML的配置、基于注解的配置、基于Java的配置.</p><p>主要由以下几个模块组成：</p><ul><li>Spring Core：核心类库，提供IOC服务；</li><li>Spring Context：提供框架式的Bean访问方式，以及企业级功能（JNDI、定时任务等）；</li><li>Spring AOP：AOP服务；</li><li>Spring DAO：对JDBC的抽象，简化了数据访问异常的处理；</li><li>Spring ORM：对现有的ORM框架的支持；</li><li>Spring Web：提供了基本的面向Web的综合特性，例如多方文件上传；</li><li>Spring MVC：提供面向Web应用的Model-View-Controller实现。</li></ul><p><img src="https://img-blog.csdnimg.cn/2019011310002937.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="1-3-Spring的好处"><a href="#1-3-Spring的好处" class="headerlink" title="1.3 Spring的好处"></a>1.3 Spring的好处</h2><table><thead><tr><th>序号</th><th>好处</th><th align="left">说明</th></tr></thead><tbody><tr><td>1</td><td>轻量</td><td align="left">Spring 是轻量的，基本的版本大约2MB。</td></tr><tr><td>2</td><td>控制反转</td><td align="left">Spring通过控制反转实现了松散耦合，对象们给出它们的依赖，<code>&lt;br&gt;</code>而不是创建或查找依赖的对象们。</td></tr><tr><td>3</td><td>面向切面编程(AOP)</td><td align="left">Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开。</td></tr><tr><td>4</td><td>容器</td><td align="left">Spring 包含并管理应用中对象的生命周期和配置。</td></tr><tr><td>5</td><td>MVC框架</td><td align="left">Spring的WEB框架是个精心设计的框架，是Web框架的一个很好的替代品。</td></tr><tr><td>6</td><td>事务管理</td><td align="left">Spring 提供一个持续的事务管理接口，<code>&lt;br&gt;</code>可以扩展到上至本地事务下至全局事务（JTA）。</td></tr><tr><td>7</td><td>异常处理</td><td align="left">Spring 提供方便的API把具体技术相关的异常 <code>&lt;br&gt;</code>(比如由JDBC，Hibernate or JDO抛出的)转化为一致的unchecked 异常。</td></tr><tr><td>8</td><td>最重要的</td><td align="left">用的人多！！！</td></tr></tbody></table><h1 id="2-Spring框架中用到了哪些设计模式"><a href="#2-Spring框架中用到了哪些设计模式" class="headerlink" title="2.Spring框架中用到了哪些设计模式"></a>2.Spring框架中用到了哪些设计模式</h1><h2 id="2-1-单例模式"><a href="#2-1-单例模式" class="headerlink" title="2.1 单例模式"></a>2.1 单例模式</h2><p>&emsp;&emsp;单例模式应该是大家印象最深的一种设计模式了。在Spring中最明显的使用场景是在配置文件中配置注册bean对象的时候<strong>设置scope的值为singleton</strong> 。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans </span></span><br><span class="hljs-string"><span class="hljs-tag"> http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.dpb.pojo.User&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;singleton&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;波波烤鸭&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h2 id="2-2-原型模式"><a href="#2-2-原型模式" class="headerlink" title="2.2 原型模式"></a>2.2 原型模式</h2><p>&emsp;&emsp;原型模式也叫克隆模式，Spring中该模式使用的很明显，和单例一样在bean标签中设置scope的属性prototype即表示该bean以克隆的方式生成</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans </span></span><br><span class="hljs-string"><span class="hljs-tag"> http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.dpb.pojo.User&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;prototype&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;波波烤鸭&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h2 id="2-3-模板模式"><a href="#2-3-模板模式" class="headerlink" title="2.3 模板模式"></a>2.3 模板模式</h2><p>&emsp;&emsp;模板模式的核心是父类定义好流程，然后将流程中需要子类实现的方法就抽象话留给子类实现，Spring中的JdbcTemplate就是这样的实现。我们知道jdbc的步骤是固定</p><ul><li>加载驱动,</li><li>获取连接通道,</li><li>构建sql语句.</li><li>执行sql语句,</li><li>关闭资源</li></ul><p>  在这些步骤中第3步和第四步是不确定的,所以就留给客户实现，而我们实际使用JdbcTemplate的时候也确实是只需要构建SQL就可以了.这就是典型的模板模式。我们以query方法为例来看下JdbcTemplate中的代码.</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/1462/1646114654000/a1f1150a38f94b518794e3e5df467092.png" alt="image.png"></p><h2 id="2-4-观察者模式"><a href="#2-4-观察者模式" class="headerlink" title="2.4 观察者模式"></a>2.4 观察者模式</h2><p>&emsp;&emsp;观察者模式定义的是对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。使用比较场景是在监听器中而spring中Observer模式常用的地方也是listener的实现。如ApplicationListener.</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/1462/1646114654000/32247ef6524c430dab31ea97294f28ae.png" alt="image.png"></p><h2 id="2-5-工厂模式"><a href="#2-5-工厂模式" class="headerlink" title="2.5 工厂模式"></a>2.5 工厂模式</h2><p><strong>简单工厂模式</strong>：</p><p>&emsp;&emsp;简单工厂模式就是通过工厂根据传递进来的参数决定产生哪个对象。Spring中我们通过getBean方法获取对象的时候根据id或者name获取就是简单工厂模式了。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">context:annotation-config</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.dpb.pojo.User&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span>  &gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;波波烤鸭&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p><strong>工厂方法模式</strong>：</p><p>&emsp;&emsp;在Spring中我们一般是将Bean的实例化直接交给容器去管理的，实现了使用和创建的分离，这时容器直接管理对象，还有种情况是，bean的创建过程我们交给一个工厂去实现，而Spring容器管理这个工厂。这个就是我们讲的工厂模式，在Spring中有两种实现一种是静态工厂方法模式，一种是动态工厂方法模式。以静态工厂来演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * User 工厂类</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> dpb[波波烤鸭]</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserFactory</span> &#123;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 必须是static方法</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> UserBean <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserBean</span>();<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>application.xml文件中注册</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans </span></span><br><span class="hljs-string"><span class="hljs-tag">http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 静态工厂方式配置 配置静态工厂及方法 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.dpb.factory.UserFactory&quot;</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">&quot;getInstance&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user2&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h2 id="2-6-适配器模式"><a href="#2-6-适配器模式" class="headerlink" title="2.6 适配器模式"></a>2.6 适配器模式</h2><p>&emsp;&emsp;将一个类的接口转换成客户希望的另外一个接口。使得原本由于接口不兼容而不能一起工作的那些类可以在一起工作。这就是适配器模式。在Spring中在AOP实现中的Advice和interceptor之间的转换就是通过适配器模式实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodBeforeAdviceAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AdvisorAdapter</span>, Serializable &#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">supportsAdvice</span><span class="hljs-params">(Advice advice)</span> &#123;<br><span class="hljs-keyword">return</span> (advice <span class="hljs-keyword">instanceof</span> MethodBeforeAdvice);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> MethodInterceptor <span class="hljs-title function_">getInterceptor</span><span class="hljs-params">(Advisor advisor)</span> &#123;<br><span class="hljs-type">MethodBeforeAdvice</span> <span class="hljs-variable">advice</span> <span class="hljs-operator">=</span> (MethodBeforeAdvice) advisor.getAdvice();<br><span class="hljs-comment">// 通知类型匹配对应的拦截器</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MethodBeforeAdviceInterceptor</span>(advice);<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="2-7-装饰者模式"><a href="#2-7-装饰者模式" class="headerlink" title="2.7 装饰者模式"></a>2.7 装饰者模式</h2><p>&emsp;&emsp;装饰者模式又称为包装模式(Wrapper),作用是用来动态的为一个对象增加新的功能。装饰模式是一种用于代替继承的技术，无须通过继承增加子类就能扩展对象的新功能。使用对象的关联关系代替继承关系，更加灵活，同时避免类型体系的快速膨胀。<br>&emsp;&emsp;spring中用到的包装器模式在类名上有两种表现：一种是类名中含有Wrapper，另一种是类名中含有Decorator。基本上都是动态地给一个对象添加一些额外的职责。<br>&emsp;&emsp;具体的使用在Spring session框架中的SessionRepositoryRequestWrapper使用包装模式对原生的request的功能进行增强，可以将session中的数据和分布式数据库进行同步，这样即使当前tomcat崩溃，session中的数据也不会丢失。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.session<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-session<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.1.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h2 id="2-8-代理模式"><a href="#2-8-代理模式" class="headerlink" title="2.8 代理模式"></a>2.8 代理模式</h2><p>&emsp;&emsp;代理模式应该是大家非常熟悉的设计模式了，在Spring中AOP的实现中代理模式使用的很彻底.</p><h2 id="2-9-策略模式"><a href="#2-9-策略模式" class="headerlink" title="2.9 策略模式"></a>2.9 策略模式</h2><p>&emsp;&emsp;策略模式对应于解决某一个问题的一个算法族，允许用户从该算法族中任选一个算法解决某一问题，同时可以方便的更换算法或者增加新的算法。并且由客户端决定调用哪个算法，spring中在实例化对象的时候用到Strategy模式。XmlBeanDefinitionReader,PropertiesBeanDefinitionReader</p><h2 id="2-10-责任链默认"><a href="#2-10-责任链默认" class="headerlink" title="2.10 责任链默认"></a>2.10 责任链默认</h2><p>AOP中的拦截器链</p><h2 id="2-11-委托者模式"><a href="#2-11-委托者模式" class="headerlink" title="2.11 委托者模式"></a>2.11 委托者模式</h2><p>DelegatingFilterProxy，整合Shiro，SpringSecurity的时候都有用到。</p><p>…..</p><h1 id="3-Autowired和Resource关键字的区别？"><a href="#3-Autowired和Resource关键字的区别？" class="headerlink" title="3.Autowired和Resource关键字的区别？"></a>3.Autowired和Resource关键字的区别？</h1><p>&emsp;&emsp;这是一个相对比较简单的问题，@Resource和@Autowired都是做bean的注入时使用，其实@Resource并不是Spring的注解，它的包是javax.annotation.Resource，需要导入，但是Spring支持该注解的注入。</p><h2 id="3-1-共同点"><a href="#3-1-共同点" class="headerlink" title="3.1 共同点"></a>3.1 共同点</h2><p>&emsp;&emsp;两者都可以写在字段和setter方法上。两者如果都写在字段上，那么就不需要再写setter方法.</p><h2 id="3-2-不同点"><a href="#3-2-不同点" class="headerlink" title="3.2 不同点"></a>3.2 不同点</h2><p><strong>@Autowired</strong></p><p>&emsp;&emsp;@Autowired为Spring提供的注解，需要导入org.springframework.beans.factory.annotation.Autowired;只按照byType注入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestServiceImpl</span> &#123;<br> <span class="hljs-comment">// 下面两种@Autowired只要使用一种即可</span><br> <span class="hljs-meta">@Autowired</span><br> <span class="hljs-keyword">private</span> UserDao userDao; <span class="hljs-comment">// 用于字段上</span><br> <br> <span class="hljs-meta">@Autowired</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUserDao</span><span class="hljs-params">(UserDao userDao)</span> &#123; <span class="hljs-comment">// 用于属性的方法上</span><br> <span class="hljs-built_in">this</span>.userDao = userDao;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>@Autowired注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false。如果我们想使用按照名称（byName）来装配，可以结合@Qualififier注解一起使用。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestServiceImpl</span> &#123;<br> <span class="hljs-meta">@Autowired</span><br> <span class="hljs-meta">@Qualifier(&quot;userDao&quot;)</span><br> <span class="hljs-keyword">private</span> UserDao userDao; &#125;<br></code></pre></td></tr></table></figure><p><strong>@Resource</strong></p><p>&emsp;&emsp;@Resource默认按照ByName自动注入，由J2EE提供，需要导入包javax.annotation.Resource。@Resource有两个重要的属性：name和type，而Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以，如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不制定name也不制定type属性，这时将通过反射机制使用byName自动注入策略.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestServiceImpl</span> &#123;<br> <span class="hljs-comment">// 下面两种@Resource只要使用一种即可</span><br> <span class="hljs-meta">@Resource(name=&quot;userDao&quot;)</span><br> <span class="hljs-keyword">private</span> UserDao userDao; <span class="hljs-comment">// 用于字段上</span><br> <br> <span class="hljs-meta">@Resource(name=&quot;userDao&quot;)</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUserDao</span><span class="hljs-params">(UserDao userDao)</span> &#123; <span class="hljs-comment">// 用于属性的setter方法上</span><br> <span class="hljs-built_in">this</span>.userDao = userDao;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>@Resource装配顺序：</p><ol><li>如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常。</li><li>如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常。</li><li>如果指定了type，则从上下文中找到类似匹配的唯一bean进行装配，找不到或是找到多个，都会抛出异常。</li><li>如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配。</li></ol><p>@Resource的作用相当于@Autowired，只不过@Autowired按照byType自动注入。</p><h1 id="4-Spring中常用的注解有哪些，重点介绍几个"><a href="#4-Spring中常用的注解有哪些，重点介绍几个" class="headerlink" title="4.Spring中常用的注解有哪些，重点介绍几个"></a>4.Spring中常用的注解有哪些，重点介绍几个</h1><p>@Controller  @Service @RestController @RequestBody,@Indexd  @Import等</p><p>@Indexd提升 @ComponentScan的效率</p><p>@Import注解是import标签的替换，在SpringBoot的自动装配中非常重要，也是EnableXXX的前置基础。</p><h1 id="5-循环依赖"><a href="#5-循环依赖" class="headerlink" title="5.循环依赖"></a>5.循环依赖</h1><p>面试的重点，大厂必问之一：</p><h2 id="5-1-什么是循环依赖"><a href="#5-1-什么是循环依赖" class="headerlink" title="5.1 什么是循环依赖"></a>5.1 什么是循环依赖</h2><p>看下图</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/1462/1646114654000/d1e9bec7b2d648b3b777caeb6da2a872.png" alt="image.png"></p><p>&emsp;&emsp;上图是循环依赖的三种情况，虽然方式有点不一样，但是循环依赖的本质是一样的，就你的完整创建要依赖与我，我的完整创建也依赖于你。相互依赖从而没法完整创建造成失败。</p><h2 id="5-2-代码演示"><a href="#5-2-代码演示" class="headerlink" title="5.2 代码演示"></a>5.2 代码演示</h2><p>&emsp;&emsp;我们再通过代码的方式来演示下循环依赖的效果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CircularTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">CircularTest1</span>();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CircularTest1</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">CircularTest2</span> <span class="hljs-variable">circularTest2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CircularTest2</span>();<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CircularTest2</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">CircularTest1</span> <span class="hljs-variable">circularTest1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CircularTest1</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>执行后出现了 StackOverflowError 错误</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/1462/1646114654000/ad194978a72a4312bff8f659806028e9.png" alt="image.png"></p><p>&emsp;&emsp;上面的就是最基本的循环依赖的场景，你需要我，我需要你，然后就报错了。而且上面的这种设计情况我们是没有办法解决的。那么针对这种场景我们应该要怎么设计呢？这个是关键！</p><h2 id="5-3-分析问题"><a href="#5-3-分析问题" class="headerlink" title="5.3 分析问题"></a>5.3 分析问题</h2><p>&emsp;&emsp;首先我们要明确一点就是如果这个对象A还没创建成功，在创建的过程中要依赖另一个对象B，而另一个对象B也是在创建中要依赖对象A，这种肯定是无解的，这时我们就要转换思路，我们先把A创建出来，但是还没有完成初始化操作，也就是这是一个半成品的对象，然后在赋值的时候先把A暴露出来，然后创建B，让B创建完成后找到暴露的A完成整体的实例化，这时再把B交给A完成A的后续操作，从而揭开了循环依赖的密码。也就是如下图：</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/1462/1646114654000/b42b8c3aa1784ad7881001044aae7910.png" alt="image.png"></p><h2 id="5-4-自己解决"><a href="#5-4-自己解决" class="headerlink" title="5.4 自己解决"></a>5.4 自己解决</h2><p>&emsp;&emsp;明白了上面的本质后，我们可以自己来尝试解决下：</p><p>先来把上面的案例改为set&#x2F;get来依赖关联</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CircularTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        System.out.println(getBean(CircularTest1.class).getCircularTest2());<br>        System.out.println(getBean(CircularTest2.class).getCircularTest1());<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; T <span class="hljs-title function_">getBean</span><span class="hljs-params">(Class&lt;T&gt; beanClass)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-comment">// 1.获取 实例对象</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> beanClass.newInstance();<br>        <span class="hljs-comment">// 2.完成属性填充</span><br>        Field[] declaredFields = obj.getClass().getDeclaredFields();<br>        <span class="hljs-comment">// 遍历处理</span><br>        <span class="hljs-keyword">for</span> (Field field : declaredFields) &#123;<br>            field.setAccessible(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 针对private修饰</span><br>            <span class="hljs-comment">// 获取成员变量 对应的类对象</span><br>            Class&lt;?&gt; fieldClass = field.getType();<br>            <span class="hljs-comment">// 获取对应的 beanName</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">fieldBeanName</span> <span class="hljs-operator">=</span> fieldClass.getSimpleName().toLowerCase();<br>            <span class="hljs-comment">// 给成员变量赋值 如果 singletonObjects 中有半成品就获取，否则创建对象</span><br>            field.set(obj,getBean(fieldClass));<br>        &#125;<br>        <span class="hljs-keyword">return</span> (T) obj;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CircularTest1</span>&#123;<br>    <span class="hljs-keyword">private</span> CircularTest2 circularTest2;<br><br>    <span class="hljs-keyword">public</span> CircularTest2 <span class="hljs-title function_">getCircularTest2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> circularTest2;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCircularTest2</span><span class="hljs-params">(CircularTest2 circularTest2)</span> &#123;<br>        <span class="hljs-built_in">this</span>.circularTest2 = circularTest2;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CircularTest2</span>&#123;<br>    <span class="hljs-keyword">private</span> CircularTest1 circularTest1;<br><br>    <span class="hljs-keyword">public</span> CircularTest1 <span class="hljs-title function_">getCircularTest1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> circularTest1;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCircularTest1</span><span class="hljs-params">(CircularTest1 circularTest1)</span> &#123;<br>        <span class="hljs-built_in">this</span>.circularTest1 = circularTest1;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们再通过把对象实例化和成员变量赋值拆解开来处理。从而解决循环依赖的问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CircularTest</span> &#123;<br>    <span class="hljs-comment">// 保存提前暴露的对象，也就是半成品的对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> Map&lt;String,Object&gt; singletonObjects = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        System.out.println(getBean(CircularTest1.class).getCircularTest2());<br>        System.out.println(getBean(CircularTest2.class).getCircularTest1());<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; T <span class="hljs-title function_">getBean</span><span class="hljs-params">(Class&lt;T&gt; beanClass)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-comment">//1.获取类对象对应的名称</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">beanName</span> <span class="hljs-operator">=</span> beanClass.getSimpleName().toLowerCase();<br>        <span class="hljs-comment">// 2.根据名称去 singletonObjects 中查看是否有半成品的对象</span><br>        <span class="hljs-keyword">if</span>(singletonObjects.containsKey(beanName))&#123;<br>            <span class="hljs-keyword">return</span> (T) singletonObjects.get(beanName);<br>        &#125;<br>        <span class="hljs-comment">// 3. singletonObjects 没有半成品的对象，那么就反射实例化对象</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> beanClass.newInstance();<br>        <span class="hljs-comment">// 还没有完整的创建完这个对象就把这个对象存储在了 singletonObjects中</span><br>        singletonObjects.put(beanName,obj);<br>        <span class="hljs-comment">// 属性填充来补全对象</span><br>        Field[] declaredFields = obj.getClass().getDeclaredFields();<br>        <span class="hljs-comment">// 遍历处理</span><br>        <span class="hljs-keyword">for</span> (Field field : declaredFields) &#123;<br>            field.setAccessible(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 针对private修饰</span><br>            <span class="hljs-comment">// 获取成员变量 对应的类对象</span><br>            Class&lt;?&gt; fieldClass = field.getType();<br>            <span class="hljs-comment">// 获取对应的 beanName</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">fieldBeanName</span> <span class="hljs-operator">=</span> fieldClass.getSimpleName().toLowerCase();<br>            <span class="hljs-comment">// 给成员变量赋值 如果 singletonObjects 中有半成品就获取，否则创建对象</span><br>            field.set(obj,singletonObjects.containsKey(fieldBeanName)?<br>                    singletonObjects.get(fieldBeanName):getBean(fieldClass));<br>        &#125;<br>        <span class="hljs-keyword">return</span> (T) obj;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CircularTest1</span>&#123;<br>    <span class="hljs-keyword">private</span> CircularTest2 circularTest2;<br><br>    <span class="hljs-keyword">public</span> CircularTest2 <span class="hljs-title function_">getCircularTest2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> circularTest2;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCircularTest2</span><span class="hljs-params">(CircularTest2 circularTest2)</span> &#123;<br>        <span class="hljs-built_in">this</span>.circularTest2 = circularTest2;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CircularTest2</span>&#123;<br>    <span class="hljs-keyword">private</span> CircularTest1 circularTest1;<br><br>    <span class="hljs-keyword">public</span> CircularTest1 <span class="hljs-title function_">getCircularTest1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> circularTest1;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCircularTest1</span><span class="hljs-params">(CircularTest1 circularTest1)</span> &#123;<br>        <span class="hljs-built_in">this</span>.circularTest1 = circularTest1;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行程序你会发现问题完美的解决了</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/1462/1646114654000/63135dba531b45938dfbc9d69ecc6301.png" alt="image.png"></p><p>&emsp;&emsp;在上面的方法中的核心是getBean方法，Test1 创建后填充属性时依赖Test2，那么就去创建 Test2，在创建 Test2 开始填充时发现依赖于 Test1，但此时 Test1 这个半成品对象已经存放在缓存到 <code>singletonObjects</code> 中了，所以Test2可以正常创建，在通过递归把 Test1 也创建完整了。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/1462/1646114654000/2c97505674514ed28a774477c51e0f0b.png" alt="image.png"></p><p>最后总结下该案例解决的本质：</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/1462/1646114654000/09f7cb069e58480fa37c8c5ac0dd8467.png" alt="image.png"></p><h2 id="5-5-Spring循环依赖"><a href="#5-5-Spring循环依赖" class="headerlink" title="5.5 Spring循环依赖"></a>5.5 Spring循环依赖</h2><p>针对Spring中Bean对象的各种场景。支持的方案不一样：</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1646114654000/258d647b589345ba854ca8e6db50ba75.png" alt="image.png"></p><p>&emsp;&emsp;然后我们再来看看Spring中是如何解决循环依赖问题的呢？刚刚上面的案例中的对象的生命周期的核心就两个</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/1462/1646114654000/f297c4657bfa4318bb1db866ad960848.png" alt="image.png"></p><p>&emsp;&emsp;而Spring创建Bean的生命周期中涉及到的方法就很多了。下面是简单列举了对应的方法</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/1462/1646114654000/51bfe454457c459b8edabde7a40318b5.png" alt="image.png"></p><p>&emsp;&emsp;基于前面案例的了解，我们知道肯定需要在调用构造方法方法创建完成后再暴露对象，在Spring中提供了三级缓存来处理这个事情，对应的处理节点如下图：</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/1462/1646114654000/d4394ca79d9a4dea87ebb7c461d7485b.png" alt="image.png"></p><p>对应到源码中具体处理循环依赖的流程如下：</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/1462/1646114654000/33568ba20781477eafed5c790a44212a.png" alt="image.png"></p><p>&emsp;&emsp;上面就是在Spring的生命周期方法中和循环依赖出现相关的流程了。那么源码中的具体处理是怎么样的呢？我们继续往下面看。</p><p>首先在调用构造方法的后会放入到三级缓存中</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/1462/1646114654000/8fe6a991c479455fb588e4246de9709d.png" alt="image.png"></p><p>下面就是放入三级缓存的逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addSingletonFactory</span><span class="hljs-params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> &#123;<br>Assert.notNull(singletonFactory, <span class="hljs-string">&quot;Singleton factory must not be null&quot;</span>);<br><span class="hljs-comment">// 使用singletonObjects进行加锁，保证线程安全</span><br><span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.singletonObjects) &#123;<br><span class="hljs-comment">// 如果单例对象的高速缓存【beam名称-bean实例】没有beanName的对象</span><br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.singletonObjects.containsKey(beanName)) &#123;<br><span class="hljs-comment">// 将beanName,singletonFactory放到单例工厂的缓存【bean名称 - ObjectFactory】</span><br><span class="hljs-built_in">this</span>.singletonFactories.put(beanName, singletonFactory);<br><span class="hljs-comment">// 从早期单例对象的高速缓存【bean名称-bean实例】 移除beanName的相关缓存对象</span><br><span class="hljs-built_in">this</span>.earlySingletonObjects.remove(beanName);<br><span class="hljs-comment">// 将beanName添加已注册的单例集中</span><br><span class="hljs-built_in">this</span>.registeredSingletons.add(beanName);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在填充属性的时候会存入二级缓存中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">earlySingletonObjects.put(beanName,bean);<br>registeredSingletons.add(beanName);<br></code></pre></td></tr></table></figure><p>最后把创建的对象保存在了一级缓存中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addSingleton</span><span class="hljs-params">(String beanName, Object singletonObject)</span> &#123;<br><span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.singletonObjects) &#123;<br><span class="hljs-comment">// 将映射关系添加到单例对象的高速缓存中</span><br><span class="hljs-built_in">this</span>.singletonObjects.put(beanName, singletonObject);<br><span class="hljs-comment">// 移除beanName在单例工厂缓存中的数据</span><br><span class="hljs-built_in">this</span>.singletonFactories.remove(beanName);<br><span class="hljs-comment">// 移除beanName在早期单例对象的高速缓存的数据</span><br><span class="hljs-built_in">this</span>.earlySingletonObjects.remove(beanName);<br><span class="hljs-comment">// 将beanName添加到已注册的单例集中</span><br><span class="hljs-built_in">this</span>.registeredSingletons.add(beanName);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-6-疑问点"><a href="#5-6-疑问点" class="headerlink" title="5.6 疑问点"></a>5.6 疑问点</h2><p>这些疑问点也是面试官喜欢问的问题点</p><h3 id="为什么需要三级缓存"><a href="#为什么需要三级缓存" class="headerlink" title="为什么需要三级缓存"></a>为什么需要三级缓存</h3><p>三级缓存主要处理的是AOP的代理对象，存储的是一个ObjectFactory</p><p>三级缓存考虑的是带你对象，而二级缓存考虑的是性能-从三级缓存的工厂里创建出对象，再扔到二级缓存（这样就不用每次都要从工厂里拿）</p><h3 id="没有三级环境能解决吗？"><a href="#没有三级环境能解决吗？" class="headerlink" title="没有三级环境能解决吗？"></a>没有三级环境能解决吗？</h3><p>没有三级缓存是可以解决循环依赖问题的</p><h3 id="三级缓存分别什么作用"><a href="#三级缓存分别什么作用" class="headerlink" title="三级缓存分别什么作用"></a>三级缓存分别什么作用</h3><p>一级缓存：正式对象</p><p>二级缓存：半成品对象</p><p>三级缓存：工厂</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/1462/1646114654000/99f0bb5b710a49f6b9ebd53a173118a5.png" alt="image.png"></p><h1 id="6-Spring的生命周期"><a href="#6-Spring的生命周期" class="headerlink" title="6.Spring的生命周期"></a>6.Spring的生命周期</h1><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/1462/1646114654000/cf1072694ce9496aa04c3c6fde40c38a.png" alt="image.png"></p><p>结合图，把Bean对象在Spring中的关键节点介绍一遍</p><h1 id="7-Spring中支持几种作用域"><a href="#7-Spring中支持几种作用域" class="headerlink" title="7.Spring中支持几种作用域"></a>7.Spring中支持几种作用域</h1><p>Spring容器中的bean可以分为5个范围：</p><ol><li>prototype：为每一个bean请求提供一个实例。</li><li>singleton：默认，每个容器中只有一个bean的实例，单例的模式由BeanFactory自身来维护。</li><li>request：为每一个网络请求创建一个实例，在请求完成以后，bean会失效并被垃圾回收器回收。</li><li>session：与request范围类似，确保每个session中有一个bean的实例，在session过期后，bean会随之失效。</li><li>global-session：全局作用域，global-session和Portlet应用相关。当你的应用部署在Portlet容器中工作时，它包含很多portlet。如果你想要声明让所有的portlet共用全局的存储变量的话，那么这全局变量需要存储在global-session中。全局作用域与Servlet中的session作用域效果相同。</li></ol><h1 id="8-说说事务的隔离级别"><a href="#8-说说事务的隔离级别" class="headerlink" title="8.说说事务的隔离级别"></a>8.说说事务的隔离级别</h1><p>&emsp;&emsp;事务隔离级别指的是一个事务对数据的修改与另一个并行的事务的隔离程度，当多个事务同时访问相同数据时，如果没有采取必要的隔离机制，就可能发生以下问题：</p><table><thead><tr><th>问题</th><th align="left">描述</th></tr></thead><tbody><tr><td>脏读</td><td align="left">一个事务读到另一个事务未提交的更新数据，所谓脏读，就是指事务A读到了事务B还没有提交的数据，比如银行取钱，事务A开启事务，此时切换到事务B，事务B开启事务–&gt;取走100元，此时切换回事务A，事务A读取的肯定是数据库里面的原始数据，因为事务B取走了100块钱，并没有提交，数据库里面的账务余额肯定还是原始余额，这就是脏读</td></tr><tr><td>幻读</td><td align="left">是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。 同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象 发生了幻觉一样。</td></tr><tr><td>不可重复读</td><td align="left">在一个事务里面的操作中发现了未被操作的数据 比方说在同一个事务中先后执行两条一模一样的select语句，期间在此次事务中没有执行过任何DDL语句，但先后得到的结果不一致，这就是不可重复读</td></tr></tbody></table><p><strong>Spring支持的隔离级别</strong></p><table><thead><tr><th align="left">隔离级别</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">DEFAULT</td><td align="left">使用数据库本身使用的隔离级别 <code>&lt;br&gt;</code> ORACLE（读已提交） MySQL（可重复读）</td></tr><tr><td align="left">READ_UNCOMITTED</td><td align="left">读未提交（脏读）最低的隔离级别，一切皆有可能。</td></tr><tr><td align="left">READ_COMMITED</td><td align="left">读已提交，ORACLE默认隔离级别，有幻读以及不可重复读风险。</td></tr><tr><td align="left">REPEATABLE_READ</td><td align="left">可重复读，解决不可重复读的隔离级别，但还是有幻读风险。</td></tr><tr><td align="left">SERLALIZABLE</td><td align="left">串行化，最高的事务隔离级别，不管多少事务，挨个运行完一个事务的所有子事务之后才可以执行另外一个事务里面的所有子事务，这样就解决了脏读、不可重复读和幻读的问题了</td></tr></tbody></table><p><img src="https://img-blog.csdnimg.cn/20190703000608167.png" alt="在这里插入图片描述"></p><p>&emsp;&emsp;再必须强调一遍，不是事务隔离级别设置得越高越好，事务隔离级别设置得越高，意味着势必要花手段去加锁用以保证事务的正确性，那么效率就要降低，因此实际开发中往往要在效率和并发正确性之间做一个取舍，一般情况下会设置为READ_COMMITED，此时避免了脏读，并发性也还不错，之后再通过一些别的手段去解决不可重复读和幻读的问题就好了。</p><h1 id="9-事务的传播行为"><a href="#9-事务的传播行为" class="headerlink" title="9.事务的传播行为"></a>9.事务的传播行为</h1><p>保证事务：ACID</p><p>事务的传播行为针对的是嵌套的关系</p><p>Spring中的7个事务传播行为:</p><table><thead><tr><th align="left">事务行为</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">PROPAGATION_REQUIRED</td><td align="left">支持当前事务，假设当前没有事务。就新建一个事务</td></tr><tr><td align="left">PROPAGATION_SUPPORTS</td><td align="left">支持当前事务，假设当前没有事务，就以非事务方式运行</td></tr><tr><td align="left">PROPAGATION_MANDATORY</td><td align="left">支持当前事务，假设当前没有事务，就抛出异常</td></tr><tr><td align="left">PROPAGATION_REQUIRES_NEW</td><td align="left">新建事务，假设当前存在事务。把当前事务挂起</td></tr><tr><td align="left">PROPAGATION_NOT_SUPPORTED</td><td align="left">以非事务方式运行操作。假设当前存在事务，就把当前事务挂起</td></tr><tr><td align="left">PROPAGATION_NEVER</td><td align="left">以非事务方式运行，假设当前存在事务，则抛出异常</td></tr><tr><td align="left">PROPAGATION_NESTED</td><td align="left">如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。</td></tr></tbody></table><p><strong>举例说明</strong></p><p><strong>案例代码</strong></p><p>ServiceA</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">ServiceA &#123;   <br>     <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span> &#123;<br>         ServiceB.methodB();<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>ServiceB</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">ServiceB &#123; <br>     <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodB</span><span class="hljs-params">()</span> &#123;<br>     &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-PROPAGATION-REQUIRED"><a href="#1-PROPAGATION-REQUIRED" class="headerlink" title="1.PROPAGATION_REQUIRED"></a>1.PROPAGATION_REQUIRED</h3><p>&emsp;&emsp;假如当前正要运行的事务不在另外一个事务里，那么就起一个新的事务 比方说，ServiceB.methodB的事务级别定义PROPAGATION_REQUIRED, 那么因为执行ServiceA.methodA的时候，ServiceA.methodA已经起了事务。这时调用ServiceB.methodB，ServiceB.methodB看到自己已经执行在ServiceA.methodA的事务内部。就不再起新的事务。而假如ServiceA.methodA执行的时候发现自己没有在事务中，他就会为自己分配一个事务。这样，在ServiceA.methodA或者在ServiceB.methodB内的不论什么地方出现异常。事务都会被回滚。即使ServiceB.methodB的事务已经被提交，可是ServiceA.methodA在接下来fail要回滚，ServiceB.methodB也要回滚<br><img src="https://img-blog.csdnimg.cn/20190223225404935.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="2-PROPAGATION-SUPPORTS"><a href="#2-PROPAGATION-SUPPORTS" class="headerlink" title="2.PROPAGATION_SUPPORTS"></a>2.PROPAGATION_SUPPORTS</h3><p>&emsp;&emsp;假设当前在事务中。即以事务的形式执行。假设当前不在一个事务中，那么就以非事务的形式执行</p><h3 id="3PROPAGATION-MANDATORY"><a href="#3PROPAGATION-MANDATORY" class="headerlink" title="3PROPAGATION_MANDATORY"></a>3PROPAGATION_MANDATORY</h3><p>&emsp;&emsp;必须在一个事务中执行。也就是说，他仅仅能被一个父事务调用。否则，他就要抛出异常</p><h3 id="4-PROPAGATION-REQUIRES-NEW"><a href="#4-PROPAGATION-REQUIRES-NEW" class="headerlink" title="4.PROPAGATION_REQUIRES_NEW"></a>4.PROPAGATION_REQUIRES_NEW</h3><p>&emsp;&emsp;这个就比较绕口了。 比方我们设计ServiceA.methodA的事务级别为PROPAGATION_REQUIRED，ServiceB.methodB的事务级别为PROPAGATION_REQUIRES_NEW。那么当运行到ServiceB.methodB的时候，ServiceA.methodA所在的事务就会挂起。ServiceB.methodB会起一个新的事务。等待ServiceB.methodB的事务完毕以后，他才继续运行。<br>他与PROPAGATION_REQUIRED 的事务差别在于事务的回滚程度了。由于ServiceB.methodB是新起一个事务，那么就是存在两个不同的事务。假设ServiceB.methodB已经提交，那么ServiceA.methodA失败回滚。ServiceB.methodB是不会回滚的。假设ServiceB.methodB失败回滚，假设他抛出的异常被ServiceA.methodA捕获，ServiceA.methodA事务仍然可能提交。<br><img src="https://img-blog.csdnimg.cn/20190223230140433.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="5-PROPAGATION-NOT-SUPPORTED"><a href="#5-PROPAGATION-NOT-SUPPORTED" class="headerlink" title="5.PROPAGATION_NOT_SUPPORTED"></a>5.PROPAGATION_NOT_SUPPORTED</h3><p>&emsp;&emsp;当前不支持事务。比方ServiceA.methodA的事务级别是PROPAGATION_REQUIRED 。而ServiceB.methodB的事务级别是PROPAGATION_NOT_SUPPORTED ，那么当执行到ServiceB.methodB时。ServiceA.methodA的事务挂起。而他以非事务的状态执行完，再继续ServiceA.methodA的事务。</p><h3 id="6-PROPAGATION-NEVER"><a href="#6-PROPAGATION-NEVER" class="headerlink" title="6.PROPAGATION_NEVER"></a>6.PROPAGATION_NEVER</h3><p>&emsp;&emsp;不能在事务中执行。<br>如果ServiceA.methodA的事务级别是PROPAGATION_REQUIRED。 而ServiceB.methodB的事务级别是PROPAGATION_NEVER ，那么ServiceB.methodB就要抛出异常了。</p><h3 id="7-PROPAGATION-NESTED"><a href="#7-PROPAGATION-NESTED" class="headerlink" title="7.PROPAGATION_NESTED"></a>7.PROPAGATION_NESTED</h3><p>&emsp;&emsp;如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。</p><h1 id="10-Spring事务实现的方式"><a href="#10-Spring事务实现的方式" class="headerlink" title="10.Spring事务实现的方式"></a>10.Spring事务实现的方式</h1><p><strong>编程式事务管理</strong>：这意味着你可以通过编程的方式管理事务，这种方式带来了很大的灵活性，但很难维护。</p><p><strong>声明式事务管理</strong>：这种方式意味着你可以将事务管理和业务代码分离。你只需要通过注解或者XML配置管理事务。</p><h1 id="11-事务注解的本质是什么"><a href="#11-事务注解的本质是什么" class="headerlink" title="11.事务注解的本质是什么"></a>11.事务注解的本质是什么</h1><p>&emsp;&emsp;@Transactional 这个注解仅仅是一些（和事务相关的）元数据，在运行时被事务基础设施读取消费，并使用这些元数据来配置bean的事务行为。 大致来说具有两方面功能，一是表明该方法要参与事务，二是配置相关属性来定制事务的参与方式和运行行为</p><p>&emsp;&emsp;声明式事务主要是得益于Spring AOP。使用一个事务拦截器，在方法调用的前后&#x2F;周围进行事务性增强（advice），来驱动事务完成。</p><p>&emsp;&emsp;@Transactional注解既可以标注在类上，也可以标注在方法上。当在类上时，默认应用到类里的所有方法。如果此时方法上也标注了，则方法上的优先级高。 另外注意方法一定要是public的。</p><p><a href="https://cloud.fynote.com/share/d/IVeyV0Jp">https://cloud.fynote.com/share/d/IVeyV0Jp</a></p><h1 id="12-谈谈你对BeanFactory和ApplicationContext的理解"><a href="#12-谈谈你对BeanFactory和ApplicationContext的理解" class="headerlink" title="12.谈谈你对BeanFactory和ApplicationContext的理解"></a>12.谈谈你对BeanFactory和ApplicationContext的理解</h1><p>目的：考察对IoC的理解</p><p>BeanFactory:Bean工厂 &#x3D;&#x3D;》IoC容器</p><p>BeanDefinition &#x3D;&#x3D;&#x3D;》Bean定义</p><p>BeanDefinitionRegistry &#x3D;&#x3D;》 BeanDefinition 和 BeanFactory的关联</p><p>….</p><p>ApplicationContext:应用上下文</p><p>ApplicationContext ac &#x3D; new ClasspathXmlApplicationContext(xxx.xml);</p><h1 id="13-谈谈你对BeanFactoryPostProcessor的理解"><a href="#13-谈谈你对BeanFactoryPostProcessor的理解" class="headerlink" title="13.谈谈你对BeanFactoryPostProcessor的理解"></a>13.谈谈你对BeanFactoryPostProcessor的理解</h1><p>BeanFactoryPostProcessor:是在BeanFactory创建完成后的后置处理</p><p>BeanFactory：对外提供Bean对象</p><p>需要知道怎么提供Bean对象–&gt;BeanDefinition</p><p>XML&#x2F;注解 –》 BeanDefinition –》注册 –》完成BeanFactory的处理</p><p>1.需要交代BeanFactoryPostProcessor的作用</p><p>2.举个例子</p><p>@Configuration 注解 –》 Java被 @Configuration注解标识–&gt; 这是一个Java配置类</p><p>@Configuration–》@Component –&gt;BeanDefinition –&gt; 存储在BeanFactory中  是当做一个普通的Bean管理的</p><p>@Bean  @Primary 。。。。</p><p>ConfigurationClassPostProcessor</p><h1 id="14-谈谈你对BeanPostProcessor的理解"><a href="#14-谈谈你对BeanPostProcessor的理解" class="headerlink" title="14.谈谈你对BeanPostProcessor的理解"></a>14.谈谈你对BeanPostProcessor的理解</h1><p>针对Bean对象初始化前后。 针对Bean对象创建之后的处理操作。</p><p>SpringIoC 核心流程</p><p>BeanDefinition –&gt; 注册BeanDefinition –&gt;BeanFactory –》BeanFactory的后置处理 –&gt; 单例bean –&gt;  AOP  –》 代理对象 —&gt; advice pointcut join point 。。。</p><p>BeanPostProcessor 提供了一种扩展机制</p><p>自定义接口的实现 –》 <strong>注册</strong>到BeanFactory的 Map中</p><p>BeanDefinition –&gt; 注册BeanDefinition –&gt;BeanFactory –》BeanFactory的后置处理 –&gt; 单例bean –&gt;</p><p>遍历上面的Map 执行相关的行为 –&gt; 。。。。。</p><p>&#x3D;&#x3D;&#x3D;》 AOP</p><p>IoC 和AOP的关系</p><p>有了IoC 才有 AOP  DI</p><h1 id="15-谈谈你对SpringMVC的理解"><a href="#15-谈谈你对SpringMVC的理解" class="headerlink" title="15.谈谈你对SpringMVC的理解"></a>15.谈谈你对SpringMVC的理解</h1><p>控制框架：前端控制器–》Servlet –》Web容器【Tomcat】</p><p>SpringMVC和Spring的关系  IoC容器关系–》父子关系</p><p><a href="https://www.processon.com/view/link/63dc99aba7d181715d1f4569">https://www.processon.com/view/link/63dc99aba7d181715d1f4569</a></p><p>Spring和SpringMVC的关系理解</p><p>Spring和SpringMVC整合的项目中</p><p>Controller  Service Dao</p><p>具体的有两个容器Spring中的IoC容器。然后SpringMVC中也有一个IoC容器</p><p>Controller中定义的实例都是SpringMVC组件维护的</p><p>Service和Dao中的实例都是由Spring的IoC容器维护的</p><p>这两个容器有一个父子容器的关系</p><p>Spring容器是SpringMVC容器的父容器</p><h1 id="16-谈谈你对DelegatingFilterProxy的理解"><a href="#16-谈谈你对DelegatingFilterProxy的理解" class="headerlink" title="16.谈谈你对DelegatingFilterProxy的理解"></a>16.谈谈你对DelegatingFilterProxy的理解</h1><p>web.xml</p><p>Shiro SpringSecurity</p><p>Spring整合的第三方的组件会非常多</p><p>JWT  单独登录  OAuth2.0</p><p>组件：组合起来的零件–》组件  组合起来的技术栈–》组件框架</p><h1 id="17-谈谈你对SpringBoot的理解"><a href="#17-谈谈你对SpringBoot的理解" class="headerlink" title="17.谈谈你对SpringBoot的理解"></a>17.谈谈你对SpringBoot的理解</h1><p>约定由于配置</p><p>自动装配</p><p>SpringBoot和Spring的关系</p><p>SpringBoot的初始化 –&gt; IoC Spring的初始化</p><p>SpringBoot的启动 –&gt; IoC</p><p>@SpringApplication注解 –&gt; @Configuration –&gt;ConfigurationClassPostProcessor –》 @Import注解 –》 延迟加载 –》 自动装配 –&gt; SPI  去重 排除 过滤</p><p>spring.factories</p><p>SSM框架的整合</p><p>1。导入依赖</p><p>2。添加配置文件</p><p>3。设置配置文件 web.xml</p><h1 id="18-介绍下Import注解的理解"><a href="#18-介绍下Import注解的理解" class="headerlink" title="18.介绍下Import注解的理解"></a>18.介绍下Import注解的理解</h1><p>@Import注解是在Spring3.0的时候提供。目的是为了替换在XML配置文件中的import标签。</p><p>@Import注解除了可以导入第三方的Java配置类还扩展了其他的功能</p><ol><li>可以把某个类型的对象注入到容器中</li><li>导入的类型如果实现了ImportSelector接口。那么会调用接口中声明的方法。然后把方法返回的类型全类路径的类型对象注入到容器中</li><li>如果导入的类型实现了ImportBeanDefinitionRegistrar这个接口。那么就会调用声明的方法在该方法中显示的提供注册器来完成注入</li></ol><h1 id="19-SpringBoot自动装配中为什么用DeferredImportSelector"><a href="#19-SpringBoot自动装配中为什么用DeferredImportSelector" class="headerlink" title="19.SpringBoot自动装配中为什么用DeferredImportSelector"></a>19.SpringBoot自动装配中为什么用DeferredImportSelector</h1><p>在SpringBoot自动装配中核心是会加载所有依赖中的META-INF&#x2F;spring.factories文件中的配置信息。</p><p>我们可以有多个需要加载的spring.factories文件。那么我们就需要多次操作。我们可以考虑把所有的信息都加载后再统一把这些需要注入到容器中的内容注入进去</p><p>DeferredImportSelector：延迟注入Bean实例的作用</p><h1 id="20-SpringBoot中有了属性文件为什么还要加一个bootstrap-yml文件"><a href="#20-SpringBoot中有了属性文件为什么还要加一个bootstrap-yml文件" class="headerlink" title="20.SpringBoot中有了属性文件为什么还要加一个bootstrap.yml文件?"></a>20.SpringBoot中有了属性文件为什么还要加一个bootstrap.yml文件?</h1><p>&emsp;&emsp;在单体的SpringBoot项目中其实我们是用不到bootstrap.yml文件的，bootsrap.yml文件的使用需要SpringCloud的支持，因为在微服务环境下我们都是有配置中心的，来统一的管理系统的相关配置属性，那么怎么去加载配置中心的内容呢？一个SpringBoot项目启动的时候默认只会加载对应的application.yml中的相关信息，这时bootstrap.yml的作用就体现出来了，会在SpringBoot正常启动前创建一个父容器来通过bootstrap.yml中的配置来加载配置中心的内容。</p><h1 id="21-如果要对属性文件中的账号密码加密如何实现？"><a href="#21-如果要对属性文件中的账号密码加密如何实现？" class="headerlink" title="21.如果要对属性文件中的账号密码加密如何实现？"></a>21.如果要对属性文件中的账号密码加密如何实现？</h1><p>&emsp;&emsp;其实这是一个比较篇实战的一个问题，我们在application.yml中保存的MySQL数据库的账号密码或者其他服务的账号密码，都可以保存加密后的内容，那么我们在处理的时候要怎么解密呢？这个其实比较简单只需要对SpringBoot的执行流程清楚就可以了，第一个我们可以通过自定义监听器可以在加载解析了配置文件之后对加密的文件中做解密处理同时覆盖之前加密的内容，或者通过对应的后置处理器来处理，具体的实现如下：</p><p><img src="https://img-blog.csdnimg.cn/457ab5a2fd124ff988e10b2af6209811.png" alt="在这里插入图片描述"></p><p>然后我们通过案例代码来演示下，加深大家的理解<br>首先我们在属性文件中配置加密后的信息</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.datasource.driverClassName</span>=<span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br><span class="hljs-attr">spring.datasource.url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/mb?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true</span><br><span class="hljs-attr">spring.datasource.username</span>=<span class="hljs-string">root</span><br><span class="hljs-comment"># 对通过3DES对密码加密</span><br><span class="hljs-attr">spring.datasource.password</span>=<span class="hljs-string">t5Jd2CzFWEw=</span><br><br><span class="hljs-attr">spring.datasource.type</span>=<span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span><br><br><span class="hljs-attr">mybatis.mapper-locations</span>=<span class="hljs-string">classpath:mapper/*.xml</span><br></code></pre></td></tr></table></figure><p>&emsp;&emsp;在SpringBoot项目启动的时候在在刷新Spring容器之前执行的，所以我们要做的就是在加载完环境配置信息后，获取到配置的 <code>spring.datasource.password=t5Jd2CzFWEw=</code> 这个信息，然后解密并修改覆盖就可以了。<br><img src="https://img-blog.csdnimg.cn/56ead524284e4317b40700fa7170e7b9.png" alt="在这里插入图片描述">&emsp;&emsp;然后在属性文件的逻辑其实是通过发布事件触发对应的监听器来实现的<br><img src="https://img-blog.csdnimg.cn/795454a61a254cb388b86b308f0b89e3.png" alt="在这里插入图片描述"><br>&emsp;&emsp;所以第一个解决方案就是你自定义一个监听器，这个监听器在加载属性文件(ConfigFileApplicationListener)的监听器之后处理,这种方式稍微麻烦点，<br>&emsp;&emsp;还有一种方式就是通过加载属性文件的一个后置处理器来处理，这就以个为例来实现</p><p>3DES的工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 3DES加密算法，主要用于加密用户id，身份证号等敏感信息,防止破解</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DESedeUtil</span> &#123;<br><br>    <span class="hljs-comment">//秘钥</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span>  <span class="hljs-variable">KEY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;~@#$y1a2n.&amp;@+n@$%*(1)&quot;</span>;<br>    <span class="hljs-comment">//秘钥长度</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">secretKeyLength</span> <span class="hljs-operator">=</span> <span class="hljs-number">24</span>;<br>    <span class="hljs-comment">//加密算法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span>  <span class="hljs-variable">ALGORITHM</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;DESede&quot;</span>;<br>    <span class="hljs-comment">//编码</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">CHARSET</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;UTF-8&quot;</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 转换成十六进制字符串</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">byte</span>[] getHex(String key)&#123;<br>        <span class="hljs-type">byte</span>[] secretKeyByte = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">24</span>];<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">byte</span>[] hexByte;<br>            hexByte = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(DigestUtils.md5Hex(key)).getBytes(CHARSET);<br>            <span class="hljs-comment">//秘钥长度固定为24位</span><br>            System.arraycopy(hexByte,<span class="hljs-number">0</span>,secretKeyByte,<span class="hljs-number">0</span>,secretKeyLength);<br>        &#125; <span class="hljs-keyword">catch</span> (UnsupportedEncodingException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> secretKeyByte;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生成密钥，返回加密串</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key 密钥</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> encodeStr 将加密的字符串</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String  <span class="hljs-title function_">encode3DES</span><span class="hljs-params">(String key,String encodeStr)</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Cipher</span> <span class="hljs-variable">cipher</span> <span class="hljs-operator">=</span> Cipher.getInstance(ALGORITHM);<br>            cipher.init(Cipher.ENCRYPT_MODE, <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecretKeySpec</span>(getHex(key), ALGORITHM));<br>            <span class="hljs-keyword">return</span> Base64.encodeBase64String(cipher.doFinal(encodeStr.getBytes(CHARSET)));<br>        &#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生成密钥,解密，并返回字符串</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key 密钥</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> decodeStr 需要解密的字符串</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">decode3DES</span><span class="hljs-params">(String key, String decodeStr)</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Cipher</span> <span class="hljs-variable">cipher</span> <span class="hljs-operator">=</span> Cipher.getInstance(ALGORITHM);<br>            cipher.init(Cipher.DECRYPT_MODE, <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecretKeySpec</span>(getHex(key),ALGORITHM));<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(cipher.doFinal(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Base64</span>().decode(decodeStr)),CHARSET);<br>        &#125; <span class="hljs-keyword">catch</span>(Exception e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123456&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">encode</span> <span class="hljs-operator">=</span> DESedeUtil.encode3DES(KEY, userId);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">decode</span> <span class="hljs-operator">=</span> DESedeUtil.decode3DES(KEY, encode);<br>        System.out.println(<span class="hljs-string">&quot;用户id&gt;&gt;&gt;&quot;</span>+userId);<br>        System.out.println(<span class="hljs-string">&quot;用户id加密&gt;&gt;&gt;&quot;</span>+encode);<br>        System.out.println(<span class="hljs-string">&quot;用户id解密&gt;&gt;&gt;&quot;</span>+decode);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>声明后置处理器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SafetyEncryptProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">EnvironmentPostProcessor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postProcessEnvironment</span><span class="hljs-params">(ConfigurableEnvironment environment, SpringApplication application)</span> &#123;<br>        <span class="hljs-keyword">for</span> (PropertySource&lt;?&gt; propertySource : environment.getPropertySources()) &#123;<br>            System.out.println(<span class="hljs-string">&quot;propertySource = &quot;</span> + propertySource);<br>            <span class="hljs-keyword">if</span>(propertySource <span class="hljs-keyword">instanceof</span> OriginTrackedMapPropertySource)&#123;<br>                <span class="hljs-type">OriginTrackedMapPropertySource</span> <span class="hljs-variable">source</span> <span class="hljs-operator">=</span> (OriginTrackedMapPropertySource) propertySource;<br>                <span class="hljs-keyword">for</span> (String propertyName : source.getPropertyNames()) &#123;<br>                    <span class="hljs-comment">//System.out.println(propertyName + &quot;=&quot; + source.getProperty(propertyName));</span><br>                    <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;spring.datasource.password&quot;</span>.equals(propertyName))&#123;<br>                        Map&lt;String,Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>                        <span class="hljs-comment">// 做解密处理</span><br>                        <span class="hljs-type">String</span> <span class="hljs-variable">property</span> <span class="hljs-operator">=</span> (String) source.getProperty(propertyName);<br>                        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> DESedeUtil.decode3DES(DESedeUtil.KEY, property);<br>                        System.out.println(<span class="hljs-string">&quot;密文：&quot;</span> + property);<br>                        System.out.println(<span class="hljs-string">&quot;解密后的：&quot;</span> + s);<br>                        map.put(propertyName,s);<br><br>                        <span class="hljs-comment">// 注意要添加到前面，覆盖</span><br>                        environment.getPropertySources().addFirst(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MapPropertySource</span>(propertyName,map));<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在META-INF&#x2F;spring.factories文件中注册</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">org.springframework.boot.env.EnvironmentPostProcessor</span>=<span class="hljs-string">com.bobo.util.SafetyEncryptProcessor</span><br></code></pre></td></tr></table></figure><p>然后启动项目就可以了<br><img src="https://img-blog.csdnimg.cn/970447b8998445abb81d6b9b407bde6b.png" alt="在这里插入图片描述"></p><p>&emsp;&emsp;搞定</p><h1 id="22-谈谈Indexed注解的作用"><a href="#22-谈谈Indexed注解的作用" class="headerlink" title="22.谈谈Indexed注解的作用"></a>22.谈谈Indexed注解的作用</h1><p>@Indexed注解是Spring5.0提供</p><p>Indexed注解解决的问题：是随着项目越来越复杂那么@ComponentScan需要扫描加载的Class会越来越多。在系统启动的时候会造成性能损耗。所以Indexed注解的作用其实就是提升系统启动的性能。</p><p>在系统编译的时候那么会收集所有被@Indexed注解标识的Java类。然后记录在META-INF&#x2F;spring.components文件中。那么系统启动的时候就只需要读取一个该文件中的内容就不用在遍历所有的目录了。提升的效率</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1646114654000/bbb5205d8dec4316b38c08840aca7984.png" alt="image.png"></p><h1 id="23-Component-Controller-Repository-Service-有何区别？"><a href="#23-Component-Controller-Repository-Service-有何区别？" class="headerlink" title="23.@Component, @Controller, @Repository,@Service 有何区别？"></a>23.@Component, @Controller, @Repository,@Service 有何区别？</h1><p>@Component ：这将 java 类标记为 bean。它是任何 Spring 管理组件的通用构造型。spring 的组件扫描机制现在可以将其拾取并将其拉入应用程序环境中。</p><p>@Controller ：这将一个类标记为 Spring Web MVC 控制器。标有它的Bean 会自动导入到 IoC 容器中。</p><p>@Service ：此注解是组件注解的特化。它不会对 @Component 注解提供任何其他行为。您可以在服务层类中使用@Service 而不是 @Component，因为它以更好的方式指定了意图。</p><p>@Repository ：这个注解是具有类似用途和功能的 @Component 注解的特化。它为 DAO 提供了额外的好处。它将 DAO 导入 IoC 容器，并使未经检查的异常有资格转换为 Spring DataAccessException。</p><h1 id="24-有哪些通知类型-Advice"><a href="#24-有哪些通知类型-Advice" class="headerlink" title="24.有哪些通知类型(Advice)"></a>24.有哪些通知类型(Advice)</h1><p>前置通知：Before - 这些类型的 Advice 在 joinpoint 方法之前执行，并使用@Before 注解标记进行配置。<br>后置通知：After Returning - 这些类型的 Advice 在连接点方法正常执行后执行，并使用@AfterReturning 注解标记进行配置。<br>异常通知：After Throwing - 这些类型的 Advice 仅在 joinpoint 方法通过抛出异常退出并使用 @AfterThrowing 注解标记配置时执行。<br>最终通知：After (finally) - 这些类型的 Advice 在连接点方法之后执行，无论方法退出是正常还是异常返回，并使用 @After 注解标记进行配置。<br>环绕通知：Around - 这些类型的 Advice 在连接点之前和之后执行，并使用@Around 注解标记进行配置。</p><h1 id="25-什么是-Spring-的依赖注入？"><a href="#25-什么是-Spring-的依赖注入？" class="headerlink" title="25.什么是 Spring 的依赖注入？"></a>25.什么是 Spring 的依赖注入？</h1><p>依赖注入，是 IOC 的一个方面，是个通常的概念，它有多种解释。这概念是说你不用创建对象，而只需要描述它如何被创建。你不在代码里直接组装你的组件和服务，但是要在配置文件里描述哪些组件需要哪些服务，之后一个容器（IOC 容器）负责把他们组装起来。</p><p>BeanFactory</p><p>BeanDefinition</p><p>BeanDefinitionRegistry</p><p>ApplicationContext</p><p>–》 DI</p><p>–》 AOP</p><p>–》事务。日志</p><h1 id="26-Spring-框架中的单例-bean-是线程安全的吗"><a href="#26-Spring-框架中的单例-bean-是线程安全的吗" class="headerlink" title="26.Spring 框架中的单例 bean 是线程安全的吗?"></a>26.Spring 框架中的单例 bean 是线程安全的吗?</h1><p>不，Spring 框架中的单例 bean 不是线程安全的。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/04/10/springBoot%E9%9D%A2%E7%BB%8F/09-SpringBoot%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2024/04/10/springBoot%E9%9D%A2%E7%BB%8F/09-SpringBoot%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="什么是-Spring-Boot？"><a href="#什么是-Spring-Boot？" class="headerlink" title="什么是 Spring Boot？"></a>什么是 Spring Boot？</h2><p>Spring Boot 是 Spring 开源组织下的子项目，是 Spring 组件一站式解决方案，主要是简化了使用 Spring 的难度，简省了繁重的配置，提供了各种启动器，开发者能快速上手。</p><h2 id="Spring-Boot-有哪些优点？"><a href="#Spring-Boot-有哪些优点？" class="headerlink" title="Spring Boot 有哪些优点？"></a>Spring Boot 有哪些优点？</h2><p>Spring Boot 主要有如下优点：</p><ol><li><p>容易上手，提升开发效率，为 Spring 开发提供一个更快、更广泛的入门体验。</p></li><li><p>开箱即用，远离繁琐的配置。</p></li><li><p>提供了一系列大型项目通用的非业务性功能，例如：内嵌服务器、安全管理、运行数据监控、运行状况检查和外部化配置等。</p></li><li><p>没有代码生成，也不需要XML配置。</p></li><li><p>避免大量的 Maven 导入和各种版本冲突。</p></li></ol><h2 id="Spring-Boot-的核心注解是哪个？它主要由哪几个注解组成的？"><a href="#Spring-Boot-的核心注解是哪个？它主要由哪几个注解组成的？" class="headerlink" title="Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？"></a>Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？</h2><p>启动类上面的注解是@SpringBootApplication，它也是 Spring Boot 的核心注解，主要组合包含了以下 3 个注解：</p><p>@SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。</p><p>@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项，如关闭数据源自动配置功能： @SpringBootApplication(exclude </p><p>&#x3D; { DataSourceAutoConfiguration.class })。</p><p>@ComponentScan：Spring组件扫描。</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h2 id="什么是-JavaConfig？"><a href="#什么是-JavaConfig？" class="headerlink" title="什么是 JavaConfig？"></a>什么是 JavaConfig？</h2><p>Spring JavaConfig 是 Spring 社区的产品，它提供了配置 Spring IoC 容器的纯Java 方法。因此它有助于避免使用 XML 配置。使用 JavaConfig 的优点在于：</p><p>（1）  面向对象的配置。由于配置被定义为 JavaConfig 中的类，因此用户可以</p><p>充分利用 Java 中的面向对象功能。一个配置类可以继承另一个，重写它的</p><p>@Bean 方法等。</p><p>（2）  减少或消除 XML 配置。基于依赖注入原则的外化配置的好处已被证明。</p><p>但是，许多开发人员不希望在 XML 和 Java 之间来回切换。JavaConfig 为开发人员提供了一种纯 Java 方法来配置与 XML 配置概念相似的 Spring 容器。从</p><p>技术角度来讲，只使用 JavaConfig 配置类来配置容器是可行的，但实际上很多人认为将JavaConfig 与 XML 混合匹配是理想的。（3）类型安全和重构友好。JavaConfig 提供了一种类型安全的方法来配置 </p><p>Spring容器。由于 Java 5.0 对泛型的支持，现在可以按类型而不是按名称检索 bean，不需要任何强制转换或基于字符串的查找。</p><h2 id="Spring-Boot-自动配置原理是什么？"><a href="#Spring-Boot-自动配置原理是什么？" class="headerlink" title="Spring Boot 自动配置原理是什么？"></a>Spring Boot 自动配置原理是什么？</h2><p>BFPP：BeanFactoryPostProcessor</p><p>BPP：BeanPostProcessor</p><p>BDRPP:BeanDefinitionRegistryPostProcessor</p><p>表达的总体思路是：总-分-总</p><p>1、springboot自动装配是什么，解决了什么问题</p><p>2、自动装配实现的原理：</p><p>​1、当启动springboot应用程序的时候， 会先创建SpringApplication的对象，在对象的构造方法中会进行某些参数的初始化工作，最主要的是判断当前应用程序的类型以及初始化器和监听器，在这个过程中会加载整个应用程序中的spring.factories文件，将文件的内容放到缓存对象中，方便后续获取。</p><p>​2、SpringApplication对象创建完成之后，开始执行run方法，来完成整个启动，启动过程中最主要的有两个方法，第一个叫做prepareContext，第二个叫做refreshContext,在这两个关键步骤中完整了自动装配的核心功能，前面的处理逻辑包含了上下文对象的创建，banner的打印，异常报告期的准备等各个准备工作，方便后续来进行调用。</p><p>​3、在prepareContext方法中主要完成的是对上下文对象的初始化操作，包括了属性值的设置，比如环境对象，在整个过程中有一个非常重要的方法，叫做load，load主要完成一件事，将当前启动类做为一个beanDefinition注册到registry中，方便后续在进行BeanFactoryPostProcessor调用执行的时候，找到对应的主类，来完成@SpringBootApplicaiton,@EnableAutoConfiguration等注解的解析工作</p><p>​4、在refreshContext方法中会进行整个容器刷新过程，会调用中spring中的refresh方法，refresh中有13个非常关键的方法，来完成整个spring应用程序的启动，在自动装配过程中，会调用invokeBeanFactoryPostProcessor方法，在此方法中主要是对ConfigurationClassPostProcessor类的处理，这次是BFPP的子类也是BDRPP的子类，在调用的时候会先调用BDRPP中的postProcessBeanDefinitionRegistry方法，然后调用postProcessBeanFactory方法，在执行postProcessBeanDefinitionRegistry的时候回解析处理各种注解，包含@PropertySource,@ComponentScan,@ComponentScans，@Bean,@Import等注解，最主要的是@Import注解的解析</p><p>​5、在解析@Import注解的时候，会有一个getImports的方法，从主类开始递归解析注解，把所有包含@Import的注解都解析到，然后在processImport方法中对Import的类进行分类，此处主要识别的时候AutoConfigurationImportSelect归属于ImportSelect的子类，在后续过程中会调用deferredImportSelectorHandler中的process方法，来完整EnableAutoConfiguration的加载。</p><p>​6、上面是我对springboot自动装配的简单理解，面试官您看一下，我回答有没有问题，帮我指点一下！</p><h2 id="你如何理解-Spring-Boot-配置加载顺序？"><a href="#你如何理解-Spring-Boot-配置加载顺序？" class="headerlink" title="你如何理解 Spring Boot 配置加载顺序？"></a>你如何理解 Spring Boot 配置加载顺序？</h2><p>在 Spring Boot 里面，可以使用以下几种方式来加载配置。</p><p>1）     properties文件；</p><p>2）     YAML文件；</p><p>3）     系统环境变量；</p><p>等等……</p><h2 id="4）命令行参数；-什么是-YAML？"><a href="#4）命令行参数；-什么是-YAML？" class="headerlink" title="4）命令行参数； 什么是 YAML？"></a>4）命令行参数； 什么是 YAML？</h2><p>YAML 是一种人类可读的数据序列化语言。它通常用于配置文件。与属性文件相比，如果我们想要在配置文件中添加复杂的属性，YAML 文件就更加结构化，而且更少混淆。可以看出 YAML 具有分层配置数据。</p><h2 id="YAML-配置的优势在哪里"><a href="#YAML-配置的优势在哪里" class="headerlink" title="YAML 配置的优势在哪里 ?"></a>YAML 配置的优势在哪里 ?</h2><p>YAML 现在可以算是非常流行的一种配置文件格式了，无论是前端还是后端，都可以见到 YAML 配置。那么 YAML 配置和传统的 properties 配置相比到底有哪些优势呢？</p><ol><li><p>配置有序，在一些特殊的场景下，配置有序很关键</p></li><li><p>支持数组，数组中的元素可以是基本数据类型也可以是对象</p></li><li><p>简洁</p></li></ol><p>相比 properties 配置文件，YAML 还有一个缺点，就是不支持 @PropertySource 注解导入自定义的 YAML 配置。</p><h2 id="Spring-Boot-是否可以使用-XML-配置"><a href="#Spring-Boot-是否可以使用-XML-配置" class="headerlink" title="Spring Boot 是否可以使用 XML 配置 ?"></a>Spring Boot 是否可以使用 XML 配置 ?</h2><p>Spring Boot 推荐使用 Java 配置而非 XML 配置，但是 Spring Boot 中也可以使用 XML 配置，通过 @ImportResource 注解可以引入一个 XML 配置。 spring boot 核心配置文件是什么？</p><p>bootstrap.properties 和 application.properties 有何区别 ?</p><p>单纯做 Spring Boot 开发，可能不太容易遇到 bootstrap.properties 配置文</p><p>件，但是在结合 Spring Cloud 时，这个配置就会经常遇到了，特别是在需要加载一些远程配置文件的时侯。</p><p>spring boot 核心的两个配置文件：</p><p> bootstrap (. yml 或者 . properties)：boostrap 由父 ApplicationContext 加载的，比 applicaton 优先加载，配置在应用程序上下文的引导阶段生效。一般来说我们在 Spring Cloud Config 或者 Nacos 中会用到它。且 boostrap 里面的属性不</p><p>能被覆盖；</p><p> application (. yml 或者 . properties)： 由ApplicatonContext 加载，用于 spring boot 项目的自动化配置。</p><h2 id="什么是-Spring-Profiles？"><a href="#什么是-Spring-Profiles？" class="headerlink" title="什么是 Spring Profiles？"></a>什么是 Spring Profiles？</h2><p>Spring Profiles 允许用户根据配置文件（dev，test，prod 等）来注册 bean。因此，当应用程序在开发中运行时，只有某些 bean 可以加载，而在</p><p>PRODUCTION中，某些其他 bean 可以加载。假设我们的要求是 Swagger 文档仅适用于 QA 环境，并且禁用所有其他文档。这可以使用配置文件来完成。Spring Boot 使得使用配置文件非常简单。</p><h2 id="如何在自定义端口上运行-Spring-Boot-应用程序？"><a href="#如何在自定义端口上运行-Spring-Boot-应用程序？" class="headerlink" title="如何在自定义端口上运行 Spring Boot 应用程序？"></a>如何在自定义端口上运行 Spring Boot 应用程序？</h2><p>为了在自定义端口上运行 Spring Boot 应用程序，您可以在</p><p>application.properties 中指定端口。server.port &#x3D; 8090</p><h1 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h1><h2 id="如何实现-Spring-Boot-应用程序的安全性？"><a href="#如何实现-Spring-Boot-应用程序的安全性？" class="headerlink" title="如何实现 Spring Boot 应用程序的安全性？"></a>如何实现 Spring Boot 应用程序的安全性？</h2><p>为了实现 Spring Boot 的安全性，我们使用 spring-boot-starter-security 依赖项，并且必须添加安全配置。它只需要很少的代码。配置类将必须扩展</p><p>WebSecurityConfigurerAdapter 并覆盖其方法。</p><h2 id="Spring-Boot-中如何解决跨域问题"><a href="#Spring-Boot-中如何解决跨域问题" class="headerlink" title="Spring Boot 中如何解决跨域问题 ?"></a>Spring Boot 中如何解决跨域问题 ?</h2><p>跨域可以在前端通过 JSONP 来解决，但是 JSONP 只可以发送 GET 请求，无法发送其他类型的请求，在 RESTful 风格的应用中，就显得非常鸡肋，因此我们推荐在后端通过 （CORS，Cross-origin resource sharing） 来解决跨域问题。这种解决方案并非 Spring Boot 特有的，在传统的 SSM 框架中，就可以通过 CORS 来解决跨域问题，只不过之前我们是在 XML 文件中配置 CORS ，现在可以通过实现WebMvcConfigurer接口然后重写addCorsMappings方法解决跨域问题。</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span> @Configuration<br><span class="hljs-symbol">2 </span> public class CorsConfig implements WebMvcConfigurer &#123; <span class="hljs-number">3</span><br><span class="hljs-symbol">4 </span>  @Override<br><span class="hljs-symbol">5 </span>  public void addCorsMappings(CorsRegistry registry) &#123;<br><span class="hljs-symbol">6 </span>  registry.addMapping(<span class="hljs-string">&quot;/**&quot;</span>)<br><span class="hljs-symbol">7 </span>  .allowedOrigins(<span class="hljs-string">&quot;*&quot;</span>)<br><span class="hljs-symbol">8 </span>  .allowCredentials(true)<br><span class="hljs-symbol">9 </span>  .allowedMethods(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;POST&quot;</span>, <span class="hljs-string">&quot;PUT&quot;</span>, <span class="hljs-string">&quot;DELETE&quot;</span>, <span class="hljs-string">&quot;OPTIONS&quot;</span>)<br><span class="hljs-symbol">10 </span>  .maxAge(<span class="hljs-number">3600</span>);<br><span class="hljs-symbol">11 </span>  &#125; <br><span class="hljs-number">12</span><br><span class="hljs-symbol">13 </span> &#125;<br></code></pre></td></tr></table></figure><p>项目中前后端分离部署，所以需要解决跨域的问题。</p><p>我们使用cookie存放用户登录的信息，在spring拦截器进行权限控制，当权限不符合时，直接返回给用户固定的json结果。</p><p>当用户登录以后，正常使用；当用户退出登录状态时或者token过期时，由于拦截器和跨域的顺序有问题，出现了跨域的现象。</p><p>我们知道一个http请求，先走filter，到达servlet后才进行拦截器的处理，如果我们把cors放在filter里，就可以优先于权限拦截器执行。</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span> @Configuration<br><span class="hljs-symbol">2 </span> public class CorsConfig &#123; <span class="hljs-number">3</span><br><span class="hljs-symbol">4 </span>  @Bean<br><span class="hljs-symbol">5 </span>  public CorsFilter corsFilter() &#123;<br><span class="hljs-symbol">6 </span>  CorsConfiguration corsConfiguration = <span class="hljs-keyword">new</span> CorsConfiguration();<br><span class="hljs-symbol">7 </span>  corsConfiguration.addAllowedOrigin(<span class="hljs-string">&quot;*&quot;</span>);<br><span class="hljs-symbol">8 </span>  corsConfiguration.addAllowedHeader(<span class="hljs-string">&quot;*&quot;</span>);<br><span class="hljs-symbol">9 </span>  corsConfiguration.addAllowedMethod(<span class="hljs-string">&quot;*&quot;</span>);<br><span class="hljs-symbol">10 </span>  corsConfiguration.setAllowCredentials(true);<br><span class="hljs-symbol">11 </span>  UrlBasedCorsConfigurationSource urlBasedCorsConfigurationSource = <span class="hljs-keyword">new</span> U rlBasedCorsConfigurationSource();<br><span class="hljs-symbol">12 </span>  urlBasedCorsConfigurationSource.registerCorsConfiguration(<span class="hljs-string">&quot;/**&quot;</span>, corsCo nfiguration);<br><span class="hljs-symbol">13 </span>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CorsFilter(urlBasedCorsConfigurationSource);<br><span class="hljs-symbol">14 </span>  &#125; <br><span class="hljs-number">15</span><br><span class="hljs-symbol">16 </span> &#125;<br></code></pre></td></tr></table></figure><h2 id="什么是-CSRF-攻击？"><a href="#什么是-CSRF-攻击？" class="headerlink" title="什么是 CSRF 攻击？"></a>什么是 CSRF 攻击？</h2><p>CSRF 代表跨站请求伪造。这是一种攻击，迫使 终用户在当前通过身份验证的 Web 应用程序上执行不需要的操作。CSRF 攻击专门针对状态改变请求，而不是数据窃取，因为攻击者无法查看对伪造请求的响应。</p><h1 id="监视器"><a href="#监视器" class="headerlink" title="监视器"></a>监视器</h1><h2 id="Spring-Boot-中的监视器是什么？"><a href="#Spring-Boot-中的监视器是什么？" class="headerlink" title="Spring Boot 中的监视器是什么？"></a>Spring Boot 中的监视器是什么？</h2><p>Spring boot actuator 是 spring 启动框架中的重要功能之一。Spring boot 监视器可帮助您访问生产环境中正在运行的应用程序的当前状态。有几个指标必须在生产环境中进行检查和监控。即使一些外部应用程序可能正在使用这些服务来向相关人员触发警报消息。监视器模块公开了一组可直接作为 HTTP URL 访问 的REST 端点来检查状态。</p><p>如何在 Spring Boot 中禁用 Actuator 端点安全性？</p><p>默认情况下，所有敏感的 HTTP 端点都是安全的，只有具有 ACTUATOR 角色</p><p>的用户才能访问它们。安全性是使用标准的 HttpServletRequest.isUserInRole 方法实施的。 我们可以使用来禁用安全性。只有在执行机构端点在防火墙后访问时，才建议禁用安全性。</p><h2 id="我们如何监视所有-Spring-Boot-微服务？"><a href="#我们如何监视所有-Spring-Boot-微服务？" class="headerlink" title="我们如何监视所有 Spring Boot 微服务？"></a>我们如何监视所有 Spring Boot 微服务？</h2><p>Spring Boot 提供监视器端点以监控各个微服务的度量。这些端点对于获取有关应用程序的信息（如它们是否已启动）以及它们的组件（如数据库等）是否正常运行很有帮助。但是，使用监视器的一个主要缺点或困难是，我们必须单独打开应用程序的知识点以了解其状态或健康状况。想象一下涉及 50 个应用程序的微服务，管理员将不得不击中所有 50 个应用程序的执行终端。为了帮助我们处理这种情况，我们将使用位于的开源项目。 它建立在 Spring Boot Actuator 之上，它提供了一个 Web UI，使我们能够可视化多个应用程序的度量。</p><h1 id="整合第三方项目"><a href="#整合第三方项目" class="headerlink" title="整合第三方项目"></a>整合第三方项目</h1><h2 id="什么是-WebSockets？"><a href="#什么是-WebSockets？" class="headerlink" title="什么是 WebSockets？"></a>什么是 WebSockets？</h2><p>WebSocket 是一种计算机通信协议，通过单个 TCP 连接提供全双工通信信道。</p><p>1、     WebSocket 是双向的 -使用 WebSocket 客户端或服务器可以发起消息发送。</p><p>2、     WebSocket 是全双工的 -客户端和服务器通信是相互独立的。</p><p>3、     单个 TCP 连接 -初始连接使用 HTTP，然后将此连接升级到基于套接字的连接。然后这个单一连接用于所有未来的通信</p><p>4、     Light -与 http 相比，WebSocket 消息数据交换要轻得多。</p><p>什么是 Spring Data ?</p><p>Spring Data 是 Spring 的一个子项目。用于简化数据库访问，支持NoSQL 和 关系数据存储。其主要目标是使数据库的访问变得方便快捷。Spring Data 具有如下特点：</p><p>SpringData 项目支持 NoSQL 存储：</p><ol><li><p>MongoDB （文档数据库）</p></li><li><p>Neo4j（图形数据库）</p></li><li><p>Redis（键&#x2F;值存储）</p></li><li><p>Hbase（列族数据库）</p></li></ol><p>SpringData 项目所支持的关系数据存储技术：</p><ol><li><p>JDBC</p></li><li><p>JPA</p></li></ol><p>Spring Data Jpa 致力于减少数据访问层 (DAO) 的开发量. 开发者唯一要做的，就是声明持久层的接口，其他都交给 Spring Data JPA 来帮你完成！Spring Data JPA 通过规范方法的名字，根据符合规范的名字来确定方法需要实现什么样的逻辑。</p><h2 id="什么是-Spring-Batch？"><a href="#什么是-Spring-Batch？" class="headerlink" title="什么是 Spring Batch？"></a>什么是 Spring Batch？</h2><p>Spring Boot Batch 提供可重用的函数，这些函数在处理大量记录时非常重要，包括日志&#x2F;跟踪，事务管理，作业处理统计信息，作业重新启动，跳过和资源管理。它还提供了更先进的技术服务和功能，通过优化和分区技术，可以实现极高批量和高性能批处理作业。简单以及复杂的大批量批处理作业可以高度可扩展的方式利用框架处理重要大量的信息。</p><h2 id="什么是-FreeMarker-模板？"><a href="#什么是-FreeMarker-模板？" class="headerlink" title="什么是 FreeMarker 模板？"></a>什么是 FreeMarker 模板？</h2><p>FreeMarker 是一个基于 Java 的模板引擎，  初专注于使用 MVC 软件架构进行动态网页生成。使用 Freemarker 的主要优点是表示层和业务层的完全分离。程序员可以处理应用程序代码，而设计人员可以处理 html 页面设计。 后使用 freemarker 可以将这些结合起来，给出  终的输出页面。</p><h2 id="如何集成-Spring-Boot-和-ActiveMQ？"><a href="#如何集成-Spring-Boot-和-ActiveMQ？" class="headerlink" title="如何集成 Spring Boot 和 ActiveMQ？"></a>如何集成 Spring Boot 和 ActiveMQ？</h2><p>对于集成 Spring Boot 和 ActiveMQ，我们使用依赖关系。 它只需要很少的配置，并且不需要样板代码。</p><h2 id="什么是-Apache-Kafka？"><a href="#什么是-Apache-Kafka？" class="headerlink" title="什么是 Apache Kafka？"></a>什么是 Apache Kafka？</h2><p>Apache Kafka 是一个分布式发布 - 订阅消息系统。它是一个可扩展的，容错的发布 - 订阅消息系统，它使我们能够构建分布式应用程序。这是一个 Apache 顶级项目。Kafka 适合离线和在线消息消费。</p><h2 id="什么是-Swagger？你用-Spring-Boot-实现了它吗？"><a href="#什么是-Swagger？你用-Spring-Boot-实现了它吗？" class="headerlink" title="什么是 Swagger？你用 Spring Boot 实现了它吗？"></a>什么是 Swagger？你用 Spring Boot 实现了它吗？</h2><p>Swagger 广泛用于可视化 API，使用 Swagger UI 为前端开发人员提供在线沙箱。Swagger 是用于生成 RESTful Web 服务的可视化表示的工具，规范和完整框架实现。它使文档能够以与服务器相同的速度更新。当通过 Swagger 正确定义时，消费者可以使用 少量的实现逻辑来理解远程服务并与其进行交互。因此，Swagger消除了调用服务时的猜测。</p><p>前后端分离，如何维护接口文档 ?</p><p>前后端分离开发日益流行，大部分情况下，我们都是通过 Spring Boot 做前后端分离开发，前后端分离一定会有接口文档，不然会前后端会深深陷入到扯皮中。一个比较笨的方法就是使用 word 或者 md 来维护接口文档，但是效率太低，接口一变，所有人手上的文档都得变。在 Spring Boot 中，这个问题常见</p><p>的解决方案是 Swagger ，使用 Swagger 我们可以快速生成一个接口文档网</p><p>站，接口一旦发生变化，文档就会自动更新，所有开发工程师访问这一个在线网站就可以获取到 新的接口文档，非常方便。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="如何重新加载-Spring-Boot-上的更改，而无需重新启动服务器？Spring-Boot项目如何热部署？"><a href="#如何重新加载-Spring-Boot-上的更改，而无需重新启动服务器？Spring-Boot项目如何热部署？" class="headerlink" title="如何重新加载 Spring Boot 上的更改，而无需重新启动服务器？Spring Boot项目如何热部署？"></a>如何重新加载 Spring Boot 上的更改，而无需重新启动服务器？Spring Boot项目如何热部署？</h2><p>这可以使用 DEV 工具来实现。通过这种依赖关系，您可以节省任何更改，嵌入式tomcat 将重新启动。Spring Boot 有一个开发工具（DevTools）模块，它有助于提高开发人员的生产力。Java 开发人员面临的一个主要挑战是将文件更改自动部署到服务器并自动重启服务器。开发人员可以重新加载 Spring Boot 上的更改，而无需重新启动服务器。这将消除每次手动部署更改的需要。</p><p>Spring Boot 在发布它的第一个版本时没有这个功能。这是开发人员 需要的功能。DevTools 模块完全满足开发人员的需求。该模块将在生产环境中被禁用。</p><p>它还提供 H2 数据库控制台以更好地测试应用程序。</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>&lt;dependency&gt;<br><span class="hljs-symbol">2 </span>  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br><span class="hljs-symbol">3 </span>  &lt;artifactId&gt;spring‐boot‐devtools&lt;/artifactId&gt;<br><span class="hljs-symbol">4 </span> &lt;/dependency&gt;<br></code></pre></td></tr></table></figure><h2 id="您使用了哪些-starter-maven-依赖项？"><a href="#您使用了哪些-starter-maven-依赖项？" class="headerlink" title="您使用了哪些 starter maven 依赖项？"></a>您使用了哪些 starter maven 依赖项？</h2><p>使用了下面的一些依赖项</p><p>spring-boot-starter-activemq</p><p>spring-boot-starter-security</p><p>这有助于增加更少的依赖关系，并减少版本的冲突。</p><p>Spring Boot 中的 starter 到底是什么 ?</p><p>首先，这个 Starter 并非什么新的技术点，基本上还是基于 Spring 已有功能来实现的。首先它提供了一个自动化配置类，一般命名为 XXXAutoConfiguration </p><p>，在这个配置类中通过条件注解来决定一个配置是否生效（条件注解就是 </p><p>Spring 中原本就有的），然后它还会提供一系列的默认配置，也允许开发者根据实际情况自定义相关配置，然后通过类型安全的属性注入将这些配置属性注入进来，新注入的属性会代替掉默认属性。正因为如此，很多第三方框架，我们只需要引入依赖就可以直接使用了。当然，开发者也可以自定义 Starter spring-boot-starter-parent 有什么用 ?</p><p>我们都知道，新创建一个 Spring Boot 项目，默认都是有 parent 的，这个 </p><p>parent 就是 spring-boot-starter-parent ，spring-boot-starter-parent 主要有如下作用：</p><ol><li><p>定义了 Java 编译版本为 1.8 。</p></li><li><p>使用 UTF-8 格式编码。</p></li><li><p>继承自 spring-boot-dependencies，这个里边定义了依赖的版本，也正是因为继承了这个依赖，所以我们在写依赖时才不需要写版本号。</p></li><li><p>执行打包操作的配置。</p></li><li><p>自动化的资源过滤。</p></li><li><p>自动化的插件配置。</p></li><li><p>针对 application.properties 和 application.yml 的资源过滤，包括通过 profile 定义的不同环境的配置文件，例如 applicationdev.properties 和 application-dev.yml。</p></li></ol><p>Spring Boot 打成的 jar 和普通的 jar 有什么区别 ?</p><p>Spring Boot 项目  终打包成的 jar 是可执行 jar ，这种 jar 可以直接通过 java jar xxx.jar 命令来运行，这种 jar 不可以作为普通的 jar 被其他项目依赖，即使依赖了也无法使用其中的类。</p><p>Spring Boot 的 jar 无法被其他项目依赖，主要还是他和普通 jar 的结构不同。普通的 jar 包，解压后直接就是包名，包里就是我们的代码，而 Spring Boot </p><p>打包成的可执行 jar 解压后，在 \BOOT-INF\classes 目录下才是我们的代码，因此无法被直接引用。如果非要引用，可以在 pom.xml 文件中增加配置，将 Spring Boot 项目打包成两个 jar ，一个可执行，一个可引用。</p><h2 id="运行-Spring-Boot-有哪几种方式？"><a href="#运行-Spring-Boot-有哪几种方式？" class="headerlink" title="运行 Spring Boot 有哪几种方式？"></a>运行 Spring Boot 有哪几种方式？</h2><p>1）     打包用命令或者放到容器中运行</p><p>2）     用 Maven&#x2F; Gradle 插件运行</p><p>3）直接执行 main 方法运行</p><h2 id="Spring-Boot-需要独立的容器运行吗？"><a href="#Spring-Boot-需要独立的容器运行吗？" class="headerlink" title="Spring Boot 需要独立的容器运行吗？"></a>Spring Boot 需要独立的容器运行吗？</h2><h2 id="开启-Spring-Boot-特性有哪几种方式？"><a href="#开启-Spring-Boot-特性有哪几种方式？" class="headerlink" title="开启 Spring Boot 特性有哪几种方式？"></a>开启 Spring Boot 特性有哪几种方式？</h2><p>1）     继承spring-boot-starter-parent项目</p><p>2）     导入spring-boot-dependencies项目依赖</p><h2 id="如何使用-Spring-Boot-实现异常处理？"><a href="#如何使用-Spring-Boot-实现异常处理？" class="headerlink" title="如何使用 Spring Boot 实现异常处理？"></a>如何使用 Spring Boot 实现异常处理？</h2><p>Spring 提供了一种使用 ControllerAdvice 处理异常的非常有用的方法。 我们通过实现一个 ControlerAdvice 类，来处理控制器类抛出的所有异常。</p><h2 id="如何使用-Spring-Boot-实现分页和排序？"><a href="#如何使用-Spring-Boot-实现分页和排序？" class="headerlink" title="如何使用 Spring Boot 实现分页和排序？"></a>如何使用 Spring Boot 实现分页和排序？</h2><p>使用 Spring Boot 实现分页非常简单。使用 Spring Data-JPA 可以实现将可分页的传递给存储库方法。</p><p>微服务中如何实现 session 共享 ?</p><p>在微服务中，一个完整的项目被拆分成多个不相同的独立的服务，各个服务独立部署在不同的服务器上，各自的 session 被从物理空间上隔离开了，但是经</p><p>常，我们需要在不同微服务之间共享 session ，常见的方案就是 Spring </p><p>Session + Redis 来实现 session 共享。将所有微服务的 session 统一保存在 Redis 上，当各个微服务对 session 有相关的读写操作时，都去操作 Redis 上的 session 。这样就实现了 session 共享，Spring Session 基于 Spring 中的代理过滤器实现，使得 session 的同步操作对开发人员而言是透明的，非常简便。</p><h2 id="Spring-Boot-中如何实现定时任务"><a href="#Spring-Boot-中如何实现定时任务" class="headerlink" title="Spring Boot 中如何实现定时任务 ?"></a>Spring Boot 中如何实现定时任务 ?</h2><p>定时任务也是一个常见的需求，Spring Boot 中对于定时任务的支持主要还是来自 Spring 框架。</p><p>在 Spring Boot 中使用定时任务主要有两种不同的方式，一个就是使用 Spring 中的 @Scheduled 注解，另一个则是使用第三方框架 Quartz。</p><p>使用 Spring 中的 @Scheduled 的方式主要通过 @Scheduled 注解来实现。</p><p>使用 Quartz ，则按照 Quartz 的方式，定义 Job 和 Trigger 即可。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/04/10/spring%E9%9D%A2%E7%BB%8F/Spring%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98/"/>
    <url>/2024/04/10/spring%E9%9D%A2%E7%BB%8F/Spring%E9%9D%A2%E8%AF%95%E4%B8%93%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<blockquote><p>讲师：邓澎波</p></blockquote><h1 id="Spring面试专题"><a href="#Spring面试专题" class="headerlink" title="Spring面试专题"></a>Spring面试专题</h1><h1 id="1-Spring应该很熟悉吧？来介绍下你的Spring的理解"><a href="#1-Spring应该很熟悉吧？来介绍下你的Spring的理解" class="headerlink" title="1.Spring应该很熟悉吧？来介绍下你的Spring的理解"></a>1.Spring应该很熟悉吧？来介绍下你的Spring的理解</h1><p>  有些同学可能会抢答，不熟悉!!!</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/1462/1646114654000/5dc1f730b32a4fc49922745f43a5c614.png" alt="image.png"></p><p>  好了，不开玩笑，面对这个问题我们应该怎么来回答呢？我们给大家梳理这个几个维度来回答</p><h2 id="1-1-Spring的发展历程"><a href="#1-1-Spring的发展历程" class="headerlink" title="1.1 Spring的发展历程"></a>1.1 Spring的发展历程</h2><p>  先介绍Spring是怎么来的，发展中有哪些核心的节点，当前的最新版本是什么等</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/1462/1646114654000/f401749c6b6c435d932f949067f0b252.png" alt="image.png"></p><p> 通过上图可以比较清晰的看到Spring的各个时间版本对应的时间节点了。也就是Spring从之前单纯的xml的配置方式，到现在的完全基于注解的编程方式发展。</p><h2 id="1-2-Spring的组成"><a href="#1-2-Spring的组成" class="headerlink" title="1.2 Spring的组成"></a>1.2 Spring的组成</h2><p>&emsp;&emsp;Spring是一个轻量级的IoC和AOP容器框架。是为Java应用程序提供基础性服务的一套框架，目的是用于简化企业应用程序的开发，它使得开发者只需要关心业务需求。常见的配置方式有三种：基于XML的配置、基于注解的配置、基于Java的配置.</p><p>主要由以下几个模块组成：</p><ul><li>Spring Core：核心类库，提供IOC服务；</li><li>Spring Context：提供框架式的Bean访问方式，以及企业级功能（JNDI、定时任务等）；</li><li>Spring AOP：AOP服务；</li><li>Spring DAO：对JDBC的抽象，简化了数据访问异常的处理；</li><li>Spring ORM：对现有的ORM框架的支持；</li><li>Spring Web：提供了基本的面向Web的综合特性，例如多方文件上传；</li><li>Spring MVC：提供面向Web应用的Model-View-Controller实现。</li></ul><p><img src="https://img-blog.csdnimg.cn/2019011310002937.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="1-3-Spring的好处"><a href="#1-3-Spring的好处" class="headerlink" title="1.3 Spring的好处"></a>1.3 Spring的好处</h2><table><thead><tr><th>序号</th><th>好处</th><th align="left">说明</th></tr></thead><tbody><tr><td>1</td><td>轻量</td><td align="left">Spring 是轻量的，基本的版本大约2MB。</td></tr><tr><td>2</td><td>控制反转</td><td align="left">Spring通过控制反转实现了松散耦合，对象们给出它们的依赖，<code>&lt;br&gt;</code>而不是创建或查找依赖的对象们。</td></tr><tr><td>3</td><td>面向切面编程(AOP)</td><td align="left">Spring支持面向切面的编程，并且把应用业务逻辑和系统服务分开。</td></tr><tr><td>4</td><td>容器</td><td align="left">Spring 包含并管理应用中对象的生命周期和配置。</td></tr><tr><td>5</td><td>MVC框架</td><td align="left">Spring的WEB框架是个精心设计的框架，是Web框架的一个很好的替代品。</td></tr><tr><td>6</td><td>事务管理</td><td align="left">Spring 提供一个持续的事务管理接口，<code>&lt;br&gt;</code>可以扩展到上至本地事务下至全局事务（JTA）。</td></tr><tr><td>7</td><td>异常处理</td><td align="left">Spring 提供方便的API把具体技术相关的异常 <code>&lt;br&gt;</code>(比如由JDBC，Hibernate or JDO抛出的)转化为一致的unchecked 异常。</td></tr><tr><td>8</td><td>最重要的</td><td align="left">用的人多！！！</td></tr></tbody></table><h1 id="2-Spring框架中用到了哪些设计模式"><a href="#2-Spring框架中用到了哪些设计模式" class="headerlink" title="2.Spring框架中用到了哪些设计模式"></a>2.Spring框架中用到了哪些设计模式</h1><h2 id="2-1-单例模式"><a href="#2-1-单例模式" class="headerlink" title="2.1 单例模式"></a>2.1 单例模式</h2><p>&emsp;&emsp;单例模式应该是大家印象最深的一种设计模式了。在Spring中最明显的使用场景是在配置文件中配置注册bean对象的时候<strong>设置scope的值为singleton</strong> 。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans </span></span><br><span class="hljs-string"><span class="hljs-tag"> http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.dpb.pojo.User&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;singleton&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;波波烤鸭&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h2 id="2-2-原型模式"><a href="#2-2-原型模式" class="headerlink" title="2.2 原型模式"></a>2.2 原型模式</h2><p>&emsp;&emsp;原型模式也叫克隆模式，Spring中该模式使用的很明显，和单例一样在bean标签中设置scope的属性prototype即表示该bean以克隆的方式生成</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans </span></span><br><span class="hljs-string"><span class="hljs-tag"> http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.dpb.pojo.User&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;prototype&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;波波烤鸭&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h2 id="2-3-模板模式"><a href="#2-3-模板模式" class="headerlink" title="2.3 模板模式"></a>2.3 模板模式</h2><p>&emsp;&emsp;模板模式的核心是父类定义好流程，然后将流程中需要子类实现的方法就抽象话留给子类实现，Spring中的JdbcTemplate就是这样的实现。我们知道jdbc的步骤是固定</p><ul><li>加载驱动,</li><li>获取连接通道,</li><li>构建sql语句.</li><li>执行sql语句,</li><li>关闭资源</li></ul><p>  在这些步骤中第3步和第四步是不确定的,所以就留给客户实现，而我们实际使用JdbcTemplate的时候也确实是只需要构建SQL就可以了.这就是典型的模板模式。我们以query方法为例来看下JdbcTemplate中的代码.</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/1462/1646114654000/a1f1150a38f94b518794e3e5df467092.png" alt="image.png"></p><h2 id="2-4-观察者模式"><a href="#2-4-观察者模式" class="headerlink" title="2.4 观察者模式"></a>2.4 观察者模式</h2><p>&emsp;&emsp;观察者模式定义的是对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。使用比较场景是在监听器中而spring中Observer模式常用的地方也是listener的实现。如ApplicationListener.</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/1462/1646114654000/32247ef6524c430dab31ea97294f28ae.png" alt="image.png"></p><h2 id="2-5-工厂模式"><a href="#2-5-工厂模式" class="headerlink" title="2.5 工厂模式"></a>2.5 工厂模式</h2><p><strong>简单工厂模式</strong>：</p><p>&emsp;&emsp;简单工厂模式就是通过工厂根据传递进来的参数决定产生哪个对象。Spring中我们通过getBean方法获取对象的时候根据id或者name获取就是简单工厂模式了。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-string"><span class="hljs-tag">http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">context:annotation-config</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.dpb.pojo.User&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span>  &gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;波波烤鸭&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p><strong>工厂方法模式</strong>：</p><p>&emsp;&emsp;在Spring中我们一般是将Bean的实例化直接交给容器去管理的，实现了使用和创建的分离，这时容器直接管理对象，还有种情况是，bean的创建过程我们交给一个工厂去实现，而Spring容器管理这个工厂。这个就是我们讲的工厂模式，在Spring中有两种实现一种是静态工厂方法模式，一种是动态工厂方法模式。以静态工厂来演示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * User 工厂类</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> dpb[波波烤鸭]</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserFactory</span> &#123;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 必须是static方法</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> UserBean <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserBean</span>();<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>application.xml文件中注册</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans </span></span><br><span class="hljs-string"><span class="hljs-tag">http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 静态工厂方式配置 配置静态工厂及方法 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.dpb.factory.UserFactory&quot;</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">&quot;getInstance&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user2&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h2 id="2-6-适配器模式"><a href="#2-6-适配器模式" class="headerlink" title="2.6 适配器模式"></a>2.6 适配器模式</h2><p>&emsp;&emsp;将一个类的接口转换成客户希望的另外一个接口。使得原本由于接口不兼容而不能一起工作的那些类可以在一起工作。这就是适配器模式。在Spring中在AOP实现中的Advice和interceptor之间的转换就是通过适配器模式实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MethodBeforeAdviceAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AdvisorAdapter</span>, Serializable &#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">supportsAdvice</span><span class="hljs-params">(Advice advice)</span> &#123;<br><span class="hljs-keyword">return</span> (advice <span class="hljs-keyword">instanceof</span> MethodBeforeAdvice);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> MethodInterceptor <span class="hljs-title function_">getInterceptor</span><span class="hljs-params">(Advisor advisor)</span> &#123;<br><span class="hljs-type">MethodBeforeAdvice</span> <span class="hljs-variable">advice</span> <span class="hljs-operator">=</span> (MethodBeforeAdvice) advisor.getAdvice();<br><span class="hljs-comment">// 通知类型匹配对应的拦截器</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MethodBeforeAdviceInterceptor</span>(advice);<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="2-7-装饰者模式"><a href="#2-7-装饰者模式" class="headerlink" title="2.7 装饰者模式"></a>2.7 装饰者模式</h2><p>&emsp;&emsp;装饰者模式又称为包装模式(Wrapper),作用是用来动态的为一个对象增加新的功能。装饰模式是一种用于代替继承的技术，无须通过继承增加子类就能扩展对象的新功能。使用对象的关联关系代替继承关系，更加灵活，同时避免类型体系的快速膨胀。<br>&emsp;&emsp;spring中用到的包装器模式在类名上有两种表现：一种是类名中含有Wrapper，另一种是类名中含有Decorator。基本上都是动态地给一个对象添加一些额外的职责。<br>&emsp;&emsp;具体的使用在Spring session框架中的SessionRepositoryRequestWrapper使用包装模式对原生的request的功能进行增强，可以将session中的数据和分布式数据库进行同步，这样即使当前tomcat崩溃，session中的数据也不会丢失。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.session<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-session<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.1.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h2 id="2-8-代理模式"><a href="#2-8-代理模式" class="headerlink" title="2.8 代理模式"></a>2.8 代理模式</h2><p>&emsp;&emsp;代理模式应该是大家非常熟悉的设计模式了，在Spring中AOP的实现中代理模式使用的很彻底.</p><h2 id="2-9-策略模式"><a href="#2-9-策略模式" class="headerlink" title="2.9 策略模式"></a>2.9 策略模式</h2><p>&emsp;&emsp;策略模式对应于解决某一个问题的一个算法族，允许用户从该算法族中任选一个算法解决某一问题，同时可以方便的更换算法或者增加新的算法。并且由客户端决定调用哪个算法，spring中在实例化对象的时候用到Strategy模式。XmlBeanDefinitionReader,PropertiesBeanDefinitionReader</p><h2 id="2-10-责任链默认"><a href="#2-10-责任链默认" class="headerlink" title="2.10 责任链默认"></a>2.10 责任链默认</h2><p>AOP中的拦截器链</p><h2 id="2-11-委托者模式"><a href="#2-11-委托者模式" class="headerlink" title="2.11 委托者模式"></a>2.11 委托者模式</h2><p>DelegatingFilterProxy，整合Shiro，SpringSecurity的时候都有用到。</p><p>…..</p><h1 id="3-Autowired和Resource关键字的区别？"><a href="#3-Autowired和Resource关键字的区别？" class="headerlink" title="3.Autowired和Resource关键字的区别？"></a>3.Autowired和Resource关键字的区别？</h1><p>&emsp;&emsp;这是一个相对比较简单的问题，@Resource和@Autowired都是做bean的注入时使用，其实@Resource并不是Spring的注解，它的包是javax.annotation.Resource，需要导入，但是Spring支持该注解的注入。</p><h2 id="3-1-共同点"><a href="#3-1-共同点" class="headerlink" title="3.1 共同点"></a>3.1 共同点</h2><p>&emsp;&emsp;两者都可以写在字段和setter方法上。两者如果都写在字段上，那么就不需要再写setter方法.</p><h2 id="3-2-不同点"><a href="#3-2-不同点" class="headerlink" title="3.2 不同点"></a>3.2 不同点</h2><p><strong>@Autowired</strong></p><p>&emsp;&emsp;@Autowired为Spring提供的注解，需要导入org.springframework.beans.factory.annotation.Autowired;只按照byType注入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestServiceImpl</span> &#123;<br> <span class="hljs-comment">// 下面两种@Autowired只要使用一种即可</span><br> <span class="hljs-meta">@Autowired</span><br> <span class="hljs-keyword">private</span> UserDao userDao; <span class="hljs-comment">// 用于字段上</span><br> <br> <span class="hljs-meta">@Autowired</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUserDao</span><span class="hljs-params">(UserDao userDao)</span> &#123; <span class="hljs-comment">// 用于属性的方法上</span><br> <span class="hljs-built_in">this</span>.userDao = userDao;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>@Autowired注解是按照类型（byType）装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false。如果我们想使用按照名称（byName）来装配，可以结合@Qualififier注解一起使用。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestServiceImpl</span> &#123;<br> <span class="hljs-meta">@Autowired</span><br> <span class="hljs-meta">@Qualifier(&quot;userDao&quot;)</span><br> <span class="hljs-keyword">private</span> UserDao userDao; &#125;<br></code></pre></td></tr></table></figure><p><strong>@Resource</strong></p><p>&emsp;&emsp;@Resource默认按照ByName自动注入，由J2EE提供，需要导入包javax.annotation.Resource。@Resource有两个重要的属性：name和type，而Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以，如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不制定name也不制定type属性，这时将通过反射机制使用byName自动注入策略.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestServiceImpl</span> &#123;<br> <span class="hljs-comment">// 下面两种@Resource只要使用一种即可</span><br> <span class="hljs-meta">@Resource(name=&quot;userDao&quot;)</span><br> <span class="hljs-keyword">private</span> UserDao userDao; <span class="hljs-comment">// 用于字段上</span><br> <br> <span class="hljs-meta">@Resource(name=&quot;userDao&quot;)</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUserDao</span><span class="hljs-params">(UserDao userDao)</span> &#123; <span class="hljs-comment">// 用于属性的setter方法上</span><br> <span class="hljs-built_in">this</span>.userDao = userDao;<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>@Resource装配顺序：</p><ol><li>如果同时指定了name和type，则从Spring上下文中找到唯一匹配的bean进行装配，找不到则抛出异常。</li><li>如果指定了name，则从上下文中查找名称（id）匹配的bean进行装配，找不到则抛出异常。</li><li>如果指定了type，则从上下文中找到类似匹配的唯一bean进行装配，找不到或是找到多个，都会抛出异常。</li><li>如果既没有指定name，又没有指定type，则自动按照byName方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配。</li></ol><p>@Resource的作用相当于@Autowired，只不过@Autowired按照byType自动注入。</p><h1 id="4-Spring中常用的注解有哪些，重点介绍几个"><a href="#4-Spring中常用的注解有哪些，重点介绍几个" class="headerlink" title="4.Spring中常用的注解有哪些，重点介绍几个"></a>4.Spring中常用的注解有哪些，重点介绍几个</h1><p>@Controller  @Service @RestController @RequestBody,@Indexd  @Import等</p><p>@Indexd提升 @ComponentScan的效率</p><p>@Import注解是import标签的替换，在SpringBoot的自动装配中非常重要，也是EnableXXX的前置基础。</p><h1 id="5-循环依赖"><a href="#5-循环依赖" class="headerlink" title="5.循环依赖"></a>5.循环依赖</h1><p>面试的重点，大厂必问之一：</p><h2 id="5-1-什么是循环依赖"><a href="#5-1-什么是循环依赖" class="headerlink" title="5.1 什么是循环依赖"></a>5.1 什么是循环依赖</h2><p>看下图</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/1462/1646114654000/d1e9bec7b2d648b3b777caeb6da2a872.png" alt="image.png"></p><p>&emsp;&emsp;上图是循环依赖的三种情况，虽然方式有点不一样，但是循环依赖的本质是一样的，就你的完整创建要依赖与我，我的完整创建也依赖于你。相互依赖从而没法完整创建造成失败。</p><h2 id="5-2-代码演示"><a href="#5-2-代码演示" class="headerlink" title="5.2 代码演示"></a>5.2 代码演示</h2><p>&emsp;&emsp;我们再通过代码的方式来演示下循环依赖的效果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CircularTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">CircularTest1</span>();<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CircularTest1</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">CircularTest2</span> <span class="hljs-variable">circularTest2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CircularTest2</span>();<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CircularTest2</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">CircularTest1</span> <span class="hljs-variable">circularTest1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CircularTest1</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>执行后出现了 StackOverflowError 错误</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/1462/1646114654000/ad194978a72a4312bff8f659806028e9.png" alt="image.png"></p><p>&emsp;&emsp;上面的就是最基本的循环依赖的场景，你需要我，我需要你，然后就报错了。而且上面的这种设计情况我们是没有办法解决的。那么针对这种场景我们应该要怎么设计呢？这个是关键！</p><h2 id="5-3-分析问题"><a href="#5-3-分析问题" class="headerlink" title="5.3 分析问题"></a>5.3 分析问题</h2><p>&emsp;&emsp;首先我们要明确一点就是如果这个对象A还没创建成功，在创建的过程中要依赖另一个对象B，而另一个对象B也是在创建中要依赖对象A，这种肯定是无解的，这时我们就要转换思路，我们先把A创建出来，但是还没有完成初始化操作，也就是这是一个半成品的对象，然后在赋值的时候先把A暴露出来，然后创建B，让B创建完成后找到暴露的A完成整体的实例化，这时再把B交给A完成A的后续操作，从而揭开了循环依赖的密码。也就是如下图：</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/1462/1646114654000/b42b8c3aa1784ad7881001044aae7910.png" alt="image.png"></p><h2 id="5-4-自己解决"><a href="#5-4-自己解决" class="headerlink" title="5.4 自己解决"></a>5.4 自己解决</h2><p>&emsp;&emsp;明白了上面的本质后，我们可以自己来尝试解决下：</p><p>先来把上面的案例改为set&#x2F;get来依赖关联</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CircularTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        System.out.println(getBean(CircularTest1.class).getCircularTest2());<br>        System.out.println(getBean(CircularTest2.class).getCircularTest1());<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; T <span class="hljs-title function_">getBean</span><span class="hljs-params">(Class&lt;T&gt; beanClass)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-comment">// 1.获取 实例对象</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> beanClass.newInstance();<br>        <span class="hljs-comment">// 2.完成属性填充</span><br>        Field[] declaredFields = obj.getClass().getDeclaredFields();<br>        <span class="hljs-comment">// 遍历处理</span><br>        <span class="hljs-keyword">for</span> (Field field : declaredFields) &#123;<br>            field.setAccessible(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 针对private修饰</span><br>            <span class="hljs-comment">// 获取成员变量 对应的类对象</span><br>            Class&lt;?&gt; fieldClass = field.getType();<br>            <span class="hljs-comment">// 获取对应的 beanName</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">fieldBeanName</span> <span class="hljs-operator">=</span> fieldClass.getSimpleName().toLowerCase();<br>            <span class="hljs-comment">// 给成员变量赋值 如果 singletonObjects 中有半成品就获取，否则创建对象</span><br>            field.set(obj,getBean(fieldClass));<br>        &#125;<br>        <span class="hljs-keyword">return</span> (T) obj;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CircularTest1</span>&#123;<br>    <span class="hljs-keyword">private</span> CircularTest2 circularTest2;<br><br>    <span class="hljs-keyword">public</span> CircularTest2 <span class="hljs-title function_">getCircularTest2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> circularTest2;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCircularTest2</span><span class="hljs-params">(CircularTest2 circularTest2)</span> &#123;<br>        <span class="hljs-built_in">this</span>.circularTest2 = circularTest2;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CircularTest2</span>&#123;<br>    <span class="hljs-keyword">private</span> CircularTest1 circularTest1;<br><br>    <span class="hljs-keyword">public</span> CircularTest1 <span class="hljs-title function_">getCircularTest1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> circularTest1;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCircularTest1</span><span class="hljs-params">(CircularTest1 circularTest1)</span> &#123;<br>        <span class="hljs-built_in">this</span>.circularTest1 = circularTest1;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们再通过把对象实例化和成员变量赋值拆解开来处理。从而解决循环依赖的问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CircularTest</span> &#123;<br>    <span class="hljs-comment">// 保存提前暴露的对象，也就是半成品的对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> Map&lt;String,Object&gt; singletonObjects = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        System.out.println(getBean(CircularTest1.class).getCircularTest2());<br>        System.out.println(getBean(CircularTest2.class).getCircularTest1());<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; T <span class="hljs-title function_">getBean</span><span class="hljs-params">(Class&lt;T&gt; beanClass)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-comment">//1.获取类对象对应的名称</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">beanName</span> <span class="hljs-operator">=</span> beanClass.getSimpleName().toLowerCase();<br>        <span class="hljs-comment">// 2.根据名称去 singletonObjects 中查看是否有半成品的对象</span><br>        <span class="hljs-keyword">if</span>(singletonObjects.containsKey(beanName))&#123;<br>            <span class="hljs-keyword">return</span> (T) singletonObjects.get(beanName);<br>        &#125;<br>        <span class="hljs-comment">// 3. singletonObjects 没有半成品的对象，那么就反射实例化对象</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> beanClass.newInstance();<br>        <span class="hljs-comment">// 还没有完整的创建完这个对象就把这个对象存储在了 singletonObjects中</span><br>        singletonObjects.put(beanName,obj);<br>        <span class="hljs-comment">// 属性填充来补全对象</span><br>        Field[] declaredFields = obj.getClass().getDeclaredFields();<br>        <span class="hljs-comment">// 遍历处理</span><br>        <span class="hljs-keyword">for</span> (Field field : declaredFields) &#123;<br>            field.setAccessible(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 针对private修饰</span><br>            <span class="hljs-comment">// 获取成员变量 对应的类对象</span><br>            Class&lt;?&gt; fieldClass = field.getType();<br>            <span class="hljs-comment">// 获取对应的 beanName</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">fieldBeanName</span> <span class="hljs-operator">=</span> fieldClass.getSimpleName().toLowerCase();<br>            <span class="hljs-comment">// 给成员变量赋值 如果 singletonObjects 中有半成品就获取，否则创建对象</span><br>            field.set(obj,singletonObjects.containsKey(fieldBeanName)?<br>                    singletonObjects.get(fieldBeanName):getBean(fieldClass));<br>        &#125;<br>        <span class="hljs-keyword">return</span> (T) obj;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CircularTest1</span>&#123;<br>    <span class="hljs-keyword">private</span> CircularTest2 circularTest2;<br><br>    <span class="hljs-keyword">public</span> CircularTest2 <span class="hljs-title function_">getCircularTest2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> circularTest2;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCircularTest2</span><span class="hljs-params">(CircularTest2 circularTest2)</span> &#123;<br>        <span class="hljs-built_in">this</span>.circularTest2 = circularTest2;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CircularTest2</span>&#123;<br>    <span class="hljs-keyword">private</span> CircularTest1 circularTest1;<br><br>    <span class="hljs-keyword">public</span> CircularTest1 <span class="hljs-title function_">getCircularTest1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> circularTest1;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCircularTest1</span><span class="hljs-params">(CircularTest1 circularTest1)</span> &#123;<br>        <span class="hljs-built_in">this</span>.circularTest1 = circularTest1;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行程序你会发现问题完美的解决了</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/1462/1646114654000/63135dba531b45938dfbc9d69ecc6301.png" alt="image.png"></p><p>&emsp;&emsp;在上面的方法中的核心是getBean方法，Test1 创建后填充属性时依赖Test2，那么就去创建 Test2，在创建 Test2 开始填充时发现依赖于 Test1，但此时 Test1 这个半成品对象已经存放在缓存到 <code>singletonObjects</code> 中了，所以Test2可以正常创建，在通过递归把 Test1 也创建完整了。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/1462/1646114654000/2c97505674514ed28a774477c51e0f0b.png" alt="image.png"></p><p>最后总结下该案例解决的本质：</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/1462/1646114654000/09f7cb069e58480fa37c8c5ac0dd8467.png" alt="image.png"></p><h2 id="5-5-Spring循环依赖"><a href="#5-5-Spring循环依赖" class="headerlink" title="5.5 Spring循环依赖"></a>5.5 Spring循环依赖</h2><p>针对Spring中Bean对象的各种场景。支持的方案不一样：</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1646114654000/258d647b589345ba854ca8e6db50ba75.png" alt="image.png"></p><p>&emsp;&emsp;然后我们再来看看Spring中是如何解决循环依赖问题的呢？刚刚上面的案例中的对象的生命周期的核心就两个</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/1462/1646114654000/f297c4657bfa4318bb1db866ad960848.png" alt="image.png"></p><p>&emsp;&emsp;而Spring创建Bean的生命周期中涉及到的方法就很多了。下面是简单列举了对应的方法</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/1462/1646114654000/51bfe454457c459b8edabde7a40318b5.png" alt="image.png"></p><p>&emsp;&emsp;基于前面案例的了解，我们知道肯定需要在调用构造方法方法创建完成后再暴露对象，在Spring中提供了三级缓存来处理这个事情，对应的处理节点如下图：</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/1462/1646114654000/d4394ca79d9a4dea87ebb7c461d7485b.png" alt="image.png"></p><p>对应到源码中具体处理循环依赖的流程如下：</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/1462/1646114654000/33568ba20781477eafed5c790a44212a.png" alt="image.png"></p><p>&emsp;&emsp;上面就是在Spring的生命周期方法中和循环依赖出现相关的流程了。那么源码中的具体处理是怎么样的呢？我们继续往下面看。</p><p>首先在调用构造方法的后会放入到三级缓存中</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/1462/1646114654000/8fe6a991c479455fb588e4246de9709d.png" alt="image.png"></p><p>下面就是放入三级缓存的逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addSingletonFactory</span><span class="hljs-params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> &#123;<br>Assert.notNull(singletonFactory, <span class="hljs-string">&quot;Singleton factory must not be null&quot;</span>);<br><span class="hljs-comment">// 使用singletonObjects进行加锁，保证线程安全</span><br><span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.singletonObjects) &#123;<br><span class="hljs-comment">// 如果单例对象的高速缓存【beam名称-bean实例】没有beanName的对象</span><br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.singletonObjects.containsKey(beanName)) &#123;<br><span class="hljs-comment">// 将beanName,singletonFactory放到单例工厂的缓存【bean名称 - ObjectFactory】</span><br><span class="hljs-built_in">this</span>.singletonFactories.put(beanName, singletonFactory);<br><span class="hljs-comment">// 从早期单例对象的高速缓存【bean名称-bean实例】 移除beanName的相关缓存对象</span><br><span class="hljs-built_in">this</span>.earlySingletonObjects.remove(beanName);<br><span class="hljs-comment">// 将beanName添加已注册的单例集中</span><br><span class="hljs-built_in">this</span>.registeredSingletons.add(beanName);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在填充属性的时候会存入二级缓存中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">earlySingletonObjects.put(beanName,bean);<br>registeredSingletons.add(beanName);<br></code></pre></td></tr></table></figure><p>最后把创建的对象保存在了一级缓存中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addSingleton</span><span class="hljs-params">(String beanName, Object singletonObject)</span> &#123;<br><span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.singletonObjects) &#123;<br><span class="hljs-comment">// 将映射关系添加到单例对象的高速缓存中</span><br><span class="hljs-built_in">this</span>.singletonObjects.put(beanName, singletonObject);<br><span class="hljs-comment">// 移除beanName在单例工厂缓存中的数据</span><br><span class="hljs-built_in">this</span>.singletonFactories.remove(beanName);<br><span class="hljs-comment">// 移除beanName在早期单例对象的高速缓存的数据</span><br><span class="hljs-built_in">this</span>.earlySingletonObjects.remove(beanName);<br><span class="hljs-comment">// 将beanName添加到已注册的单例集中</span><br><span class="hljs-built_in">this</span>.registeredSingletons.add(beanName);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-6-疑问点"><a href="#5-6-疑问点" class="headerlink" title="5.6 疑问点"></a>5.6 疑问点</h2><p>这些疑问点也是面试官喜欢问的问题点</p><h3 id="为什么需要三级缓存"><a href="#为什么需要三级缓存" class="headerlink" title="为什么需要三级缓存"></a>为什么需要三级缓存</h3><p>三级缓存主要处理的是AOP的代理对象，存储的是一个ObjectFactory</p><p>三级缓存考虑的是带你对象，而二级缓存考虑的是性能-从三级缓存的工厂里创建出对象，再扔到二级缓存（这样就不用每次都要从工厂里拿）</p><h3 id="没有三级环境能解决吗？"><a href="#没有三级环境能解决吗？" class="headerlink" title="没有三级环境能解决吗？"></a>没有三级环境能解决吗？</h3><p>没有三级缓存是可以解决循环依赖问题的</p><h3 id="三级缓存分别什么作用"><a href="#三级缓存分别什么作用" class="headerlink" title="三级缓存分别什么作用"></a>三级缓存分别什么作用</h3><p>一级缓存：正式对象</p><p>二级缓存：半成品对象</p><p>三级缓存：工厂</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/1462/1646114654000/99f0bb5b710a49f6b9ebd53a173118a5.png" alt="image.png"></p><h1 id="6-Spring的生命周期"><a href="#6-Spring的生命周期" class="headerlink" title="6.Spring的生命周期"></a>6.Spring的生命周期</h1><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/1462/1646114654000/cf1072694ce9496aa04c3c6fde40c38a.png" alt="image.png"></p><p>结合图，把Bean对象在Spring中的关键节点介绍一遍</p><h1 id="7-Spring中支持几种作用域"><a href="#7-Spring中支持几种作用域" class="headerlink" title="7.Spring中支持几种作用域"></a>7.Spring中支持几种作用域</h1><p>Spring容器中的bean可以分为5个范围：</p><ol><li>prototype：为每一个bean请求提供一个实例。</li><li>singleton：默认，每个容器中只有一个bean的实例，单例的模式由BeanFactory自身来维护。</li><li>request：为每一个网络请求创建一个实例，在请求完成以后，bean会失效并被垃圾回收器回收。</li><li>session：与request范围类似，确保每个session中有一个bean的实例，在session过期后，bean会随之失效。</li><li>global-session：全局作用域，global-session和Portlet应用相关。当你的应用部署在Portlet容器中工作时，它包含很多portlet。如果你想要声明让所有的portlet共用全局的存储变量的话，那么这全局变量需要存储在global-session中。全局作用域与Servlet中的session作用域效果相同。</li></ol><h1 id="8-说说事务的隔离级别"><a href="#8-说说事务的隔离级别" class="headerlink" title="8.说说事务的隔离级别"></a>8.说说事务的隔离级别</h1><p>&emsp;&emsp;事务隔离级别指的是一个事务对数据的修改与另一个并行的事务的隔离程度，当多个事务同时访问相同数据时，如果没有采取必要的隔离机制，就可能发生以下问题：</p><table><thead><tr><th>问题</th><th align="left">描述</th></tr></thead><tbody><tr><td>脏读</td><td align="left">一个事务读到另一个事务未提交的更新数据，所谓脏读，就是指事务A读到了事务B还没有提交的数据，比如银行取钱，事务A开启事务，此时切换到事务B，事务B开启事务–&gt;取走100元，此时切换回事务A，事务A读取的肯定是数据库里面的原始数据，因为事务B取走了100块钱，并没有提交，数据库里面的账务余额肯定还是原始余额，这就是脏读</td></tr><tr><td>幻读</td><td align="left">是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。 同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象 发生了幻觉一样。</td></tr><tr><td>不可重复读</td><td align="left">在一个事务里面的操作中发现了未被操作的数据 比方说在同一个事务中先后执行两条一模一样的select语句，期间在此次事务中没有执行过任何DDL语句，但先后得到的结果不一致，这就是不可重复读</td></tr></tbody></table><p><strong>Spring支持的隔离级别</strong></p><table><thead><tr><th align="left">隔离级别</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">DEFAULT</td><td align="left">使用数据库本身使用的隔离级别 <code>&lt;br&gt;</code> ORACLE（读已提交） MySQL（可重复读）</td></tr><tr><td align="left">READ_UNCOMITTED</td><td align="left">读未提交（脏读）最低的隔离级别，一切皆有可能。</td></tr><tr><td align="left">READ_COMMITED</td><td align="left">读已提交，ORACLE默认隔离级别，有幻读以及不可重复读风险。</td></tr><tr><td align="left">REPEATABLE_READ</td><td align="left">可重复读，解决不可重复读的隔离级别，但还是有幻读风险。</td></tr><tr><td align="left">SERLALIZABLE</td><td align="left">串行化，最高的事务隔离级别，不管多少事务，挨个运行完一个事务的所有子事务之后才可以执行另外一个事务里面的所有子事务，这样就解决了脏读、不可重复读和幻读的问题了</td></tr></tbody></table><p><img src="https://img-blog.csdnimg.cn/20190703000608167.png" alt="在这里插入图片描述"></p><p>&emsp;&emsp;再必须强调一遍，不是事务隔离级别设置得越高越好，事务隔离级别设置得越高，意味着势必要花手段去加锁用以保证事务的正确性，那么效率就要降低，因此实际开发中往往要在效率和并发正确性之间做一个取舍，一般情况下会设置为READ_COMMITED，此时避免了脏读，并发性也还不错，之后再通过一些别的手段去解决不可重复读和幻读的问题就好了。</p><h1 id="9-事务的传播行为"><a href="#9-事务的传播行为" class="headerlink" title="9.事务的传播行为"></a>9.事务的传播行为</h1><p>保证事务：ACID</p><p>事务的传播行为针对的是嵌套的关系</p><p>Spring中的7个事务传播行为:</p><table><thead><tr><th align="left">事务行为</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">PROPAGATION_REQUIRED</td><td align="left">支持当前事务，假设当前没有事务。就新建一个事务</td></tr><tr><td align="left">PROPAGATION_SUPPORTS</td><td align="left">支持当前事务，假设当前没有事务，就以非事务方式运行</td></tr><tr><td align="left">PROPAGATION_MANDATORY</td><td align="left">支持当前事务，假设当前没有事务，就抛出异常</td></tr><tr><td align="left">PROPAGATION_REQUIRES_NEW</td><td align="left">新建事务，假设当前存在事务。把当前事务挂起</td></tr><tr><td align="left">PROPAGATION_NOT_SUPPORTED</td><td align="left">以非事务方式运行操作。假设当前存在事务，就把当前事务挂起</td></tr><tr><td align="left">PROPAGATION_NEVER</td><td align="left">以非事务方式运行，假设当前存在事务，则抛出异常</td></tr><tr><td align="left">PROPAGATION_NESTED</td><td align="left">如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。</td></tr></tbody></table><p><strong>举例说明</strong></p><p><strong>案例代码</strong></p><p>ServiceA</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">ServiceA &#123;   <br>     <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span> &#123;<br>         ServiceB.methodB();<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>ServiceB</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">ServiceB &#123; <br>     <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodB</span><span class="hljs-params">()</span> &#123;<br>     &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-PROPAGATION-REQUIRED"><a href="#1-PROPAGATION-REQUIRED" class="headerlink" title="1.PROPAGATION_REQUIRED"></a>1.PROPAGATION_REQUIRED</h3><p>&emsp;&emsp;假如当前正要运行的事务不在另外一个事务里，那么就起一个新的事务 比方说，ServiceB.methodB的事务级别定义PROPAGATION_REQUIRED, 那么因为执行ServiceA.methodA的时候，ServiceA.methodA已经起了事务。这时调用ServiceB.methodB，ServiceB.methodB看到自己已经执行在ServiceA.methodA的事务内部。就不再起新的事务。而假如ServiceA.methodA执行的时候发现自己没有在事务中，他就会为自己分配一个事务。这样，在ServiceA.methodA或者在ServiceB.methodB内的不论什么地方出现异常。事务都会被回滚。即使ServiceB.methodB的事务已经被提交，可是ServiceA.methodA在接下来fail要回滚，ServiceB.methodB也要回滚<br><img src="https://img-blog.csdnimg.cn/20190223225404935.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="2-PROPAGATION-SUPPORTS"><a href="#2-PROPAGATION-SUPPORTS" class="headerlink" title="2.PROPAGATION_SUPPORTS"></a>2.PROPAGATION_SUPPORTS</h3><p>&emsp;&emsp;假设当前在事务中。即以事务的形式执行。假设当前不在一个事务中，那么就以非事务的形式执行</p><h3 id="3PROPAGATION-MANDATORY"><a href="#3PROPAGATION-MANDATORY" class="headerlink" title="3PROPAGATION_MANDATORY"></a>3PROPAGATION_MANDATORY</h3><p>&emsp;&emsp;必须在一个事务中执行。也就是说，他仅仅能被一个父事务调用。否则，他就要抛出异常</p><h3 id="4-PROPAGATION-REQUIRES-NEW"><a href="#4-PROPAGATION-REQUIRES-NEW" class="headerlink" title="4.PROPAGATION_REQUIRES_NEW"></a>4.PROPAGATION_REQUIRES_NEW</h3><p>&emsp;&emsp;这个就比较绕口了。 比方我们设计ServiceA.methodA的事务级别为PROPAGATION_REQUIRED，ServiceB.methodB的事务级别为PROPAGATION_REQUIRES_NEW。那么当运行到ServiceB.methodB的时候，ServiceA.methodA所在的事务就会挂起。ServiceB.methodB会起一个新的事务。等待ServiceB.methodB的事务完毕以后，他才继续运行。<br>他与PROPAGATION_REQUIRED 的事务差别在于事务的回滚程度了。由于ServiceB.methodB是新起一个事务，那么就是存在两个不同的事务。假设ServiceB.methodB已经提交，那么ServiceA.methodA失败回滚。ServiceB.methodB是不会回滚的。假设ServiceB.methodB失败回滚，假设他抛出的异常被ServiceA.methodA捕获，ServiceA.methodA事务仍然可能提交。<br><img src="https://img-blog.csdnimg.cn/20190223230140433.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NTI2NTcz,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="5-PROPAGATION-NOT-SUPPORTED"><a href="#5-PROPAGATION-NOT-SUPPORTED" class="headerlink" title="5.PROPAGATION_NOT_SUPPORTED"></a>5.PROPAGATION_NOT_SUPPORTED</h3><p>&emsp;&emsp;当前不支持事务。比方ServiceA.methodA的事务级别是PROPAGATION_REQUIRED 。而ServiceB.methodB的事务级别是PROPAGATION_NOT_SUPPORTED ，那么当执行到ServiceB.methodB时。ServiceA.methodA的事务挂起。而他以非事务的状态执行完，再继续ServiceA.methodA的事务。</p><h3 id="6-PROPAGATION-NEVER"><a href="#6-PROPAGATION-NEVER" class="headerlink" title="6.PROPAGATION_NEVER"></a>6.PROPAGATION_NEVER</h3><p>&emsp;&emsp;不能在事务中执行。<br>如果ServiceA.methodA的事务级别是PROPAGATION_REQUIRED。 而ServiceB.methodB的事务级别是PROPAGATION_NEVER ，那么ServiceB.methodB就要抛出异常了。</p><h3 id="7-PROPAGATION-NESTED"><a href="#7-PROPAGATION-NESTED" class="headerlink" title="7.PROPAGATION_NESTED"></a>7.PROPAGATION_NESTED</h3><p>&emsp;&emsp;如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。</p><h1 id="10-Spring事务实现的方式"><a href="#10-Spring事务实现的方式" class="headerlink" title="10.Spring事务实现的方式"></a>10.Spring事务实现的方式</h1><p><strong>编程式事务管理</strong>：这意味着你可以通过编程的方式管理事务，这种方式带来了很大的灵活性，但很难维护。</p><p><strong>声明式事务管理</strong>：这种方式意味着你可以将事务管理和业务代码分离。你只需要通过注解或者XML配置管理事务。</p><h1 id="11-事务注解的本质是什么"><a href="#11-事务注解的本质是什么" class="headerlink" title="11.事务注解的本质是什么"></a>11.事务注解的本质是什么</h1><p>&emsp;&emsp;@Transactional 这个注解仅仅是一些（和事务相关的）元数据，在运行时被事务基础设施读取消费，并使用这些元数据来配置bean的事务行为。 大致来说具有两方面功能，一是表明该方法要参与事务，二是配置相关属性来定制事务的参与方式和运行行为</p><p>&emsp;&emsp;声明式事务主要是得益于Spring AOP。使用一个事务拦截器，在方法调用的前后&#x2F;周围进行事务性增强（advice），来驱动事务完成。</p><p>&emsp;&emsp;@Transactional注解既可以标注在类上，也可以标注在方法上。当在类上时，默认应用到类里的所有方法。如果此时方法上也标注了，则方法上的优先级高。 另外注意方法一定要是public的。</p><p><a href="https://cloud.fynote.com/share/d/IVeyV0Jp">https://cloud.fynote.com/share/d/IVeyV0Jp</a></p><h1 id="12-谈谈你对BeanFactory和ApplicationContext的理解"><a href="#12-谈谈你对BeanFactory和ApplicationContext的理解" class="headerlink" title="12.谈谈你对BeanFactory和ApplicationContext的理解"></a>12.谈谈你对BeanFactory和ApplicationContext的理解</h1><p>目的：考察对IoC的理解</p><p>BeanFactory:Bean工厂 &#x3D;&#x3D;》IoC容器</p><p>BeanDefinition &#x3D;&#x3D;&#x3D;》Bean定义</p><p>BeanDefinitionRegistry &#x3D;&#x3D;》 BeanDefinition 和 BeanFactory的关联</p><p>….</p><p>ApplicationContext:应用上下文</p><p>ApplicationContext ac &#x3D; new ClasspathXmlApplicationContext(xxx.xml);</p><h1 id="13-谈谈你对BeanFactoryPostProcessor的理解"><a href="#13-谈谈你对BeanFactoryPostProcessor的理解" class="headerlink" title="13.谈谈你对BeanFactoryPostProcessor的理解"></a>13.谈谈你对BeanFactoryPostProcessor的理解</h1><p>BeanFactoryPostProcessor:是在BeanFactory创建完成后的后置处理</p><p>BeanFactory：对外提供Bean对象</p><p>需要知道怎么提供Bean对象–&gt;BeanDefinition</p><p>XML&#x2F;注解 –》 BeanDefinition –》注册 –》完成BeanFactory的处理</p><p>1.需要交代BeanFactoryPostProcessor的作用</p><p>2.举个例子</p><p>@Configuration 注解 –》 Java被 @Configuration注解标识–&gt; 这是一个Java配置类</p><p>@Configuration–》@Component –&gt;BeanDefinition –&gt; 存储在BeanFactory中  是当做一个普通的Bean管理的</p><p>@Bean  @Primary 。。。。</p><p>ConfigurationClassPostProcessor</p><h1 id="14-谈谈你对BeanPostProcessor的理解"><a href="#14-谈谈你对BeanPostProcessor的理解" class="headerlink" title="14.谈谈你对BeanPostProcessor的理解"></a>14.谈谈你对BeanPostProcessor的理解</h1><p>针对Bean对象初始化前后。 针对Bean对象创建之后的处理操作。</p><p>SpringIoC 核心流程</p><p>BeanDefinition –&gt; 注册BeanDefinition –&gt;BeanFactory –》BeanFactory的后置处理 –&gt; 单例bean –&gt;  AOP  –》 代理对象 —&gt; advice pointcut join point 。。。</p><p>BeanPostProcessor 提供了一种扩展机制</p><p>自定义接口的实现 –》 <strong>注册</strong>到BeanFactory的 Map中</p><p>BeanDefinition –&gt; 注册BeanDefinition –&gt;BeanFactory –》BeanFactory的后置处理 –&gt; 单例bean –&gt;</p><p>遍历上面的Map 执行相关的行为 –&gt; 。。。。。</p><p>&#x3D;&#x3D;&#x3D;》 AOP</p><p>IoC 和AOP的关系</p><p>有了IoC 才有 AOP  DI</p><h1 id="15-谈谈你对SpringMVC的理解"><a href="#15-谈谈你对SpringMVC的理解" class="headerlink" title="15.谈谈你对SpringMVC的理解"></a>15.谈谈你对SpringMVC的理解</h1><p>控制框架：前端控制器–》Servlet –》Web容器【Tomcat】</p><p>SpringMVC和Spring的关系  IoC容器关系–》父子关系</p><p><a href="https://www.processon.com/view/link/63dc99aba7d181715d1f4569">https://www.processon.com/view/link/63dc99aba7d181715d1f4569</a></p><p>Spring和SpringMVC的关系理解</p><p>Spring和SpringMVC整合的项目中</p><p>Controller  Service Dao</p><p>具体的有两个容器Spring中的IoC容器。然后SpringMVC中也有一个IoC容器</p><p>Controller中定义的实例都是SpringMVC组件维护的</p><p>Service和Dao中的实例都是由Spring的IoC容器维护的</p><p>这两个容器有一个父子容器的关系</p><p>Spring容器是SpringMVC容器的父容器</p><h1 id="16-谈谈你对DelegatingFilterProxy的理解"><a href="#16-谈谈你对DelegatingFilterProxy的理解" class="headerlink" title="16.谈谈你对DelegatingFilterProxy的理解"></a>16.谈谈你对DelegatingFilterProxy的理解</h1><p>web.xml</p><p>Shiro SpringSecurity</p><p>Spring整合的第三方的组件会非常多</p><p>JWT  单独登录  OAuth2.0</p><p>组件：组合起来的零件–》组件  组合起来的技术栈–》组件框架</p><h1 id="17-谈谈你对SpringBoot的理解"><a href="#17-谈谈你对SpringBoot的理解" class="headerlink" title="17.谈谈你对SpringBoot的理解"></a>17.谈谈你对SpringBoot的理解</h1><p>约定由于配置</p><p>自动装配</p><p>SpringBoot和Spring的关系</p><p>SpringBoot的初始化 –&gt; IoC Spring的初始化</p><p>SpringBoot的启动 –&gt; IoC</p><p>@SpringApplication注解 –&gt; @Configuration –&gt;ConfigurationClassPostProcessor –》 @Import注解 –》 延迟加载 –》 自动装配 –&gt; SPI  去重 排除 过滤</p><p>spring.factories</p><p>SSM框架的整合</p><p>1。导入依赖</p><p>2。添加配置文件</p><p>3。设置配置文件 web.xml</p><h1 id="18-介绍下Import注解的理解"><a href="#18-介绍下Import注解的理解" class="headerlink" title="18.介绍下Import注解的理解"></a>18.介绍下Import注解的理解</h1><p>@Import注解是在Spring3.0的时候提供。目的是为了替换在XML配置文件中的import标签。</p><p>@Import注解除了可以导入第三方的Java配置类还扩展了其他的功能</p><ol><li>可以把某个类型的对象注入到容器中</li><li>导入的类型如果实现了ImportSelector接口。那么会调用接口中声明的方法。然后把方法返回的类型全类路径的类型对象注入到容器中</li><li>如果导入的类型实现了ImportBeanDefinitionRegistrar这个接口。那么就会调用声明的方法在该方法中显示的提供注册器来完成注入</li></ol><h1 id="19-SpringBoot自动装配中为什么用DeferredImportSelector"><a href="#19-SpringBoot自动装配中为什么用DeferredImportSelector" class="headerlink" title="19.SpringBoot自动装配中为什么用DeferredImportSelector"></a>19.SpringBoot自动装配中为什么用DeferredImportSelector</h1><p>在SpringBoot自动装配中核心是会加载所有依赖中的META-INF&#x2F;spring.factories文件中的配置信息。</p><p>我们可以有多个需要加载的spring.factories文件。那么我们就需要多次操作。我们可以考虑把所有的信息都加载后再统一把这些需要注入到容器中的内容注入进去</p><p>DeferredImportSelector：延迟注入Bean实例的作用</p><h1 id="20-SpringBoot中有了属性文件为什么还要加一个bootstrap-yml文件"><a href="#20-SpringBoot中有了属性文件为什么还要加一个bootstrap-yml文件" class="headerlink" title="20.SpringBoot中有了属性文件为什么还要加一个bootstrap.yml文件?"></a>20.SpringBoot中有了属性文件为什么还要加一个bootstrap.yml文件?</h1><p>&emsp;&emsp;在单体的SpringBoot项目中其实我们是用不到bootstrap.yml文件的，bootsrap.yml文件的使用需要SpringCloud的支持，因为在微服务环境下我们都是有配置中心的，来统一的管理系统的相关配置属性，那么怎么去加载配置中心的内容呢？一个SpringBoot项目启动的时候默认只会加载对应的application.yml中的相关信息，这时bootstrap.yml的作用就体现出来了，会在SpringBoot正常启动前创建一个父容器来通过bootstrap.yml中的配置来加载配置中心的内容。</p><h1 id="21-如果要对属性文件中的账号密码加密如何实现？"><a href="#21-如果要对属性文件中的账号密码加密如何实现？" class="headerlink" title="21.如果要对属性文件中的账号密码加密如何实现？"></a>21.如果要对属性文件中的账号密码加密如何实现？</h1><p>&emsp;&emsp;其实这是一个比较篇实战的一个问题，我们在application.yml中保存的MySQL数据库的账号密码或者其他服务的账号密码，都可以保存加密后的内容，那么我们在处理的时候要怎么解密呢？这个其实比较简单只需要对SpringBoot的执行流程清楚就可以了，第一个我们可以通过自定义监听器可以在加载解析了配置文件之后对加密的文件中做解密处理同时覆盖之前加密的内容，或者通过对应的后置处理器来处理，具体的实现如下：</p><p><img src="https://img-blog.csdnimg.cn/457ab5a2fd124ff988e10b2af6209811.png" alt="在这里插入图片描述"></p><p>然后我们通过案例代码来演示下，加深大家的理解<br>首先我们在属性文件中配置加密后的信息</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.datasource.driverClassName</span>=<span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br><span class="hljs-attr">spring.datasource.url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/mb?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true</span><br><span class="hljs-attr">spring.datasource.username</span>=<span class="hljs-string">root</span><br><span class="hljs-comment"># 对通过3DES对密码加密</span><br><span class="hljs-attr">spring.datasource.password</span>=<span class="hljs-string">t5Jd2CzFWEw=</span><br><br><span class="hljs-attr">spring.datasource.type</span>=<span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span><br><br><span class="hljs-attr">mybatis.mapper-locations</span>=<span class="hljs-string">classpath:mapper/*.xml</span><br></code></pre></td></tr></table></figure><p>&emsp;&emsp;在SpringBoot项目启动的时候在在刷新Spring容器之前执行的，所以我们要做的就是在加载完环境配置信息后，获取到配置的 <code>spring.datasource.password=t5Jd2CzFWEw=</code> 这个信息，然后解密并修改覆盖就可以了。<br><img src="https://img-blog.csdnimg.cn/56ead524284e4317b40700fa7170e7b9.png" alt="在这里插入图片描述">&emsp;&emsp;然后在属性文件的逻辑其实是通过发布事件触发对应的监听器来实现的<br><img src="https://img-blog.csdnimg.cn/795454a61a254cb388b86b308f0b89e3.png" alt="在这里插入图片描述"><br>&emsp;&emsp;所以第一个解决方案就是你自定义一个监听器，这个监听器在加载属性文件(ConfigFileApplicationListener)的监听器之后处理,这种方式稍微麻烦点，<br>&emsp;&emsp;还有一种方式就是通过加载属性文件的一个后置处理器来处理，这就以个为例来实现</p><p>3DES的工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 3DES加密算法，主要用于加密用户id，身份证号等敏感信息,防止破解</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DESedeUtil</span> &#123;<br><br>    <span class="hljs-comment">//秘钥</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span>  <span class="hljs-variable">KEY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;~@#$y1a2n.&amp;@+n@$%*(1)&quot;</span>;<br>    <span class="hljs-comment">//秘钥长度</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">secretKeyLength</span> <span class="hljs-operator">=</span> <span class="hljs-number">24</span>;<br>    <span class="hljs-comment">//加密算法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span>  <span class="hljs-variable">ALGORITHM</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;DESede&quot;</span>;<br>    <span class="hljs-comment">//编码</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">CHARSET</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;UTF-8&quot;</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 转换成十六进制字符串</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">byte</span>[] getHex(String key)&#123;<br>        <span class="hljs-type">byte</span>[] secretKeyByte = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">24</span>];<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">byte</span>[] hexByte;<br>            hexByte = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(DigestUtils.md5Hex(key)).getBytes(CHARSET);<br>            <span class="hljs-comment">//秘钥长度固定为24位</span><br>            System.arraycopy(hexByte,<span class="hljs-number">0</span>,secretKeyByte,<span class="hljs-number">0</span>,secretKeyLength);<br>        &#125; <span class="hljs-keyword">catch</span> (UnsupportedEncodingException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> secretKeyByte;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生成密钥，返回加密串</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key 密钥</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> encodeStr 将加密的字符串</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String  <span class="hljs-title function_">encode3DES</span><span class="hljs-params">(String key,String encodeStr)</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Cipher</span> <span class="hljs-variable">cipher</span> <span class="hljs-operator">=</span> Cipher.getInstance(ALGORITHM);<br>            cipher.init(Cipher.ENCRYPT_MODE, <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecretKeySpec</span>(getHex(key), ALGORITHM));<br>            <span class="hljs-keyword">return</span> Base64.encodeBase64String(cipher.doFinal(encodeStr.getBytes(CHARSET)));<br>        &#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生成密钥,解密，并返回字符串</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key 密钥</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> decodeStr 需要解密的字符串</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">decode3DES</span><span class="hljs-params">(String key, String decodeStr)</span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Cipher</span> <span class="hljs-variable">cipher</span> <span class="hljs-operator">=</span> Cipher.getInstance(ALGORITHM);<br>            cipher.init(Cipher.DECRYPT_MODE, <span class="hljs-keyword">new</span> <span class="hljs-title class_">SecretKeySpec</span>(getHex(key),ALGORITHM));<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(cipher.doFinal(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Base64</span>().decode(decodeStr)),CHARSET);<br>        &#125; <span class="hljs-keyword">catch</span>(Exception e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123456&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">encode</span> <span class="hljs-operator">=</span> DESedeUtil.encode3DES(KEY, userId);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">decode</span> <span class="hljs-operator">=</span> DESedeUtil.decode3DES(KEY, encode);<br>        System.out.println(<span class="hljs-string">&quot;用户id&gt;&gt;&gt;&quot;</span>+userId);<br>        System.out.println(<span class="hljs-string">&quot;用户id加密&gt;&gt;&gt;&quot;</span>+encode);<br>        System.out.println(<span class="hljs-string">&quot;用户id解密&gt;&gt;&gt;&quot;</span>+decode);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>声明后置处理器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SafetyEncryptProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">EnvironmentPostProcessor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postProcessEnvironment</span><span class="hljs-params">(ConfigurableEnvironment environment, SpringApplication application)</span> &#123;<br>        <span class="hljs-keyword">for</span> (PropertySource&lt;?&gt; propertySource : environment.getPropertySources()) &#123;<br>            System.out.println(<span class="hljs-string">&quot;propertySource = &quot;</span> + propertySource);<br>            <span class="hljs-keyword">if</span>(propertySource <span class="hljs-keyword">instanceof</span> OriginTrackedMapPropertySource)&#123;<br>                <span class="hljs-type">OriginTrackedMapPropertySource</span> <span class="hljs-variable">source</span> <span class="hljs-operator">=</span> (OriginTrackedMapPropertySource) propertySource;<br>                <span class="hljs-keyword">for</span> (String propertyName : source.getPropertyNames()) &#123;<br>                    <span class="hljs-comment">//System.out.println(propertyName + &quot;=&quot; + source.getProperty(propertyName));</span><br>                    <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;spring.datasource.password&quot;</span>.equals(propertyName))&#123;<br>                        Map&lt;String,Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>                        <span class="hljs-comment">// 做解密处理</span><br>                        <span class="hljs-type">String</span> <span class="hljs-variable">property</span> <span class="hljs-operator">=</span> (String) source.getProperty(propertyName);<br>                        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> DESedeUtil.decode3DES(DESedeUtil.KEY, property);<br>                        System.out.println(<span class="hljs-string">&quot;密文：&quot;</span> + property);<br>                        System.out.println(<span class="hljs-string">&quot;解密后的：&quot;</span> + s);<br>                        map.put(propertyName,s);<br><br>                        <span class="hljs-comment">// 注意要添加到前面，覆盖</span><br>                        environment.getPropertySources().addFirst(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MapPropertySource</span>(propertyName,map));<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在META-INF&#x2F;spring.factories文件中注册</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">org.springframework.boot.env.EnvironmentPostProcessor</span>=<span class="hljs-string">com.bobo.util.SafetyEncryptProcessor</span><br></code></pre></td></tr></table></figure><p>然后启动项目就可以了<br><img src="https://img-blog.csdnimg.cn/970447b8998445abb81d6b9b407bde6b.png" alt="在这里插入图片描述"></p><p>&emsp;&emsp;搞定</p><h1 id="22-谈谈Indexed注解的作用"><a href="#22-谈谈Indexed注解的作用" class="headerlink" title="22.谈谈Indexed注解的作用"></a>22.谈谈Indexed注解的作用</h1><p>@Indexed注解是Spring5.0提供</p><p>Indexed注解解决的问题：是随着项目越来越复杂那么@ComponentScan需要扫描加载的Class会越来越多。在系统启动的时候会造成性能损耗。所以Indexed注解的作用其实就是提升系统启动的性能。</p><p>在系统编译的时候那么会收集所有被@Indexed注解标识的Java类。然后记录在META-INF&#x2F;spring.components文件中。那么系统启动的时候就只需要读取一个该文件中的内容就不用在遍历所有的目录了。提升的效率</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1646114654000/bbb5205d8dec4316b38c08840aca7984.png" alt="image.png"></p><h1 id="23-Component-Controller-Repository-Service-有何区别？"><a href="#23-Component-Controller-Repository-Service-有何区别？" class="headerlink" title="23.@Component, @Controller, @Repository,@Service 有何区别？"></a>23.@Component, @Controller, @Repository,@Service 有何区别？</h1><p>@Component ：这将 java 类标记为 bean。它是任何 Spring 管理组件的通用构造型。spring 的组件扫描机制现在可以将其拾取并将其拉入应用程序环境中。</p><p>@Controller ：这将一个类标记为 Spring Web MVC 控制器。标有它的Bean 会自动导入到 IoC 容器中。</p><p>@Service ：此注解是组件注解的特化。它不会对 @Component 注解提供任何其他行为。您可以在服务层类中使用@Service 而不是 @Component，因为它以更好的方式指定了意图。</p><p>@Repository ：这个注解是具有类似用途和功能的 @Component 注解的特化。它为 DAO 提供了额外的好处。它将 DAO 导入 IoC 容器，并使未经检查的异常有资格转换为 Spring DataAccessException。</p><h1 id="24-有哪些通知类型-Advice"><a href="#24-有哪些通知类型-Advice" class="headerlink" title="24.有哪些通知类型(Advice)"></a>24.有哪些通知类型(Advice)</h1><p>前置通知：Before - 这些类型的 Advice 在 joinpoint 方法之前执行，并使用@Before 注解标记进行配置。<br>后置通知：After Returning - 这些类型的 Advice 在连接点方法正常执行后执行，并使用@AfterReturning 注解标记进行配置。<br>异常通知：After Throwing - 这些类型的 Advice 仅在 joinpoint 方法通过抛出异常退出并使用 @AfterThrowing 注解标记配置时执行。<br>最终通知：After (finally) - 这些类型的 Advice 在连接点方法之后执行，无论方法退出是正常还是异常返回，并使用 @After 注解标记进行配置。<br>环绕通知：Around - 这些类型的 Advice 在连接点之前和之后执行，并使用@Around 注解标记进行配置。</p><h1 id="25-什么是-Spring-的依赖注入？"><a href="#25-什么是-Spring-的依赖注入？" class="headerlink" title="25.什么是 Spring 的依赖注入？"></a>25.什么是 Spring 的依赖注入？</h1><p>依赖注入，是 IOC 的一个方面，是个通常的概念，它有多种解释。这概念是说你不用创建对象，而只需要描述它如何被创建。你不在代码里直接组装你的组件和服务，但是要在配置文件里描述哪些组件需要哪些服务，之后一个容器（IOC 容器）负责把他们组装起来。</p><p>BeanFactory</p><p>BeanDefinition</p><p>BeanDefinitionRegistry</p><p>ApplicationContext</p><p>–》 DI</p><p>–》 AOP</p><p>–》事务。日志</p><h1 id="26-Spring-框架中的单例-bean-是线程安全的吗"><a href="#26-Spring-框架中的单例-bean-是线程安全的吗" class="headerlink" title="26.Spring 框架中的单例 bean 是线程安全的吗?"></a>26.Spring 框架中的单例 bean 是线程安全的吗?</h1><p>不，Spring 框架中的单例 bean 不是线程安全的。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/04/08/java%E5%9F%BA%E7%A1%80%E9%9D%A2%E7%BB%8F/02-Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2024/04/08/java%E5%9F%BA%E7%A1%80%E9%9D%A2%E7%BB%8F/02-Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="Java基础面试题"><a href="#Java基础面试题" class="headerlink" title="Java基础面试题"></a>Java基础面试题</h1><blockquote><p>讲师：邓澎波</p></blockquote><h1 id="一、IO和多线程专题"><a href="#一、IO和多线程专题" class="headerlink" title="一、IO和多线程专题"></a>一、IO和多线程专题</h1><h2 id="1-介绍下进程和线程的关系"><a href="#1-介绍下进程和线程的关系" class="headerlink" title="1.介绍下进程和线程的关系"></a>1.介绍下进程和线程的关系</h2><p><strong>进程</strong>：一个独立的正在执行的程序</p><p><strong>线程</strong>：一个进程的最基本的执行单位，执行路径</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1675489410098/9e9ec3ca030d4c229a7f76ce5fdf650d.png" alt="image.png"></p><p><strong>多进程</strong>：在操作系统中，同时运行多个程序</p><p>多进程的好处：可以充分利用CPU，提高CPU的使用率</p><p><strong>多线程：在同一个进程(应用程序)中同时执行多个线程</strong></p><p>多线程的好处：提高进程的执行使用率，提高了CPU的使用率</p><p><strong>注意：</strong></p><ol><li>在同一个时间点一个CPU中只可能有一个线程在执行</li><li>多线程不能提高效率、反而会降低效率，但是可以提高CPU的使用率</li><li>一个进程如果有多条执行路径，则称为多线程程序</li><li>Java虚拟机的启动至少开启了两条线程，主线程和垃圾回收线程</li><li>一个线程可以理解为进程的子任务</li></ol><h2 id="2-说说Java中实现多线程的几种方法"><a href="#2-说说Java中实现多线程的几种方法" class="headerlink" title="2.说说Java中实现多线程的几种方法"></a>2.说说Java中实现多线程的几种方法</h2><p>Thread对象就是一个线程</p><p>创建线程的常用三种方式：</p><ol><li>继承Thread类</li><li>实现Runnable接口</li><li>实现Callable接口（JDK1.5&gt;&#x3D;）</li><li>线程池方式创建</li></ol><p>&emsp;&emsp;通过继承Thread类或者实现Runnable接口、Callable接口都可以实现多线程，不过实现Runnable<br>接口与实现Callable接口的方式基本相同，只是Callable接口里定义的方法返回值，可以声明抛出异<br>常而已。因此将实现Runnable接口和实现Callable接口归为一种方式。这种方式与继承Thread方式<br>之间的主要差别如下。</p><p><strong>继承Thread类</strong></p><p>实现的步骤：</p><ol><li>创建Thread类的子类</li><li>重写run方法</li><li>创建线程对象</li><li>启动线程</li></ol><p>案例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.thread;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadDemo02</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 线程的第一种实现方式</span><br><span class="hljs-comment">     *     通过创建Thread类的子类来实现</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> args</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;main方法执行了1...&quot;</span>);<br>        <span class="hljs-comment">// Java中的线程 本质上就是一个Thread对象</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadTest01</span>();<br>        <span class="hljs-comment">// 启动一个新的线程</span><br>        t1.start();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i&lt; <span class="hljs-number">100</span> ; i++)&#123;<br>            System.out.println(<span class="hljs-string">&quot;main方法的循环...&quot;</span>+i);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;main方法执行结束了3...&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 第一个自定义的线程类</span><br><span class="hljs-comment"> *    继承Thread父类</span><br><span class="hljs-comment"> *    重写run方法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadTest01</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我们的第一个线程执行了2....&quot;</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">10</span> ; i ++)&#123;<br>            System.out.println(<span class="hljs-string">&quot;子线程：&quot;</span>+i);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>注意点：</strong></p><ol><li>启动线程是使用start方法而不是run方法</li><li>线程不能启动多次，如果要创建多个线程，那么就需要创建多个Thread对象</li></ol><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1675489410098/f67f195218b34242a452df52c27a8db0.png" alt="image.png"></p><p><strong>实现Runnable接口</strong></p><p>&emsp;&emsp;在第一种实现方式中，我们是将线程的创建和线程执行的业务都封装在了Thread对象中，我们可以通过Runable接口来实现线程程序代码和数据有效的分离。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread(Runnable target)<br><span class="hljs-comment">// 分配一个新的 Thread对象。</span><br></code></pre></td></tr></table></figure><p>实现的步骤：</p><ol><li>创建Runable的实现类</li><li>重写run方法</li><li>创建Runable实例对象(通过实现类来实现)</li><li>创建Thread对象，并把第三部的Runable实现作为Thread构造方法的参数</li><li>启动线程</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.runable;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RunableDemo01</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 线程的第二种方式</span><br><span class="hljs-comment">     *     本质是创建Thread对象的时候传递了一个Runable接口实现</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> args</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;main执行了...&quot;</span>);<br>        <span class="hljs-comment">// 创建一个新的线程  Thread对象</span><br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">r1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RunableTest</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r1);<br>        <span class="hljs-comment">// 启动线程</span><br>        t1.start();<br>        System.out.println(<span class="hljs-string">&quot;main结束了...&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 线程的第二种创建方式</span><br><span class="hljs-comment"> *   创建一个Runable接口的实现类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RunableTest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;子线程执行了...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现Runable接口的好处：</p><ol><li>可以避免Java单继承带来的局限性</li><li>适合多个相同的程序代码处理同一个资源的情况，把线程同程序的代码和数据有效的分离，较好的体现了面向对象的设计思想</li></ol><p><strong>Callable的方式</strong></p><p>&emsp;&emsp;前面我们介绍的两种创建线程的方式都是重写run方法，而且run方法是没有返回结果的，也就是main方法是不知道开启的线程什么时候开始执行，什么时候结束执行，也获取不到对应的返回结果。而且run方法也不能把可能产生的异常抛出。在JDK1.5之后推出了通过实现Callable接口的方式来创建新的线程，这种方式可以获取对应的返回结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.callable;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.Callable;<br><span class="hljs-keyword">import</span> java.util.concurrent.FutureTask;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CallableDemo01</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建线程的第三种实现方式：</span><br><span class="hljs-comment">     *    Callable方式</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span>  Exception &#123;<br>        <span class="hljs-comment">// 创建一个Callable实例</span><br>        Callable&lt;Integer&gt; callable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>();<br>        FutureTask&lt;Integer&gt; futureTask = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(callable);<br>        <span class="hljs-comment">// 获取一个线程 肯定是要先创建一个Thread对象  futureTask本质上是Runable接口的实现</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(futureTask);<br>        System.out.println(<span class="hljs-string">&quot;main方法start....&quot;</span>);<br>        t1.start(); <span class="hljs-comment">// 本质还是执行的 Runable中的run方法，只是 run方法调用了call方法罢了</span><br>        <span class="hljs-comment">// 获取返回的结果</span><br>        System.out.println(futureTask.get()); <span class="hljs-comment">// 获取开启的线程执行完成后返回的结果</span><br>        System.out.println(<span class="hljs-string">&quot;main方法end ....&quot;</span>);<br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 创建Callable的实现类</span><br><span class="hljs-comment"> *    我们需要指定Callable的泛型，这个泛型是返回结果的类型</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;Integer&gt;&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 线程自动后会执行的方法</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> ; i &lt;= <span class="hljs-number">100</span> ; i ++)&#123;<br>            sum += i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>实现Runnable接口和实现Callable接口的区别:</p><ol><li>Runnable是自从java1.1就有了，而Callable是1.5之后才加上去的</li><li>Callable规定的方法是call(),Runnable规定的方法是run()</li><li>Callable的任务执行后可返回值，而Runnable的任务是不能返回值(是void)</li><li>call方法可以抛出异常，run方法不可以</li><li>运行Callable任务可以拿到一个Future对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。</li><li>加入线程池运行，Runnable使用ExecutorService的execute方法，Callable使用submit方法。</li></ol><p>其实Callable接口底层的实现就是对Runable接口实现的封装，线程启动执行的也是Runable接口实现中的run方法，只是在run方法中有调用call方法罢了</p><h2 id="3-如何停止一个正在运行的线程"><a href="#3-如何停止一个正在运行的线程" class="headerlink" title="3.如何停止一个正在运行的线程"></a>3.如何停止一个正在运行的线程</h2><p><strong>设置标志位</strong>：如果线程的run方法中执行的是一个重复执行的循环，可以提供一个标记来控制循环是否继续</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FunDemo02</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 练习2：设计一个线程：运行10秒后被终止(掌握线程的终止方法)</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> args</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>  <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">MyRunable02</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunable02</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(runnable).start();<br>        Thread.sleep(<span class="hljs-number">10000</span>); <span class="hljs-comment">// 主线程休眠10秒钟</span><br>        runnable.flag = <span class="hljs-literal">false</span>;<br>        System.out.println(<span class="hljs-string">&quot;main、  end ...&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunable02</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span>(flag)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>                System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 执行完成&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>利用中断标志位</strong>： 在线程中有个中断的标志位，默认是false，当我们显示的调用 interrupted方法或者isInterrupted方法是会修改标志位为true。我们可以利用此来中断运行的线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.fundemo;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FunDemo07</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FunDemo07</span>();<br>        t1.start();<br>        Thread.sleep(<span class="hljs-number">3000</span>);<br>         t1.interrupt(); <span class="hljs-comment">// 中断线程 将中断标志由false修改为了true</span><br>        <span class="hljs-comment">// t1.stop(); // 直接就把线程给kill掉了</span><br>        System.out.println(<span class="hljs-string">&quot;main .... &quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-built_in">this</span>.getName() + <span class="hljs-string">&quot; start...&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ;<br>        <span class="hljs-comment">// Thread.interrupted() 如果没有被中断 那么是false 如果显示的执行了interrupt 方法就会修改为 true</span><br>        <span class="hljs-keyword">while</span>(!Thread.interrupted())&#123;<br>            System.out.println(<span class="hljs-built_in">this</span>.getName() + <span class="hljs-string">&quot; &quot;</span> + i);<br>            i++;<br>        &#125;<br><br>        System.out.println(<span class="hljs-built_in">this</span>.getName()+ <span class="hljs-string">&quot; end .... &quot;</span>);<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>利用InterruptedException：</strong> 如果线程因为执行join(),sleep()或者wait()而进入阻塞状态，此时要想停止它，可以让他调用interrupt(),程序会抛出InterruptedException异常。我们利用这个异常可以来终止线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FunDemo08</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FunDemo08</span>();<br>        t1.start();<br>        Thread.sleep(<span class="hljs-number">3000</span>);<br>         t1.interrupt(); <span class="hljs-comment">// 中断线程 将中断标志由false修改为了true</span><br>        <span class="hljs-comment">// t1.stop(); // 直接就把线程给kill掉了</span><br>        System.out.println(<span class="hljs-string">&quot;main .... &quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-built_in">this</span>.getName() + <span class="hljs-string">&quot; start...&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ;<br>        <span class="hljs-comment">// Thread.interrupted() 如果没有被中断 那么是false 如果显示的执行了interrupt 方法就会修改为 true</span><br>         <span class="hljs-keyword">while</span>(!Thread.interrupted())&#123;<br>        <span class="hljs-comment">//while(!Thread.currentThread().isInterrupted())&#123;</span><br>             <span class="hljs-keyword">try</span> &#123;<br>                 Thread.sleep(<span class="hljs-number">10000</span>);<br>             &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                 e.printStackTrace();<br> <span class="hljs-keyword">break</span>;<br>             &#125;<br>             System.out.println(<span class="hljs-built_in">this</span>.getName() + <span class="hljs-string">&quot; &quot;</span> + i);<br>            i++;<br>        &#125;<br><br>        System.out.println(<span class="hljs-built_in">this</span>.getName()+ <span class="hljs-string">&quot; end .... &quot;</span>);<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="4-介绍下线程中的常用方法"><a href="#4-介绍下线程中的常用方法" class="headerlink" title="4.介绍下线程中的常用方法"></a>4.介绍下线程中的常用方法</h2><h3 id="1-start方法"><a href="#1-start方法" class="headerlink" title="1.start方法"></a>1.start方法</h3><p>start方法是我们开启一个新的线程的方法，但是并不是直接开启，而是告诉CPU我已经准备好了，快点运行我，这是启动一个线程的唯一入口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span><span class="hljs-title function_">start</span><span class="hljs-params">()</span><br><span class="hljs-comment">// 导致此线程开始执行; Java虚拟机调用此线程的run方法。</span><br></code></pre></td></tr></table></figure><h3 id="2-run方法"><a href="#2-run方法" class="headerlink" title="2.run方法"></a>2.run方法</h3><p>线程的线程体，当一个线程开始运行后，执行的就是run方法里面的代码，我们不能直接通过线程对象来调用run方法。因为这并没有产生一个新的线程。仅仅只是一个普通对象的方法调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span><span class="hljs-title function_">run</span><span class="hljs-params">()</span><br><span class="hljs-comment">// 如果这个线程使用单独的Runnable运行对象构造，则调用该Runnable对象的run方法; 否则，此方法不执行任何操作并返回。</span><br></code></pre></td></tr></table></figure><h3 id="3-getName方法"><a href="#3-getName方法" class="headerlink" title="3.getName方法"></a>3.getName方法</h3><p>获取线程名称的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">String<span class="hljs-title function_">getName</span><span class="hljs-params">()</span><br>返回此线程的名称。<br></code></pre></td></tr></table></figure><h3 id="4-优先级"><a href="#4-优先级" class="headerlink" title="4.优先级"></a>4.优先级</h3><p>我们创建的多个线程的执行顺序是由CPU决定的。Java中提供了一个线程调度器来监控程序中启动后进入就绪状态的所有的线程，优先级高的线程会获取到比较多</p><p><strong>运行机会</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 最小的优先级是 1</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">MIN_PRIORITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 默认的优先级都是5</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">NORM_PRIORITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br><br> <span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 最大的优先级是10</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_PRIORITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>大家会发现，设置了优先级后输出的结果和我们预期的并不一样，这是为什么呢？优先级在CPU调动线程执行的时候会是一个参考因数，但不是决定因数，</p><h3 id="5-sleep方法"><a href="#5-sleep方法" class="headerlink" title="5.sleep方法"></a>5.sleep方法</h3><p>将当前线程暂定指定的时间，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span><span class="hljs-title function_">sleep</span><span class="hljs-params">(<span class="hljs-type">long</span> millis)</span><br><span class="hljs-comment">// 使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行），具体取决于系统定时器和调度程序的精度和准确性。</span><br></code></pre></td></tr></table></figure><h3 id="6-isAlive"><a href="#6-isAlive" class="headerlink" title="6.isAlive"></a>6.isAlive</h3><p>获取线程的状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.fundemo;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FunDemo04</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * isAlive方法</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> args</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        System.out.println(<span class="hljs-string">&quot;main  start ...&quot;</span>);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; .... &quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">100</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;);<br>        System.out.println(<span class="hljs-string">&quot;线程的状态：&quot;</span>+t1.isAlive());<br>        t1.start();<br>        System.out.println(<span class="hljs-string">&quot;线程的状态：&quot;</span>+t1.isAlive());<br>        System.out.println(<span class="hljs-string">&quot;main  end ...&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs txt">main  start ...<br>线程的状态：false<br>线程的状态：true<br>main  end ...<br>Thread-0 .... <br></code></pre></td></tr></table></figure><h3 id="7-join"><a href="#7-join" class="headerlink" title="7.join"></a>7.join</h3><p>调用某线程的该方法，将当前线程和该线程合并，即等待该线程结束，在恢复当前线程的运行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.fundemo;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FunDemo05</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 线程的合并</span><br><span class="hljs-comment">     *     join方法</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> args</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;main  start ...&quot;</span>);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">10</span>; i++)&#123;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 子线程执行了...&quot;</span>);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(<span class="hljs-number">100</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br><br>            &#125;<br>        &#125;);<br>        t1.start();<br>        <span class="hljs-keyword">try</span> &#123;<br>            t1.join(); <span class="hljs-comment">// 线程的合并，和主线程合并  相当于我们直接调用了run方法</span><br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;main end ...&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs txt">main  start ...<br>Thread-0 子线程执行了...<br>Thread-0 子线程执行了...<br>Thread-0 子线程执行了...<br>Thread-0 子线程执行了...<br>Thread-0 子线程执行了...<br>Thread-0 子线程执行了...<br>Thread-0 子线程执行了...<br>Thread-0 子线程执行了...<br>Thread-0 子线程执行了...<br>Thread-0 子线程执行了...<br>main end ...<br><br></code></pre></td></tr></table></figure><h3 id="8-yield"><a href="#8-yield" class="headerlink" title="8.yield"></a>8.yield</h3><p>让出CPU，当前线程进入就绪状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.fundemo;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FuneDemo06</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">FuneDemo06</span><span class="hljs-params">(String threadName)</span>&#123;<br>        <span class="hljs-built_in">super</span>(threadName);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * yield方法  礼让</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> args</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">FuneDemo06</span> <span class="hljs-variable">f1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FuneDemo06</span>(<span class="hljs-string">&quot;A1&quot;</span>);<br>        <span class="hljs-type">FuneDemo06</span> <span class="hljs-variable">f2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FuneDemo06</span>(<span class="hljs-string">&quot;A2&quot;</span>);<br>        <span class="hljs-type">FuneDemo06</span> <span class="hljs-variable">f3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FuneDemo06</span>(<span class="hljs-string">&quot;A3&quot;</span>);<br><br>        f1.start();<br>        f2.start();<br>        f3.start();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">100</span>; i ++)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">10</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(i%<span class="hljs-number">10</span> == <span class="hljs-number">0</span> &amp;&amp; i != <span class="hljs-number">0</span>)&#123;<br>                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; 礼让：&quot;</span> + i);<br>                Thread.currentThread().<span class="hljs-keyword">yield</span>(); <span class="hljs-comment">// 让出CPU</span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                System.out.println(<span class="hljs-built_in">this</span>.getName() + <span class="hljs-string">&quot;:&quot;</span> + i);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="9-wait和notify-notifyAll"><a href="#9-wait和notify-notifyAll" class="headerlink" title="9.wait和notify&#x2F;notifyAll"></a>9.wait和notify&#x2F;notifyAll</h3><p>阻塞和唤醒的方法，是Object中的方法，我们在数据同步的时候会介绍到</p><h2 id="5-介绍下线程的生命周期"><a href="#5-介绍下线程的生命周期" class="headerlink" title="5.介绍下线程的生命周期"></a>5.介绍下线程的生命周期</h2><p>生命周期：对象从创建到销毁的全过程</p><p>线程的生命周期：线程对象(Thread)从开始到销毁的全过程</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1675489410098/1980f488416e4f27873341478f928eda.png" alt="image.png"></p><p><strong>线程的状态：</strong></p><ol><li>创建  Thread对象</li><li>就绪状态  执行start方法后线程进入可运行的状态</li><li>运行状态 CPU运行</li><li>阻塞状态  运行过程中被中断(等待阻塞，对象锁阻塞，其他阻塞)</li><li>终止状态  线程执行完成</li></ol><h2 id="6-为什么wait-notify和notifyAll这些方法不在thread类里面？"><a href="#6-为什么wait-notify和notifyAll这些方法不在thread类里面？" class="headerlink" title="6.为什么wait, notify和notifyAll这些方法不在thread类里面？"></a>6.为什么wait, notify和notifyAll这些方法不在thread类里面？</h2><p>&emsp;&emsp;明显的原因是JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。如果wait()方法定义在Thread类中，线程正在等待的是哪个锁就不明显了。简单的说，由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象。</p><h2 id="7-为什么wait和notify方法要在同步块中调用？"><a href="#7-为什么wait和notify方法要在同步块中调用？" class="headerlink" title="7.为什么wait和notify方法要在同步块中调用？"></a>7.为什么wait和notify方法要在同步块中调用？</h2><p>1.只有在调用线程拥有某个对象的独占锁时，才能够调用该对象的wait(),notify()和notifyAll()方法。<br>2.如果你不这么做，你的代码会抛出IllegalMonitorStateException异常。<br>3.还有一个原因是为了避免wait和notify之间产生竞态条件。<br>&emsp;&emsp;wait()<strong>方法强制当前线程释放对象锁。这意味着在调用某对象的wait()方法之前，当前线程必须已经获得该对象的锁。因此，线程必须在某个对象的同步方法或同步代码块中才能调用该对象的wait()方法。<br>&emsp;&emsp;在调用对象的</strong>notify()<strong>和</strong>notifyAll()方法之前，调用线程必须已经得到该对象的锁。因此，必须在某个对象的同步方法或同步代码块中才能调用该对象的notify()或notifyAll()方法。<br>&emsp;&emsp;调用wait()方法的原因通常是，调用线程希望某个特殊的状态(或变量)被设置之后再继续执行。调用notify() 或notifyAll()方法的原因通常是，调用线程希望告诉其他等待中的线程:”特殊状态已经被设置”。这个状态作为线程间通信的通道，它必须是一个可变的共享状态(或变量)。</p><h2 id="8-synchronized和ReentrantLock的区别"><a href="#8-synchronized和ReentrantLock的区别" class="headerlink" title="8.synchronized和ReentrantLock的区别"></a>8.synchronized和ReentrantLock的区别</h2><p><strong>相似点</strong>：<br>&emsp;&emsp;这两种同步方式有很多相似之处，它们都是加锁方式同步，而且都是阻塞式的同步，也就是说当如果一个线程获得了对象锁，进入了同步块，其他访问该同步块的线程都必须阻塞在同步块外面等待，而进行线程阻塞和唤醒的代价是比较高的.<br><strong>区别</strong>：<br>&emsp;&emsp;这两种方式最大区别就是对于Synchronized来说，它是java语言的关键字，是原生语法层面的互斥，需要jvm实现。而ReentrantLock它是JDK 1.5之后提供的API层面的互斥锁，需要lock()和unlock()方法配合try&#x2F;finally语句块来完成。</p><p>&emsp;&emsp;Synchronized进过编译，会在同步块的前后分别形成<strong>monitorenter</strong>和<strong>monitorexit</strong>这个两个字节码指令。在执行<strong>monitorenter</strong>指令时，首先要尝试获取对象锁。如果这个对象没被锁定，或者当前线程已经拥有了那个对象锁，把锁的计算器加1，相应的，在执行monitorexit指令时会将锁计算器就减1，当计算器为0时，锁就被释放了。如果获取对象锁失败，那当前线程就要阻塞，直到对象锁被另一个线程释放为止。</p><p>由于ReentrantLock是java.util.concurrent包下提供的一套互斥锁，相比Synchronized，ReentrantLock类提供了一些高级功能，主要有以下3项：</p><p>1.等待可中断，持有锁的线程长期不释放的时候，正在等待的线程可以选择放弃等待，这相当于Synchronized来说可以避免出现死锁的情况。</p><p>2.公平锁，多个线程等待同一个锁时，必须按照申请锁的时间顺序获得锁，Synchronized锁非公平锁，ReentrantLock默认的构造函数是创建的非公平锁，可以通过参数true设为公平锁，但公平锁表现的性能不是很好。</p><p>3.锁绑定多个条件，一个ReentrantLock对象可以同时绑定对个对象</p><h2 id="9-什么是线程安全"><a href="#9-什么是线程安全" class="headerlink" title="9.什么是线程安全"></a>9.什么是线程安全</h2><p>&emsp;&emsp;线程安全就是说多线程访问同一段代码，不会产生不确定的结果。<br>&emsp;&emsp;如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的。这个问题有值得一提的地方，就是线程安全也是有几个级别的：<br>（1）不可变<br>&emsp;&emsp;像String、Integer、Long这些，都是final类型的类，任何一个线程都改变不了它们的值，要改变除非新创建一个，因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用<br>（2）绝对线程安全<br>&emsp;&emsp;不管运行时环境如何，调用者都不需要额外的同步措施。要做到这一点通常需要付出许多额外的代价，Java中标注自己是线程安全的类，实际上绝大多数都不是线程安全的，不过绝对线程安全的类，Java中也有，比方说CopyOnWriteArrayList、CopyOnWriteArraySet<br>（3）相对线程安全<br>&emsp;&emsp;相对线程安全也就是我们通常意义上所说的线程安全，像Vector这种，add、remove方法都是原子操作，不会被打断，但也仅限于此，如果有个线程在遍历某个Vector、有个线程同时在add这个Vector，99%的情况下都会出现ConcurrentModificationException，也就是fail-fast机制。<br>（4）线程非安全<br>&emsp;&emsp;这个就没什么好说的了，ArrayList、LinkedList、HashMap等都是线程非安全的类</p><h2 id="10-Thread类中yield方法的作用"><a href="#10-Thread类中yield方法的作用" class="headerlink" title="10.Thread类中yield方法的作用"></a>10.Thread类中yield方法的作用</h2><p>&emsp;&emsp;yield方法可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执行。它是一个静态方法而且只保证当前线程放弃CPU占用而不能保证使其它线程一定能占用CPU，执行yield()的线程有可能在进入到暂停状态后马上又被执行。</p><h2 id="11-常用的线程池有哪些"><a href="#11-常用的线程池有哪些" class="headerlink" title="11.常用的线程池有哪些"></a>11.常用的线程池有哪些</h2><p><strong>new SingleThreadExecutor</strong>：创建一个单线程的线程池，此线程池保证所有任务的执行顺序按照任务的提交顺序执行。<br><strong>new FixedThreadPool</strong>：创建固定大小的线程池，每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。<br><strong>new CachedThreadPool</strong>：创建一个可缓存的线程池，此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。<br><strong>new ScheduledThreadPool</strong>：创建一个大小无限的线程池，此线程池支持定时以及周期性执行任务的求。</p><h2 id="12-简述一下你对线程池的理解"><a href="#12-简述一下你对线程池的理解" class="headerlink" title="12. 简述一下你对线程池的理解"></a>12. 简述一下你对线程池的理解</h2><p>如果问到了这样的问题，可以展开的说一下线程池如何用、线程池的好处、线程池的启动策略<br>合理利用线程池能够带来三个好处。<br>第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</p><p>第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。<br>第三：提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                               <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">                               <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">                               TimeUnit unit,</span><br><span class="hljs-params">                               BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="hljs-params">                               RejectedExecutionHandler handler)</span> <br><br></code></pre></td></tr></table></figure><p>参数含义：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs txt">corePoolSize：线程池核心线程数量<br>maximumPoolSize:线程池最大线程数量<br>keepAliverTime：当活跃线程数大于核心线程数时，空闲的多余线程最大存活时间<br>unit：存活时间的单位<br>workQueue：存放任务的队列<br>handler：超出线程范围和队列容量的任务的处理程序<br></code></pre></td></tr></table></figure><p>线程池工作原理：</p><p>提交一个任务到线程池中，线程池的处理流程如下：</p><ol><li>判断线程池里的核心线程是否都在执行任务，如果不是（核心线程空闲或者还有核心线程没有被创建）则创建一个新的工作线程来执行任务。如果核心线程都在执行任务，则进入下个流程。</li><li>线程池判断工作队列是否已满，如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。</li><li>判断线程池里的线程是否都处于工作状态，如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。</li></ol><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1675489410098/fc312a088d814b8ca72e855bca0d9cea.png" alt="image.png"></p><h2 id="13-线程池的拒绝策略有哪些"><a href="#13-线程池的拒绝策略有哪些" class="headerlink" title="13.线程池的拒绝策略有哪些?"></a>13.线程池的拒绝策略有哪些?</h2><p>主要有4种拒绝策略：</p><ol><li>AbortPolicy：直接丢弃任务，抛出异常，这是默认策略</li><li>CallerRunsPolicy：只用调用者所在的线程来处理任务</li><li>DiscardOldestPolicy：丢弃等待队列中最旧的任务，并执行当前任务</li><li>DiscardPolicy：直接丢弃任务，也不抛出异常</li></ol><h2 id="14-线程安全需要保证几个基本特性"><a href="#14-线程安全需要保证几个基本特性" class="headerlink" title="14.线程安全需要保证几个基本特性?"></a>14.线程安全需要保证几个基本特性?</h2><p><strong>原子性</strong>，简单说就是相关操作不会中途被其他线程干扰，一般通过同步机制实现。<br><strong>可见性</strong>，是一个线程修改了某个共享变量，其状态能够立即被其他线程知晓，通常被解释为将线程本地状态反映到主内存上，volatile就是负责保证可见性的。<br><strong>有序性</strong>，是保证线程内串行语义，避免指令重排等。</p><h2 id="15-说下线程间是如何通信的"><a href="#15-说下线程间是如何通信的" class="headerlink" title="15.说下线程间是如何通信的?"></a>15.说下线程间是如何通信的?</h2><p>线程之间的通信有两种方式：共享内存和消息传递。</p><p><strong>共享内存</strong><br>&emsp;&emsp;在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信。典型的共享内存通信方式，就是通过共享对象进行通信。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1675489410098/b106c218386d4caa9fd623a7bf3d4ef9.png" alt="image.png"></p><p>例如线程A与线程B之间如果要通信的话，那么就必须经历下面两个步骤：<br>1.线程A把本地内存A更新过得共享变量刷新到主内存中去。<br>2.线程B到主内存中去读取线程A之前更新过的共享变量。<br><strong>消息传递</strong><br>&emsp;&emsp;在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行<br>通信。在Java中典型的消息传递方式，就是wait()和notify()，或者BlockingQueue</p><h2 id="16-说说ThreadLocal的原理"><a href="#16-说说ThreadLocal的原理" class="headerlink" title="16.说说ThreadLocal的原理"></a>16.说说ThreadLocal的原理</h2><p>&emsp;&emsp;ThreadLocal可以理解为线程本地变量，他会在每个线程都创建一个副本，那么在线程之间访问内部副本变量就行了，做到了线程之间互相隔离，相比于synchronized的做法是用空间来换时间。</p><p>&emsp;&emsp;ThreadLocal有一个静态内部类ThreadLocalMap，ThreadLocalMap又包含了一个Entry数组，Entry本身是一个弱引用，他的key是指向ThreadLocal的弱引用，Entry具备了保存key value键值对的能力。</p><p>&emsp;&emsp;弱引用的目的是为了防止内存泄露，如果是强引用那么ThreadLocal对象除非线程结束否则始终无法被回收，弱引用则会在下一次GC的时候被回收。</p><p>&emsp;&emsp;但是这样还是会存在内存泄露的问题，假如key和ThreadLocal对象被回收之后，entry中就存在key为null，但是value有值的entry对象，但是永远没办法被访问到，同样除非线程结束运行。</p><p>&emsp;&emsp;但是只要ThreadLocal使用恰当，在使用完之后调用remove方法删除Entry对象，实际上是不会出现这个问题的。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1675489410098/b4f18c4a52ce4b2aa5cd2abfa9d46d4f.png" alt="image.png"></p><h2 id="17-解释下：同步、异步、阻塞、非阻塞"><a href="#17-解释下：同步、异步、阻塞、非阻塞" class="headerlink" title="17.解释下：同步、异步、阻塞、非阻塞"></a>17.解释下：同步、异步、阻塞、非阻塞</h2><p>同步和异步指的是：当前线程是否需要等待方法调用执行完毕。</p><p>阻塞和非阻塞指的是：当前接口数据还未准备就绪时，线程是否被阻塞挂起</p><p>同步&amp;异步其实是处于框架这种高层次维度来看待的，而阻塞&amp;非阻塞往往针对底层的系统调用方面来抉择，也就是说两者是从不同维度来考虑的。</p><p>这四个概念两两组合，会形成4个新的概念，如下：</p><p><strong>同步阻塞</strong>：客户端发送请求给服务端，此时服务端处理任务时间很久，则客户端则被服务端堵塞了，所以客户端会一直等待服务端的响应，此时客户端不能做其他任何事，服务端也不会接受其他客户端的请求。这种通信机制比较简单粗暴，但是效率不高。</p><p><strong>同步非阻塞</strong>：客户端发送请求给服务端，此时服务端处理任务时间很久，这个时候虽然客户端会一直等待响应，但是服务端可以处理其他的请求，过一会回来处理原先的。这种方式很高效，一个服务端可以处理很多请求，不会在因为任务没有处理完而堵着，所以这是非阻塞的。</p><p><strong>异步阻塞</strong>：客户端发送请求给服务端，此时服务端处理任务时间很久，但是客户端不会等待服务器响应，它可以做其他的任务，等服务器处理完毕后再把结果响应给客户端，客户端得到回调后再处理服务端的响应。这种方式可以避免客户端一直处于等待的状态，优化了用户体验，其实就是类似于网页里发起的ajax异步请求。</p><p><strong>异步非阻塞</strong>：客户端发送请求给服务端，此时服务端处理任务时间很久，这个时候的任务虽然处理时间会很久，但是客户端可以做其他的任务，因为他是异步的，可以在回调函数里处理响应；同时服务端是非阻塞的，所以服务端可以去处理其他的任务，如此，这个模式就显得非常的高效了。<img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1675489410098/425e2e707b7a4ba9924e7ed3acafaa6b.png" alt="image.png"></p><h2 id="18-什么是BIO"><a href="#18-什么是BIO" class="headerlink" title="18.什么是BIO?"></a>18.什么是BIO?</h2><p><strong>BIO</strong> ： <strong>同步并阻塞</strong> ，服务器实现一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，没处理完之前此线程不能做其他操作（如果是单线程的情况下，我传输的文件很大呢？），当然可以通过线程池机制改善。</p><p>BIO方式 <strong>适用于连接数目比较小且固定的架构</strong> ，这种方式对服务器资源要求比较高，并发局限于应用中JDK1.4以前的唯一选择，但程序直观简单易理解。</p><h2 id="19-什么是NIO？"><a href="#19-什么是NIO？" class="headerlink" title="19.什么是NIO？"></a>19.什么是NIO？</h2><p><strong>NIO</strong> ： <strong>同步非阻塞</strong> ，服务器实现一个连接一个线程，即客户端发送的连接请求都会注册到多路复用器上，多复用器轮询到连接有I&#x2F;O请求时才启动一个线程进行处理。</p><p>NIO方式 <strong>适用于连接数目多且连接比较短（轻操作）的架构</strong> ，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4之后开始支持。</p><h2 id="20-什么是AIO？"><a href="#20-什么是AIO？" class="headerlink" title="20.什么是AIO？"></a>20.什么是AIO？</h2><p><strong>AIO</strong> ： <strong>异步非阻塞</strong> ，服务器实现模式为一个有效请求一个线程，客户端的I&#x2F;O请求都是由操作系统先完成了再通知服务器应用去启动线程进行处理，AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用操作系统参与并发操作，编程比较复杂，JDK1.7之后开始支持。</p><p>AIO属于NIO包中的类实现，其实 <strong>IO主要分为BIO和NIO</strong> ，AIO只是附加品，解决IO不能异步的实现在以前很少有Linux系统支持AIO，Windows的IOCP就是该AIO模型。但是现在的服务器一般都是支持AIO操作</p><h2 id="21-介绍下IO流的分类"><a href="#21-介绍下IO流的分类" class="headerlink" title="21.介绍下IO流的分类"></a>21.介绍下IO流的分类</h2><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1675489410098/41ec0a93b407448f9c591a7a3645bb3a.png" alt="image.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/04/08/java%E5%9F%BA%E7%A1%80%E9%9D%A2%E7%BB%8F/03-Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2024/04/08/java%E5%9F%BA%E7%A1%80%E9%9D%A2%E7%BB%8F/03-Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="Java基础面试题"><a href="#Java基础面试题" class="headerlink" title="Java基础面试题"></a>Java基础面试题</h1><blockquote><p>讲师：邓澎波</p></blockquote><p>1：<a href="https://cloud.fynote.com/share/d/qPGzAVr5">https://cloud.fynote.com/share/d/qPGzAVr5</a></p><p>2：<a href="https://cloud.fynote.com/share/d/MPG9AVsAG">https://cloud.fynote.com/share/d/MPG9AVsAG</a></p><p>3：<a href="https://cloud.fynote.com/share/d/qPGHKVsM">https://cloud.fynote.com/share/d/qPGHKVsM</a></p><h1 id="一、JavaWeb专题"><a href="#一、JavaWeb专题" class="headerlink" title="一、JavaWeb专题"></a>一、JavaWeb专题</h1><h2 id="1-HTTP响应码有哪些"><a href="#1-HTTP响应码有哪些" class="headerlink" title="1.HTTP响应码有哪些"></a>1.HTTP响应码有哪些</h2><p>1、1xx（临时响应）<br>2、2xx（成功）<br>3、3xx（重定向）：表示要完成请求需要进一步操作<br>4、4xx（错误）：表示请求可能出错，妨碍了服务器的处理<br>5、5xx（服务器错误）：表示服务器在尝试处理请求时发生内部错误</p><p>举例：</p><p>200：成功，Web服务器成功处理了客户端的请求。<br>301：永久重定向，当客户端请求一个网址的时候，Web服务器会将当前请求重定向到另一个网址，搜索引擎会抓取重定向后网页的内容并且将旧的网址替换为重定向后的网址。<br>302：临时重定向，搜索引擎会抓取重定向后网页的内容而保留旧的网址，因为搜索引擎认为重定向后的网址是暂时的。<br>400：客户端请求错误，多为参数不合法导致Web服务器验参失败。<br>404：未找到，Web服务器找不到资源。<br>500：Web服务器错误，服务器处理客户端请求的时候发生错误。<br>503：服务不可用，服务器停机。<br>504：网关超时</p><h2 id="2-Forward和Redirect的区别？"><a href="#2-Forward和Redirect的区别？" class="headerlink" title="2.Forward和Redirect的区别？"></a>2.Forward和Redirect的区别？</h2><ol><li>浏览器URL地址：Forward是服务器内部的重定向，服务器内部请求某个servlet，然后获取响应的内容，浏览器的URL地址是不会变化的；Redirect是客户端请求服务器，然后服务器给客户端返回了一个302状态码和新的location，客户端重新发起HTTP请求，服务器给客户端响应location对应的URL地址，浏览器的URL地址发生了变化。</li><li>数据的共享：Forward是服务器内部的重定向，request在整个重定向过程中是不变的，request中的信息在servlet间是共享的。Redirect发起了两次HTTP请求分别使用不同的request。</li><li>请求的次数：Forward只有一次请求；Redirect有两次请求。</li></ol><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1675489425009/fba756c1b94e439ab2dec986650a7117.png" alt="image.png"></p><h2 id="3-Get和Post请求的区别"><a href="#3-Get和Post请求的区别" class="headerlink" title="3.Get和Post请求的区别"></a>3.Get和Post请求的区别</h2><p>用途：</p><ul><li>get请求用来从服务器获取资源</li><li>post请求用来向服务器提交数据</li></ul><p>表单的提交方式：</p><ul><li>get请求直接将表单数据以name1&#x3D;value1&amp;name2&#x3D;value2的形式拼接到URL上（<a href="http://www.baidu.com/action?name1=value1&name2=value2%EF%BC%89%EF%BC%8C%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0%E5%8F%82%E6%95%B0%E5%80%BC%E9%9C%80%E8%A6%81%E7%94%A8&%E8%BF%9E%E6%8E%A5%E8%B5%B7%E6%9D%A5%E5%B9%B6%E4%B8%94%E7%94%A8?%E6%8B%BC%E6%8E%A5%E5%88%B0action%E5%90%8E%E9%9D%A2%EF%BC%9B">http://www.baidu.com/action?name1=value1&amp;name2=value2），多个参数参数值需要用&amp;连接起来并且用?拼接到action后面；</a></li><li>post请求将表单数据放到请求头或者请求的消息体中。</li></ul><p>传输数据的大小限制：</p><ul><li>get请求传输的数据受到URL长度的限制，而URL长度是由浏览器决定的；</li><li>post请求传输数据的大小理论上来说是没有限制的。</li></ul><p>参数的编码：</p><ul><li>get请求的参数会在地址栏明文显示，使用URL编码的文本格式传递参数；</li><li>post请求使用二进制数据多重编码传递参数。</li></ul><p>缓存处理：</p><ul><li>get请求可以被浏览器缓存被收藏为标签；</li><li>post请求不会被缓存也不能被收藏为标签</li></ul><h2 id="4-介绍下OSI七层和TCP-IP四层的关系"><a href="#4-介绍下OSI七层和TCP-IP四层的关系" class="headerlink" title="4.介绍下OSI七层和TCP&#x2F;IP四层的关系"></a>4.介绍下OSI七层和TCP&#x2F;IP四层的关系</h2><p>为了更好地促进互联网的研究和发展，国际标准化组织ISO在1985 年指定了网络互联模型。OSI 参考模型（Open System Interconnect Reference <a href="https://so.csdn.net/so/search?q=Model&spm=1001.2101.3001.7020">Model</a>），具有 7 层结构</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1675489425009/8b05a5e5ca8f45f6adfe5a2473797a6e.png" alt="image.png"></p><p><strong>应用层</strong>：各种应用程序协议，比如HTTP、HTTPS、FTP、SOCKS安全套接字协议、DNS域名系统、GDP网关发现协议等等。<br><strong>表示层</strong>：加密解密、转换翻译、压缩解压缩，比如LPP轻量级表示协议。<br><strong>会话层</strong>：不同机器上的用户建立和管理会话，比如SSL安全套接字层协议、TLS传输层安全协议、RPC远程过程调用协议等等。</p><p><strong>传输层</strong>：接受上一层的数据，在必要的时候对数据进行分割，并将这些数据交给网络层，保证这些数据段有效到达对端，比如TCP传输控制协议、UDP数据报协议。<br><strong>网络层</strong>：控制子网的运行：逻辑编址、分组传输、路由选择，比如IP、IPV6、SLIP等等。<br><strong>数据链路层</strong>：物理寻址，同时将原始比特流转变为逻辑传输路线，比如XTP压缩传输协议、PPTP点对点隧道协议等等。<br><strong>物理层</strong>：机械、电子、定时接口通信信道上的原始比特流传输，比如IEEE802.2等等。</p><p>而且在消息通信的过程中具体的执行流程为：</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1675489425009/62a425220acc40b6b53cf2c34a4331a6.png" alt="image.png"></p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1675489425009/933af2e7173942319f49900f5ce9ae49.png" alt="image.png"></p><p>网络传输的数据其实会通过这七层协议来进行数据的封装和拆解</p><h2 id="5-说说TCP和UDP的区别"><a href="#5-说说TCP和UDP的区别" class="headerlink" title="5.说说TCP和UDP的区别"></a>5.说说TCP和UDP的区别</h2><p>1、TCP面向连接（如打电话要先拨号建立连接）：UDP是无连接的，即发送数据之前不需要建立连接。<br>2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付。tcp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。<br>3、UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。<br>4.每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信</p><p>5、TCP对系统资源要求较多，UDP对系统资源要求较少。</p><h2 id="6-说下HTTP和HTTPS的区别"><a href="#6-说下HTTP和HTTPS的区别" class="headerlink" title="6. 说下HTTP和HTTPS的区别"></a>6. 说下HTTP和HTTPS的区别</h2><p>端口不同：HTTP和HTTPS的连接方式不同没用的端口也不一样，HTTP是80，HTTPS用的是443<br>消耗资源：和HTTP相比，HTTPS通信会因为加解密的处理消耗更多的CPU和内存资源。<br>开销：HTTPS通信需要证书，这类证书通常需要向认证机构申请或者付费购买。</p><h2 id="7-说下HTTP、TCP、Socket的关系是什么？"><a href="#7-说下HTTP、TCP、Socket的关系是什么？" class="headerlink" title="7.说下HTTP、TCP、Socket的关系是什么？"></a>7.说下HTTP、TCP、Socket的关系是什么？</h2><ul><li>TCP&#x2F;IP代表传输控制协议&#x2F;网际协议，指的是一系列协议族。</li><li>HTTP本身就是一个协议，是从Web服务器传输超文本到本地浏览器的传送协议。</li><li>Socket是TCP&#x2F;IP网络的API，其实就是一个门面模式，它把复杂的TCP&#x2F;IP协议族隐藏在Socket接口后面。对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。</li></ul><p>综上所述：</p><ul><li>需要IP协议来连接网络</li><li>TCP是一种允许我们安全传输数据的机制，使用TCP协议来传输数据的HTTP是Web服务器和客户端使用的特殊协议。</li><li>HTTP基于TCP协议，所以可以使用Socket去建立一个TCP连接。</li></ul><h2 id="8-说下HTTP的长链接和短连接的区别"><a href="#8-说下HTTP的长链接和短连接的区别" class="headerlink" title="8. 说下HTTP的长链接和短连接的区别"></a>8. 说下HTTP的长链接和短连接的区别</h2><p>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</p><p><strong>短连接</strong><br>&emsp;&emsp;在HTTP&#x2F;1.0中默认使用短链接,也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。如果客户端访问的某个HTML或其他类型的Web资源，如JavaScript文件、图像文件、CSS文件等。当浏览器每遇到这样一个Web资源，就会建立一个HTTP会话.<br><strong>长连接</strong><br>&emsp;&emsp;从HTTP&#x2F;1.1起，默认使用长连接，用以保持连接特性。在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭。如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。</p><h2 id="9-TCP原理"><a href="#9-TCP原理" class="headerlink" title="9.TCP原理"></a>9.TCP原理</h2><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1675489425009/2c3e7415ef194f0a93fd91345ba9c0ac.png" alt="image.png"></p><p>三次握手：</p><p>1.第一次握手：客户端将标志位syn重置为1，随机产生seq&#x3D;a，并将数据包发送给服务端<br>2.第二次握手：服务端收到syn&#x3D;1知道客户端请求连接，服务端将syn和ACK都重置为1，ack&#x3D;a+1，随机产一个值seq&#x3D;b，并将数据包发送给客户端，服务端进入syn_RCVD状态。<br>3.第三次握手：客户端收到确认后，检查ack是否为a+1，ACK是否为1，若正确将ACK重置为1，将ack改为b+1，然后将数据包发送给服务端服务端检查ack与ACK,若都正确，就建立连接，进入ESTABLISHEN.</p><p>四次挥手：</p><p>1.开始双方都处于连接状态<br>2.客户端进程发出FIN报文，并停止发送数据，在报文中FIN结束标志为1，seq为a连接状态下发送给服务器的最后一个字节的序号+1，报文发送结束后，客户端进入FIN-WIT1状态。<br>3.服务端收到报文，向客户端发送确认报文，ACK&#x3D;1,seq为b服务端给客户端发送的最后字节的序号+1，ack&#x3D;a+1，发送后客户端进入close-wait状态，不再发送数据，但服务端发送数据客户端一九可以收到（城为半关闭状态）。<br>4.客户端收到服务器的确认报文后，客户端进入fin-wait2状态进行等待服务器发送第三次的挥手报文。<br>5.服务端向fin报文FIN&#x3D;1ACK&#x3D;1，seq&#x3D;c（服务器向客户端发送最后一个字节序号+1），ack&#x3D;b+1，发送结束后服务器进入last-ack状态等待最后的确认。<br>6.客户端收到是释放报文后，向服务器发送确认报文进入time-wait状态，后进入close<br>7.服务端收到确认报文进入close状态。</p><h2 id="10-Cookie和Session的区别"><a href="#10-Cookie和Session的区别" class="headerlink" title="10. Cookie和Session的区别"></a>10. Cookie和Session的区别</h2><p>&emsp;&emsp;cookie是由Web服务器保存在用户浏览器上的文件（key-value格式），可以包含用户相关的信息。客户端向服务器发起请求，就提取浏览器中的用户信息由http发送给服务器</p><p>&emsp;&emsp;session是浏览器和服务器会话过程中，服务器会分配的一块储存空间给session。服务器默认为客户浏览器的cookie中设置sessionid，这个sessionid就和cookie对应，浏览器在向服务器请求过程中传输的cookie包含sessionid，服务器根据传输cookie中的sessionid获取出会话中存储的信息，然后确定会话的身份信息。</p><p>1、Cookie数据存放在客户端上，安全性较差，Session数据放在服务器上，安全性相对更高<br>2、单个cookie保存的数据不能超过4K，session无此限制<br>3、session一定时间内保存在服务器上，当访问增多，占用服务器性能，考虑到服务器性能方面，应当<br>使用cookie。</p><h2 id="11-Tomcat是什么？"><a href="#11-Tomcat是什么？" class="headerlink" title="11.Tomcat是什么？"></a>11.Tomcat是什么？</h2><p>Tomcat服务器Apache软件基金会项目中的一个核心项目，是一个免费的开放源代码的Web应用服<br>务器（Servlet容器），属于轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被<br>普遍使用，是开发和调试JSP程序的首选。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1675489425009/cc3c3c6020d54b098e862692bada4302.png" alt="image.png"></p><h2 id="12-Tomcat有几种部署方式"><a href="#12-Tomcat有几种部署方式" class="headerlink" title="12.Tomcat有几种部署方式"></a>12.Tomcat有几种部署方式</h2><ol><li>利用Tomcat的自动部署：把web应用拷贝到webapps目录（生产环境不建议放在该目录中）。Tomcat在启动时会加载目录下的应用，并将编译后的结果放入work目录下。</li><li>使用Manager App控制台部署：在tomcat主页点击“Manager App”进入应用管理控制台，可以指定一个web应用的路径或war文件。</li><li>修改conf&#x2F;server.xml文件部署：在server.xml文件中，增加Context节点可以部署应用。</li><li>增加自定义的Web部署文件：在conf&#x2F;Catalina&#x2F;localhost&#x2F;路径下增加xyz.xml文件，内容是Context节点，可以部署应用。</li></ol><h2 id="13-什么是Servlet"><a href="#13-什么是Servlet" class="headerlink" title="13.什么是Servlet"></a>13.什么是Servlet</h2><p>&emsp;&emsp;Servlet是JavaEE规范的一种，主要是为了扩展Java作为Web服务的功能，统一接口。由其他内部厂<br>商如tomcat，jetty内部实现web的功能。如一个http请求到来：容器将请求封装为servlet中的<br>HttpServletRequest对象，调用init()，service()等方法输出response,由容器包装为httpresponse<br>返回给客户端的过程。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1675489425009/f1f331019c8b41519bd49a588d413ffc.png" alt="image.png"></p><h2 id="14-什么是Servlet规范"><a href="#14-什么是Servlet规范" class="headerlink" title="14. 什么是Servlet规范?"></a>14. 什么是Servlet规范?</h2><ul><li>从Jar包上来说，Servlet规范就是两个Jar文件。servlet-api.jar和jsp-api.jar，Jsp也是一种Servlet。</li><li>从package上来说，就是javax.servlet和javax.servlet.http两个包。</li><li>从接口来说，就是规范了Servlet接口、Filter接口、Listener接口、ServletRequest接口、ServletResponse接口等。类图如下：</li></ul><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1675489425009/5605477c3db841e7824a0432e4a6c2a9.png" alt="image.png"></p><h2 id="15-为什么我们将tomcat称为Web容器或者Servlet容器？"><a href="#15-为什么我们将tomcat称为Web容器或者Servlet容器？" class="headerlink" title="15.为什么我们将tomcat称为Web容器或者Servlet容器？"></a>15.为什么我们将tomcat称为Web容器或者Servlet容器？</h2><p>我们用一张图来表示他们之间的关系:</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1675489425009/5e137f734ac540ed9aaee12704166ec0.png" alt="image.png"></p><p>简单的理解：启动一个ServerSocket，监听8080端口。Servlet容器用来装我们开发的Servlet。</p><h2 id="16-Servlet的生命周期"><a href="#16-Servlet的生命周期" class="headerlink" title="16.Servlet的生命周期"></a>16.Servlet的生命周期</h2><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1675489425009/b6757fdbc638457daebd04fd83a9d0f7.png" alt="image.png"></p><h2 id="17-jsp和Servlet的区别"><a href="#17-jsp和Servlet的区别" class="headerlink" title="17. jsp和Servlet的区别"></a>17. jsp和Servlet的区别</h2><ul><li>本质都是servlet</li><li>servlet侧重于逻辑处理</li><li>jsp侧重于视图显示</li></ul><h2 id="18-九大内置对象"><a href="#18-九大内置对象" class="headerlink" title="18. 九大内置对象"></a>18. 九大内置对象</h2><ol><li>page页面对象</li><li>config配置对象</li><li>request请求对象</li><li>response响应对象</li><li>session会话对象</li><li>application全局对象</li><li>out输出对象</li><li>pageContext页面上下文对象</li><li>exception异常对象</li></ol><h2 id="19-JSP的四大作用域"><a href="#19-JSP的四大作用域" class="headerlink" title="19. JSP的四大作用域"></a>19. JSP的四大作用域</h2><p>page：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">只在当前页面有效<br></code></pre></td></tr></table></figure><p>request：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">它在当前请求中有效<br></code></pre></td></tr></table></figure><p>session：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">它在当前会话中有效<br></code></pre></td></tr></table></figure><p>application：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">他在所有的应用程序中都有效<br></code></pre></td></tr></table></figure><p>注意：当4个作用域对象都有相同的name属性时,默认按照最小的顺序查找</p><h2 id="20-GenericServlet和HttpServlet有什么区别？"><a href="#20-GenericServlet和HttpServlet有什么区别？" class="headerlink" title="20. GenericServlet和HttpServlet有什么区别？"></a>20. <strong>GenericServlet和HttpServlet有什么区别？</strong></h2><p>GenericServlet 为抽象类，定义了一个通用的、独立于底层协议的servlet，实现了Servlet 和 ServletConfig接口，ServletConfig接口定义了在Servlet初始化的过程中由Servlet容器传递给Servlet得配置信息对象。OK，这个类可能我们不是那么熟悉，但是他的子类相信大家都知道，也就是HttpServlet，HttpServlet 继承自抽象类GenericServlet 具有其所有的特性并拓展了一些其他的方法,如doGet、doPost等</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1675489425009/12c9c504a75243bba4aec073404bdc5e.png" alt="image.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/04/08/java%E5%9F%BA%E7%A1%80%E9%9D%A2%E7%BB%8F/01-Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2024/04/08/java%E5%9F%BA%E7%A1%80%E9%9D%A2%E7%BB%8F/01-Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="Java基础面试题"><a href="#Java基础面试题" class="headerlink" title="Java基础面试题"></a>Java基础面试题</h1><blockquote><p>讲师：邓澎波</p></blockquote><h1 id="一、面向对象和集合专题"><a href="#一、面向对象和集合专题" class="headerlink" title="一、面向对象和集合专题"></a>一、面向对象和集合专题</h1><h2 id="1-面向对象和面向过程的区别"><a href="#1-面向对象和面向过程的区别" class="headerlink" title="1. 面向对象和面向过程的区别"></a>1. 面向对象和面向过程的区别</h2><p><strong>面向过程</strong>：是分析解决问题的步骤，然后用函数把这些步骤一步一步地实现，然后在使用的时候一一调用则可。性能较高，所以单片机、嵌入式开发等一般采用面向过程开发</p><p><strong>面向对象</strong>：是把构成问题的事务分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事物在解决整个问题的过程中所发生的行为。面向对象有封装、继承、多态的特性，所以易维护、易复用、易扩展。可以设计出低耦合的系统。 但是性能上来说，比面向过程要低。</p><p>OOP和AOP</p><h2 id="2-介绍下Java中的基本数据类型"><a href="#2-介绍下Java中的基本数据类型" class="headerlink" title="2. 介绍下Java中的基本数据类型"></a>2. 介绍下Java中的基本数据类型</h2><table><thead><tr><th>基本类型</th><th>大小(字节)</th><th>默认值</th><th>封装类</th></tr></thead><tbody><tr><td>byte</td><td>1</td><td>(byte)0</td><td>Byte</td></tr><tr><td>short</td><td>2</td><td>(short)0</td><td>Short</td></tr><tr><td>int</td><td>4</td><td>0</td><td>Integer</td></tr><tr><td>long</td><td>8</td><td>0l</td><td>Long</td></tr><tr><td>float</td><td>4</td><td>0.0f</td><td>Float</td></tr><tr><td>double</td><td>8</td><td>0.0d</td><td>Double</td></tr><tr><td>boolean</td><td>-</td><td>false</td><td>Boolean</td></tr><tr><td>char</td><td>2</td><td>\u0000(null)</td><td>Character</td></tr></tbody></table><p>boolean: int 4个字节</p><p>需要注意：</p><ol><li>int是基本数据类型，Integer是int的封装类，是引用类型。int默认值是0，而Integer默认值是null，所以Integer能区分出0和null的情况。一旦java看到null，就知道这个引用还没有指向某个对象，再任何引用使用前，必须为其指定一个对象，否则会报错。</li><li>基本数据类型在声明时系统会自动给它分配空间，而引用类型声明时只是分配了引用空间，必须通过实例化开辟数据空间之后才可以赋值。数组对象也是一个引用对象，将一个数组赋值给另一个数组时只是复制了一个引用，所以通过某一个数组所做的修改在另一个数组中也看的见。虽然定义了boolean这种数据类型，但是只对它提供了非常有限的支持。在Java虚拟机中没有任何供boolean值专用的字节码指令，Java语言表达式所操作的boolean值，在编译之后都使用Java虚拟机中的int数据类型来代替，而boolean数组将会被编码成Java虚拟机的byte数组，每个元素boolean元素占8位。这样我们可以得出boolean类型占了单独使用是4个字节，在数组中又是1个字节。使用int的原因是，对于当下32位的处理器（CPU）来说，一次处理数是32位（这里不是指的是32&#x2F;64位系统，而是指CPU硬件层面），具有高效存取的特点。</li></ol><h2 id="3-标识符的命名规则"><a href="#3-标识符的命名规则" class="headerlink" title="3. 标识符的命名规则"></a>3. 标识符的命名规则</h2><p><strong>标识符的含义</strong>： 是指在程序中，我们自己定义的内容，譬如，类的名字，方法名称以及变量名称等等，都是标识符。</p><p><strong>命名规则</strong>：（硬性要求） 标识符可以包含<strong>英文字母</strong>，<strong>0-9的数字</strong>，**$<strong>以及</strong>_** 标识符不能以数字开头，标识符不是关键字<br><strong>命名规范</strong>：（非硬性要求） 类名规范：首字符大写，后面每个单词首字母大写（大驼峰式）。 变量名规范：首字母小写，后面每个单词首字母大写（小驼峰式）。 方法名规范：同变量名。</p><h2 id="4-instanceof关键字的作用"><a href="#4-instanceof关键字的作用" class="headerlink" title="4. instanceof关键字的作用"></a>4. instanceof关键字的作用</h2><p>instanceof 严格来说是Java中的一个双目运算符，用来测试一个对象是否为一个类的实例，用法<br>为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> obj <span class="hljs-keyword">instanceof</span> Class<br></code></pre></td></tr></table></figure><p>其中 obj 为一个对象，Class 表示一个类或者一个接口，当 obj 为 Class 的对象，或者是其直接或间接子类，或者是其接口的实现类，结果result 都返回 true，否则返回false。<br><strong>注意</strong>：编译器会检查 obj 是否能转换成右边的class类型，如果不能转换则直接报错，如果不能确定类型，则通过编译，具体看运行时定。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(i instanceof <span class="hljs-type">Integer</span>);//编译不通过 i必须是引用类型，不能是基本类型<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(i instanceof <span class="hljs-keyword">Object</span>);//编译不通过<br><br><span class="hljs-type">Integer</span> <span class="hljs-type">integer</span> = <span class="hljs-built_in">new</span> <span class="hljs-type">Integer</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-type">integer</span> instanceof <span class="hljs-type">Integer</span>);//<span class="hljs-keyword">true</span><br><br>//<span class="hljs-keyword">false</span> ,在 JavaSE规范 中对 instanceof 运算符的规定就是：如果 obj 为 <span class="hljs-keyword">null</span>，那么将返回 <span class="hljs-keyword">false</span>。<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">null</span> instanceof <span class="hljs-keyword">Object</span>);<br></code></pre></td></tr></table></figure><h2 id="5-重载和重写的区别"><a href="#5-重载和重写的区别" class="headerlink" title="5.重载和重写的区别"></a>5.重载和重写的区别</h2><p><strong>重写(Override)</strong><br>&emsp;&emsp;从字面上看，重写就是 重新写一遍的意思。其实就是在子类中把父类本身有的方法重新写一遍。子类继承了父类原有的方法，但有时子类并不想原封不动的继承父类中的某个方法，所以在方法名，参数列表，返回类型(除过子类中方法的返回值是父类中方法返回值的子类时)都相同的情况下， 对方法体进行修改或重写，这就是重写。但要注意子类函数的访问修饰权限不能少于父类的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span> &#123;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br> <span class="hljs-comment">// TODO Auto-generated method stub</span><br> <span class="hljs-type">Son</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Son</span>();<br> s.sayHello();<br> &#125;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span> &#123;<br> System.out.println(<span class="hljs-string">&quot;Hello&quot;</span>);<br> &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Father</span>&#123;<br> <span class="hljs-meta">@Override</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span> &#123;<br> <span class="hljs-comment">// TODO Auto-generated method stub</span><br> System.out.println(<span class="hljs-string">&quot;hello by &quot;</span>);<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>重写 总结：</p><ol><li>发生在父类与子类之间</li><li>方法名，参数列表，返回类型（除过子类中方法的返回类型是父类中返回类型的子类）必须相同</li><li>访问修饰符的限制一定要大于被重写方法的访问修饰符（public&gt;protected&gt;default&gt;private)</li><li>重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常</li></ol><p><strong>重载（Overload）</strong></p><p>&emsp;&emsp;在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同甚至是参数顺序不同）则视为重载。同时，重载对返回类型没有要求，可以相同也可以不同，但不能通过返回类型是否相同来判断重载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span> &#123;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br> <span class="hljs-comment">// TODO Auto-generated method stub</span><br> <span class="hljs-type">Father</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Father</span>();<br> s.sayHello();<br> s.sayHello(<span class="hljs-string">&quot;wintershii&quot;</span>);<br> &#125;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span> &#123;<br> System.out.println(<span class="hljs-string">&quot;Hello&quot;</span>);<br> &#125;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">(String name)</span> &#123;<br> System.out.println(<span class="hljs-string">&quot;Hello&quot;</span> + <span class="hljs-string">&quot; &quot;</span> + name);<br> &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>重载 总结：</p><ol><li>重载Overload是一个类中多态性的一种表现</li><li>重载要求同名方法的参数列表不同(参数类型，参数个数甚至是参数顺序)</li><li>重载的时候，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准</li></ol><h2 id="6-介绍下内部类"><a href="#6-介绍下内部类" class="headerlink" title="6.介绍下内部类"></a>6.介绍下内部类</h2><p>目的：提高安全性</p><p>在Java中，可以将一个类定义在另一个类里面或者一个方法里面，这样的类称为内部类。广泛意义上的内部类一般来说包括这三种：成员内部类、局部内部类、匿名内部类，如下图所示：</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1675489386042/8968036e5ec5472aa32090fa2260eb0a.png" alt="image.png"></p><h2 id="7-介绍下Java中的四种引用"><a href="#7-介绍下Java中的四种引用" class="headerlink" title="7.介绍下Java中的四种引用"></a>7.介绍下Java中的四种引用</h2><p><strong>强引用</strong><br>&emsp;&emsp;强引用是平常中使用最多的引用，强引用在程序内存不足（OOM）的时候也不会被回收，使用<br>方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;str&quot;</span>);<br>System.out.println(str);<br></code></pre></td></tr></table></figure><p><strong>软引用</strong><br>&emsp;&emsp;软引用在程序内存不足时，会被回收，使用方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 注意：wrf这个引用也是强引用，它是指向SoftReference这个对象的，</span><br><span class="hljs-comment">// 这里的软引用指的是指向new String(&quot;str&quot;)的引用，也就是SoftReference类中T</span><br>SoftReference&lt;String&gt; wrf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SoftReference</span>&lt;String&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;str&quot;</span>));<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;可用场景： 创建缓存的时候，创建的对象放进缓存中，当内存不足时，JVM就会回收早先创建的对象。<br><strong>弱引用</strong><br>&emsp;&emsp;弱引用就是只要JVM垃圾回收器发现了它，就会将之回收，使用方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">WeakReference&lt;String&gt; wrf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>&lt;String&gt;(str);<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;可用场景： Java源码中的 java.util.WeakHashMap 中的 key 就是使用弱引用，我的理解就是，一旦我不需要某个引用，JVM会自动帮我处理它，这样我就不需要做其它操作。<br><strong>虚引用</strong><br>&emsp;&emsp;虚引用的回收机制跟弱引用差不多，但是它被回收之前，会被放入 ReferenceQueue 中。注意哦，其它引用是被JVM回收后才被传入 ReferenceQueue 中的。由于这个机制，所以虚引用大多被用于引用销毁前的处理工作。还有就是，虚引用创建的时候，必须带有 ReferenceQueue ，使用例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">PhantomReference&lt;String&gt; prf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PhantomReference</span>&lt;String&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;str&quot;</span>),<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceQueue</span>&lt;&gt;());<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;可用场景： 对象销毁前的一些操作，比如说资源释放等。 Object.finalize() 虽然也可以做这类动作，但是这个方式即不安全又低效<br>&emsp;&emsp;上诉所说的几类引用，都是指对象本身的引用，而不是指Reference的四个子类的引用(SoftReference等)。</p><h2 id="8-HashCode的作用"><a href="#8-HashCode的作用" class="headerlink" title="8.HashCode的作用"></a>8.HashCode的作用</h2><p>&emsp;&emsp;java的集合有两类，一类是List，还有一类是Set。前者有序可重复，后者无序不重复。当我们在set中插入的时候怎么判断是否已经存在该元素呢，可以通过equals方法。但是如果元素太多，用这样的方法就会比较满。于是有人发明了哈希算法来提高集合中查找元素的效率。 这种方式将集合分成若干个存储区域，每个对象可以计算出一个哈希码，可以将哈希码分组，每组分别对应某个存储区域，根据一个对象的哈希码就可以确定该对象应该存储的那个区域。hashCode方法可以这样理解：它返回的就是根据对象的内存地址换算出的一个值。这样一来，当集合要添加新的元素时，先调用这个元素的hashCode方法，就一下子能定位到它应该放置的物理位置上。如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了；如果这个位置上已经有元素了，就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址。这样一来实际调用equals方法的次数就大大降低了，几乎只需要一两次。</p><h2 id="9-有没有可能两个不相等的对象有相同的hashcode"><a href="#9-有没有可能两个不相等的对象有相同的hashcode" class="headerlink" title="9.有没有可能两个不相等的对象有相同的hashcode"></a>9.有没有可能两个不相等的对象有相同的hashcode</h2><p>能.在产生hash冲突时,两个不相等的对象就会有相同的 hashcode 值.当hash冲突产生时,一般<br>有以下几种方式来处理:</p><ul><li>拉链法:每个哈希表节点都有一个next指针,多个哈希表节点可以用next指针构成一个单向链<br>表，被分配到同一个索引上的多个节点可以用这个单向链表进行存储.</li><li>开放定址法:一旦发生了冲突,就去寻找下一个空的散列地址,只要散列表足够大,空的散列地址总<br>能找到,并将记录存入</li><li>再哈希:又叫双哈希法,有多个不同的Hash函数.当发生冲突时,使用第二个,第三个….等哈希函数<br>计算地址,直到无冲突</li></ul><h2 id="10-深拷贝和浅拷贝的区别是什么"><a href="#10-深拷贝和浅拷贝的区别是什么" class="headerlink" title="10.深拷贝和浅拷贝的区别是什么?"></a>10.深拷贝和浅拷贝的区别是什么?</h2><p>原型模式：设计模式 –&gt; Spring bean的Scope</p><p><strong>浅拷贝</strong>:被复制对象的所有变量都含有与原来的对象相同的值,而所有的对其他对象的引用仍然指<br>向原来的对象.换言之,浅拷贝仅仅复制所考虑的对象,而不复制它所引用的对象.</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1675489386042/d063a0a305a34ea18fcfb8c1aeb80b66.png" alt="image.png"></p><p><strong>深拷贝</strong>:被复制对象的所有变量都含有与原来的对象相同的值.而那些引用其他对象的变量将指向<br>被复制过的新对象.而不再是原有的那些被引用的对象.换言之.深拷贝把要复制的对象所引用的<br>对象都复制了一遍.</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1675489386042/2c56eb2723ee4cec85b2b36a8b77d167.png" alt="image.png"></p><h2 id="11-static都有哪些用法"><a href="#11-static都有哪些用法" class="headerlink" title="11.static都有哪些用法?"></a>11.static都有哪些用法?</h2><p>&emsp;&emsp;所有的人都知道static关键字这两个基本的用法:静态变量和静态方法.也就是被static所修饰的变量&#x2F;<br>方法都属于类的静态资源,类实例所共享.<br>&emsp;&emsp;除了静态变量和静态方法之外,static也用于静态块,多用于初始化操作:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> calss PreCache&#123;<br> <span class="hljs-keyword">static</span>&#123;<br> <span class="hljs-comment">//执行相关操作</span><br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;此外static也多用于修饰内部类,此时称之为静态内部类.<br>&emsp;&emsp;最后一种用法就是静态导包,即 import static .import static是在JDK 1.5之后引入的新特性,可以用<br>来指定导入某个类中的静态资源,并且不需要使用类名,可以直接使用资源名,比如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.lang.Math.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br> <span class="hljs-comment">//System.out.println(Math.sin(20));传统做法</span><br> System.out.println(sin(<span class="hljs-number">20</span>));<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="12-介绍下Object中的常用方法"><a href="#12-介绍下Object中的常用方法" class="headerlink" title="12. 介绍下Object中的常用方法"></a>12. 介绍下Object中的常用方法</h2><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1675489386042/33ec904f252a4c149d45179b99477395.png" alt="image.png"></p><p><strong>clone 方法</strong><br>&emsp;&emsp;保护方法，实现对象的浅复制，只有实现了 Cloneable 接口才可以调用该方法，否则抛出<br>CloneNotSupportedException 异常，深拷贝也需要实现 Cloneable，同时其成员变量为引用类型<br>的也需要实现 Cloneable，然后重写 clone 方法。</p><p><strong>finalize 方法</strong></p><p>&emsp;&emsp;该方法和垃圾收集器有关系，判断一个对象是否可以被回收的最后一步就是判断是否重写了此方<br>法。</p><p><strong>equals 方法</strong><br>&emsp;&emsp;该方法使用频率非常高。一般 equals 和 &#x3D;&#x3D; 是不一样的，但是在 Object 中两者是一样的。子类一<br>般都要重写这个方法。</p><p><strong>hashCode 方法</strong><br>&emsp;&emsp;该方法用于哈希查找，重写了 equals 方法一般都要重写 hashCode 方法，这个方法在一些具有哈<br>希功能的 Collection 中用到。<br>&emsp;&emsp;一般必须满足 obj1.equals(obj2)&#x3D;&#x3D;true 。可以推出 obj1.hashCode()&#x3D;&#x3D;obj2.hashCode() ，但是<br>hashCode 相等不一定就满足 equals。不过为了提高效率，应该尽量使上面两个条件接近等价。</p><ul><li>JDK 1.6、1.7 默认是返回随机数；</li><li>JDK 1.8 默认是通过和当前线程有关的一个随机数 + 三个确定值，运用 Marsaglia’s xorshift<br>scheme 随机数算法得到的一个随机数。</li></ul><p><strong>wait 方法</strong></p><p>&emsp;&emsp;配合 synchronized 使用，wait 方法就是使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。wait() 方法一直等待，直到获得锁或者被中断。wait(long timeout)设定一个超时间隔，如果在规定时间内没有获得锁就返回。<br>调用该方法后当前线程进入睡眠状态，直到以下事件发生。</p><ol><li>其他线程调用了该对象的 notify 方法；</li><li>其他线程调用了该对象的 notifyAll 方法；</li><li>其他线程调用了 interrupt 中断该线程；</li><li>时间间隔到了。<br>此时该线程就可以被调度了，如果是被中断的话就抛出一个 InterruptedException 异常。</li></ol><p><strong>notify 方法</strong><br>&emsp;&emsp;配合 synchronized 使用，该方法唤醒在该对象上等待队列中的某个线程（同步队列中的线程是给抢占 CPU 的线程，等待队列中的线程指的是等待唤醒的线程）。<br><strong>notifyAll 方法</strong><br>&emsp;&emsp;配合 synchronized 使用，该方法唤醒在该对象上等待队列中的所有线程。<br><strong>总结</strong><br>&emsp;&emsp;只要把上面几个方法熟悉就可以了，toString 和 getClass 方法可以不用去讨论它们。该题目考察的是对 Object 的熟悉程度，平时用的很多方法并没看其定义但是也在用，比如说：wait() 方法，equals() 方法等。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">Class Object is the root of the class hierarchy.Every class has Object as a<br>superclass. All objects, including arrays, implement the methods of this class.<br></code></pre></td></tr></table></figure><p>大致意思：Object 是所有类的根，是所有类的父类，所有对象包括数组都实现了 Object 的方法。</p><h2 id="13-Java-创建对象有几种方式？"><a href="#13-Java-创建对象有几种方式？" class="headerlink" title="13.Java 创建对象有几种方式？"></a>13.Java 创建对象有几种方式？</h2><p><strong>new 关键字</strong></p><p>&emsp;&emsp;平时使用的最多的创建对象方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">User user=<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br></code></pre></td></tr></table></figure><p><strong>反射方式</strong></p><p>&emsp;&emsp;使用 newInstance()，但是得处理两个异常 InstantiationException、IllegalAccessException：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">User user=User.class.newInstance();<br>Object object=(Object)Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>).newInstance()<br></code></pre></td></tr></table></figure><p><strong>clone方法</strong></p><p>&emsp;&emsp;Object对象中的clone方法来完成这个操作</p><p><strong>反序列化操作</strong></p><p>&emsp;&emsp;调用 ObjectInputStream 类的 readObject() 方法。我们反序列化一个对象，JVM 会给我们创建一个单独的对象。JVM 创建对象并不会调用任何构造函数。一个对象实现了 Serializable 接口，就可以把对象写入到文中，并通过读取文件来创建对象。</p><p><strong>总结</strong><br>&emsp;&emsp;创建对象的方式关键字：new、反射、clone 拷贝、反序列化。</p><h2 id="14-有了数组为什么还要再搞一个ArrayList呢？"><a href="#14-有了数组为什么还要再搞一个ArrayList呢？" class="headerlink" title="14.有了数组为什么还要再搞一个ArrayList呢？"></a>14.有了数组为什么还要再搞一个ArrayList呢？</h2><p>&emsp;&emsp;通常我们在使用的时候，如果在不明确要插入多少数据的情况下，普通数组就很尴尬了，因为你不知道需要初始化数组大小为多少，而 ArrayList 可以使用默认的大小，当元素个数到达一定程度后，会自动扩容。<br>&emsp;&emsp;可以这么来理解：我们常说的数组是定死的数组，ArrayList 却是动态数组。</p><h2 id="15-说说什么是-fail-fast？"><a href="#15-说说什么是-fail-fast？" class="headerlink" title="15. 说说什么是 fail-fast？"></a>15. 说说什么是 fail-fast？</h2><p><strong>&emsp;&emsp;fail-fast</strong> 机制是 Java 集合（Collection）中的一种错误机制。当多个线程对同一个集合的内容进行操作时，就可能会产生 fail-fast 事件。<br>&emsp;&emsp;例如：当某一个线程 A 通过 iterator 去遍历某集合的过程中，若该集合的内容被其他线程所改变了，那么线程 A 访问集合时，就会抛出 ConcurrentModificationException 异常，产生 fail-fast 事件。这里的操作主要是指 add、remove 和 clear，对集合元素个数进行修改。<br><strong>&emsp;&emsp;解决办法</strong>：建议使用“java.util.concurrent 包下的类”去取代“java.util 包下的类”。可以这么理解：在遍历之前，把 modCount 记下来 expectModCount，后面 expectModCount 去和 modCount 进行比较，如果不相等了，证明已并发了，被修改了，于是抛出ConcurrentModificationException 异常。</p><h2 id="16-介绍下你对Java集合的理解"><a href="#16-介绍下你对Java集合的理解" class="headerlink" title="16.介绍下你对Java集合的理解"></a>16.介绍下你对Java集合的理解</h2><p>&emsp;&emsp;集合是我们在工作中使用频率非常高的组件了。下面的两张图是集合框架的类图结构。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1675489386042/78abc041848d4ac0ab959ae32cea7598.png" alt="image.png"></p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1675489386042/b4ee8f50d3d448adbcde7e3ad4dd72dd.png" alt="image.png"></p><p>TreeSet的本质是TreeMap</p><p>HashSet的本质是HashMap</p><h2 id="17-介绍下你对红黑树的理解"><a href="#17-介绍下你对红黑树的理解" class="headerlink" title="17.介绍下你对红黑树的理解"></a>17.介绍下你对红黑树的理解</h2><p>红黑树的特点：</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1675489386042/fc0214f69d974e18bfa466511efe2f2e.png" alt="image.png"></p><p>红黑色的本质：2-3-4树</p><p>红黑树保证黑节点平衡的方式:左旋&#x2F;右旋+变色 来保证</p><h2 id="18-try-finally中的return关键字"><a href="#18-try-finally中的return关键字" class="headerlink" title="18. try-finally中的return关键字"></a>18. try-finally中的return关键字</h2><p>return语句的本质：</p><ol><li>return语句获取到变量的地址</li><li>return将获取的地址返回，也就是return本质是传地址</li></ol><p>测试案例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Too too=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Too</span>();<br>        StringBuilder t1=test(too);<br>        System.out.println(<span class="hljs-string">&quot;return语句返回的:&quot;</span>+t1+<span class="hljs-string">&quot;\t返回值的hashCode:&quot;</span>+t1.hashCode());<br>        System.out.println(<span class="hljs-string">&quot;finaly里面修改的:&quot;</span>+too.num+<span class="hljs-string">&quot;\tfinaly的hashCode:&quot;</span>+too.num.hashCode());<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> StringBuilder <span class="hljs-title function_">test</span><span class="hljs-params">(Too too)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            too.num=<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;try&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;try字符串的hashcode:&quot;</span>+(<span class="hljs-string">&quot;try&quot;</span>).hashCode());<br>            System.out.println(<span class="hljs-string">&quot;StringBuilder里的try的hashCode:&quot;</span>+too.num.hashCode());<span class="hljs-comment">//--语句1</span><br>            <span class="hljs-keyword">return</span> too.num; <span class="hljs-comment">//语句2</span><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            too.num=<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;finaly&quot;</span>);<span class="hljs-comment">//语句3</span><br>            System.out.println(<span class="hljs-string">&quot;finaly的hashCode:&quot;</span>+too.num.hashCode());<span class="hljs-comment">//语句4</span><br>        &#125;&#125;&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Too</span>&#123;<br>    StringBuilder num=<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;你好&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs txt">try字符串的hashcode:115131<br>StringBuilder里的try的hashCode:460141958<br>finaly的hashCode:1163157884<br>return语句返回的:try返回值的hashCode:460141958<br>finaly里面修改的:finalyfinaly的hashCode:1163157884<br></code></pre></td></tr></table></figure><h2 id="19-异常处理影响性能吗"><a href="#19-异常处理影响性能吗" class="headerlink" title="19.异常处理影响性能吗"></a>19.异常处理影响性能吗</h2><p>&emsp;&emsp;异常处理的性能成本非常高，每个 Java 程序员在开发时都应牢记这句话。创建一个异常非常慢，抛出一个异常又会消耗1~5ms，当一个异常在应用的多个层级之间传递时，会拖累整个应用的性能。<br>&emsp;&emsp;仅在异常情况下使用异常；在可恢复的异常情况下使用异常；尽管使用异常有利于 Java 开发，但是在应用中最好不要捕获太多的调用栈，因为在很多情况下都不需要打印调用栈就知道哪里出错了。因此，异常消息应该提供恰到好处的信息。</p><h2 id="20-介绍下try-with-resource语法"><a href="#20-介绍下try-with-resource语法" class="headerlink" title="20.介绍下try-with-resource语法"></a>20.介绍下try-with-resource语法</h2><p>&emsp;&emsp;try-with-resources 是 JDK 7 中一个新的异常处理机制，它能够很容易地关闭在 try-catch 语句块中使用的资源。所谓的资源（resource）是指在程序完成后，必须关闭的对象。try-with-resources 语句确保了每个资源在语句结束时关闭。所有实现了 java.lang.AutoCloseable 接口（其中，它包括实现了 java.io.Closeable 的所有对象），可以使用作为资源。</p><p><strong>关闭单个资源</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo03</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span>(<span class="hljs-type">Resource</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Resource</span>()) &#123;<br>            res.doSome();<br>        &#125; <span class="hljs-keyword">catch</span>(Exception ex) &#123;<br>            ex.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Resource</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AutoCloseable</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSome</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;do something&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;resource is closed&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>查看编译后的代码</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1675489386042/f39af94001064f6bb857f1c5fca6c32e.png" alt="image.png"></p><p><strong>关闭多个资源</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo04</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span>(<span class="hljs-type">ResourceSome</span> <span class="hljs-variable">some</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResourceSome</span>();<br>            <span class="hljs-type">ResourceOther</span> <span class="hljs-variable">other</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResourceOther</span>()) &#123;<br>            some.doSome();<br>            other.doOther();<br>        &#125; <span class="hljs-keyword">catch</span>(Exception ex) &#123;<br>            ex.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ResourceSome</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AutoCloseable</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSome</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;do something&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;some resource is closed&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ResourceOther</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AutoCloseable</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">doOther</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;do other things&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;other resource is closed&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译后的代码</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1675489386042/2d3e6eb530034c90a25452afdbc3c094.png" alt="image.png"></p><p>处理规则</p><ol><li>凡是实现了AutoCloseable接口的类，在try()里声明该类实例的时候，在try结束后，close方法都会被调用</li><li>try结束后自动调用的close方法，这个动作会早于finally里调用的方法。</li><li>不管是否出现异常（int i&#x3D;1&#x2F;0会抛出异常），try()里的实例都会被调用close方法</li><li>越晚声明的对象，会越早被close掉。</li></ol><p><strong>JDK9中的改进</strong></p><p>&emsp;&emsp;在 JDK 9 已得到改进。如果你已经有一个资源是 final 或等效于 final 变量,您可以在 try-with-resources 语句中直接使用该变量，而无需在 try-with-resources 语句中声明一个新变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// A final resource</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">Resource</span> <span class="hljs-variable">resource1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Resource</span>(<span class="hljs-string">&quot;resource1&quot;</span>);<br><span class="hljs-comment">// An effectively final resource</span><br><span class="hljs-type">Resource</span> <span class="hljs-variable">resource2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Resource</span>(<span class="hljs-string">&quot;resource2&quot;</span>);<br><span class="hljs-keyword">try</span> (resource1;<br>     resource2) &#123;<br>    <span class="hljs-comment">// 直接使用 resource1 and resource 2.</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>java基础面经</title>
    <link href="/2024/04/08/java%E5%9F%BA%E7%A1%80%E9%9D%A2%E7%BB%8F/"/>
    <url>/2024/04/08/java%E5%9F%BA%E7%A1%80%E9%9D%A2%E7%BB%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="Java基础面试题"><a href="#Java基础面试题" class="headerlink" title="Java基础面试题"></a>Java基础面试题</h1><blockquote></blockquote><h1 id="一、面向对象和集合专题"><a href="#一、面向对象和集合专题" class="headerlink" title="一、面向对象和集合专题"></a>一、面向对象和集合专题</h1><h2 id="1-面向对象和面向过程的区别"><a href="#1-面向对象和面向过程的区别" class="headerlink" title="1. 面向对象和面向过程的区别"></a>1. 面向对象和面向过程的区别</h2><p><strong>面向过程</strong>：是分析解决问题的步骤，然后用函数把这些步骤一步一步地实现，然后在使用的时候一一调用则可。性能较高，所以单片机、嵌入式开发等一般采用面向过程开发</p><p><strong>面向对象</strong>：是把构成问题的事务分解成各个对象，而建立对象的目的也不是为了完成一个个步骤，而是为了描述某个事物在解决整个问题的过程中所发生的行为。面向对象有封装、继承、多态的特性，所以易维护、易复用、易扩展。可以设计出低耦合的系统。 但是性能上来说，比面向过程要低。</p><p>OOP和AOP</p><h2 id="2-介绍下Java中的基本数据类型"><a href="#2-介绍下Java中的基本数据类型" class="headerlink" title="2. 介绍下Java中的基本数据类型"></a>2. 介绍下Java中的基本数据类型</h2><table><thead><tr><th>基本类型</th><th>大小(字节)</th><th>默认值</th><th>封装类</th></tr></thead><tbody><tr><td>byte</td><td>1</td><td>(byte)0</td><td>Byte</td></tr><tr><td>short</td><td>2</td><td>(short)0</td><td>Short</td></tr><tr><td>int</td><td>4</td><td>0</td><td>Integer</td></tr><tr><td>long</td><td>8</td><td>0l</td><td>Long</td></tr><tr><td>float</td><td>4</td><td>0.0f</td><td>Float</td></tr><tr><td>double</td><td>8</td><td>0.0d</td><td>Double</td></tr><tr><td>boolean</td><td>-</td><td>false</td><td>Boolean</td></tr><tr><td>char</td><td>2</td><td>\u0000(null)</td><td>Character</td></tr></tbody></table><p>boolean: int 4个字节</p><p>需要注意：</p><ol><li>int是基本数据类型，Integer是int的封装类，是引用类型。int默认值是0，而Integer默认值是null，所以Integer能区分出0和null的情况。一旦java看到null，就知道这个引用还没有指向某个对象，再任何引用使用前，必须为其指定一个对象，否则会报错。</li><li>基本数据类型在声明时系统会自动给它分配空间，而引用类型声明时只是分配了引用空间，必须通过实例化开辟数据空间之后才可以赋值。数组对象也是一个引用对象，将一个数组赋值给另一个数组时只是复制了一个引用，所以通过某一个数组所做的修改在另一个数组中也看的见。虽然定义了boolean这种数据类型，但是只对它提供了非常有限的支持。在Java虚拟机中没有任何供boolean值专用的字节码指令，Java语言表达式所操作的boolean值，在编译之后都使用Java虚拟机中的int数据类型来代替，而boolean数组将会被编码成Java虚拟机的byte数组，每个元素boolean元素占8位。这样我们可以得出boolean类型占了单独使用是4个字节，在数组中又是1个字节。使用int的原因是，对于当下32位的处理器（CPU）来说，一次处理数是32位（这里不是指的是32&#x2F;64位系统，而是指CPU硬件层面），具有高效存取的特点。</li></ol><h2 id="3-标识符的命名规则"><a href="#3-标识符的命名规则" class="headerlink" title="3. 标识符的命名规则"></a>3. 标识符的命名规则</h2><p><strong>标识符的含义</strong>： 是指在程序中，我们自己定义的内容，譬如，类的名字，方法名称以及变量名称等等，都是标识符。</p><p><strong>命名规则</strong>：（硬性要求） 标识符可以包含<strong>英文字母</strong>，<strong>0-9的数字</strong>，**$<strong>以及</strong>_** 标识符不能以数字开头，标识符不是关键字<br><strong>命名规范</strong>：（非硬性要求） 类名规范：首字符大写，后面每个单词首字母大写（大驼峰式）。 变量名规范：首字母小写，后面每个单词首字母大写（小驼峰式）。 方法名规范：同变量名。</p><h2 id="4-instanceof关键字的作用"><a href="#4-instanceof关键字的作用" class="headerlink" title="4. instanceof关键字的作用"></a>4. instanceof关键字的作用</h2><p>instanceof 严格来说是Java中的一个双目运算符，用来测试一个对象是否为一个类的实例，用法<br>为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> obj <span class="hljs-keyword">instanceof</span> Class<br></code></pre></td></tr></table></figure><p>其中 obj 为一个对象，Class 表示一个类或者一个接口，当 obj 为 Class 的对象，或者是其直接或间接子类，或者是其接口的实现类，结果result 都返回 true，否则返回false。<br><strong>注意</strong>：编译器会检查 obj 是否能转换成右边的class类型，如果不能转换则直接报错，如果不能确定类型，则通过编译，具体看运行时定。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(i instanceof <span class="hljs-type">Integer</span>);//编译不通过 i必须是引用类型，不能是基本类型<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(i instanceof <span class="hljs-keyword">Object</span>);//编译不通过<br><br><span class="hljs-type">Integer</span> <span class="hljs-type">integer</span> = <span class="hljs-built_in">new</span> <span class="hljs-type">Integer</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-type">integer</span> instanceof <span class="hljs-type">Integer</span>);//<span class="hljs-keyword">true</span><br><br>//<span class="hljs-keyword">false</span> ,在 JavaSE规范 中对 instanceof 运算符的规定就是：如果 obj 为 <span class="hljs-keyword">null</span>，那么将返回 <span class="hljs-keyword">false</span>。<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">null</span> instanceof <span class="hljs-keyword">Object</span>);<br></code></pre></td></tr></table></figure><h2 id="5-重载和重写的区别"><a href="#5-重载和重写的区别" class="headerlink" title="5.重载和重写的区别"></a>5.重载和重写的区别</h2><p><strong>重写(Override)</strong><br>&emsp;&emsp;从字面上看，重写就是 重新写一遍的意思。其实就是在子类中把父类本身有的方法重新写一遍。子类继承了父类原有的方法，但有时子类并不想原封不动的继承父类中的某个方法，所以在方法名，参数列表，返回类型(除过子类中方法的返回值是父类中方法返回值的子类时)都相同的情况下， 对方法体进行修改或重写，这就是重写。但要注意子类函数的访问修饰权限不能少于父类的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span> &#123;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br> <span class="hljs-comment">// TODO Auto-generated method stub</span><br> <span class="hljs-type">Son</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Son</span>();<br> s.sayHello();<br> &#125;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span> &#123;<br> System.out.println(<span class="hljs-string">&quot;Hello&quot;</span>);<br> &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Father</span>&#123;<br> <span class="hljs-meta">@Override</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span> &#123;<br> <span class="hljs-comment">// TODO Auto-generated method stub</span><br> System.out.println(<span class="hljs-string">&quot;hello by &quot;</span>);<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>重写 总结：</p><ol><li>发生在父类与子类之间</li><li>方法名，参数列表，返回类型（除过子类中方法的返回类型是父类中返回类型的子类）必须相同</li><li>访问修饰符的限制一定要大于被重写方法的访问修饰符（public&gt;protected&gt;default&gt;private)</li><li>重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常</li></ol><p><strong>重载（Overload）</strong></p><p>&emsp;&emsp;在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同甚至是参数顺序不同）则视为重载。同时，重载对返回类型没有要求，可以相同也可以不同，但不能通过返回类型是否相同来判断重载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span> &#123;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br> <span class="hljs-comment">// TODO Auto-generated method stub</span><br> <span class="hljs-type">Father</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Father</span>();<br> s.sayHello();<br> s.sayHello(<span class="hljs-string">&quot;wintershii&quot;</span>);<br> &#125;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span> &#123;<br> System.out.println(<span class="hljs-string">&quot;Hello&quot;</span>);<br> &#125;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">(String name)</span> &#123;<br> System.out.println(<span class="hljs-string">&quot;Hello&quot;</span> + <span class="hljs-string">&quot; &quot;</span> + name);<br> &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>重载 总结：</p><ol><li>重载Overload是一个类中多态性的一种表现</li><li>重载要求同名方法的参数列表不同(参数类型，参数个数甚至是参数顺序)</li><li>重载的时候，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准</li></ol><h2 id="6-介绍下内部类"><a href="#6-介绍下内部类" class="headerlink" title="6.介绍下内部类"></a>6.介绍下内部类</h2><p>目的：提高安全性</p><p>在Java中，可以将一个类定义在另一个类里面或者一个方法里面，这样的类称为内部类。广泛意义上的内部类一般来说包括这三种：成员内部类、局部内部类、匿名内部类，如下图所示：</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1675489386042/8968036e5ec5472aa32090fa2260eb0a.png" alt="image.png"></p><h2 id="7-介绍下Java中的四种引用"><a href="#7-介绍下Java中的四种引用" class="headerlink" title="7.介绍下Java中的四种引用"></a>7.介绍下Java中的四种引用</h2><p><strong>强引用</strong><br>&emsp;&emsp;强引用是平常中使用最多的引用，强引用在程序内存不足（OOM）的时候也不会被回收，使用<br>方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;str&quot;</span>);<br>System.out.println(str);<br></code></pre></td></tr></table></figure><p><strong>软引用</strong><br>&emsp;&emsp;软引用在程序内存不足时，会被回收，使用方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 注意：wrf这个引用也是强引用，它是指向SoftReference这个对象的，</span><br><span class="hljs-comment">// 这里的软引用指的是指向new String(&quot;str&quot;)的引用，也就是SoftReference类中T</span><br>SoftReference&lt;String&gt; wrf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SoftReference</span>&lt;String&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;str&quot;</span>));<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;可用场景： 创建缓存的时候，创建的对象放进缓存中，当内存不足时，JVM就会回收早先创建的对象。<br><strong>弱引用</strong><br>&emsp;&emsp;弱引用就是只要JVM垃圾回收器发现了它，就会将之回收，使用方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">WeakReference&lt;String&gt; wrf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>&lt;String&gt;(str);<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;可用场景： Java源码中的 java.util.WeakHashMap 中的 key 就是使用弱引用，我的理解就是，一旦我不需要某个引用，JVM会自动帮我处理它，这样我就不需要做其它操作。<br><strong>虚引用</strong><br>&emsp;&emsp;虚引用的回收机制跟弱引用差不多，但是它被回收之前，会被放入 ReferenceQueue 中。注意哦，其它引用是被JVM回收后才被传入 ReferenceQueue 中的。由于这个机制，所以虚引用大多被用于引用销毁前的处理工作。还有就是，虚引用创建的时候，必须带有 ReferenceQueue ，使用例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">PhantomReference&lt;String&gt; prf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PhantomReference</span>&lt;String&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;str&quot;</span>),<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceQueue</span>&lt;&gt;());<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;可用场景： 对象销毁前的一些操作，比如说资源释放等。 Object.finalize() 虽然也可以做这类动作，但是这个方式即不安全又低效<br>&emsp;&emsp;上诉所说的几类引用，都是指对象本身的引用，而不是指Reference的四个子类的引用(SoftReference等)。</p><h2 id="8-HashCode的作用"><a href="#8-HashCode的作用" class="headerlink" title="8.HashCode的作用"></a>8.HashCode的作用</h2><p>&emsp;&emsp;java的集合有两类，一类是List，还有一类是Set。前者有序可重复，后者无序不重复。当我们在set中插入的时候怎么判断是否已经存在该元素呢，可以通过equals方法。但是如果元素太多，用这样的方法就会比较满。于是有人发明了哈希算法来提高集合中查找元素的效率。 这种方式将集合分成若干个存储区域，每个对象可以计算出一个哈希码，可以将哈希码分组，每组分别对应某个存储区域，根据一个对象的哈希码就可以确定该对象应该存储的那个区域。hashCode方法可以这样理解：它返回的就是根据对象的内存地址换算出的一个值。这样一来，当集合要添加新的元素时，先调用这个元素的hashCode方法，就一下子能定位到它应该放置的物理位置上。如果这个位置上没有元素，它就可以直接存储在这个位置上，不用再进行任何比较了；如果这个位置上已经有元素了，就调用它的equals方法与新元素进行比较，相同的话就不存了，不相同就散列其它的地址。这样一来实际调用equals方法的次数就大大降低了，几乎只需要一两次。</p><h2 id="9-有没有可能两个不相等的对象有相同的hashcode"><a href="#9-有没有可能两个不相等的对象有相同的hashcode" class="headerlink" title="9.有没有可能两个不相等的对象有相同的hashcode"></a>9.有没有可能两个不相等的对象有相同的hashcode</h2><p>能.在产生hash冲突时,两个不相等的对象就会有相同的 hashcode 值.当hash冲突产生时,一般<br>有以下几种方式来处理:</p><ul><li>拉链法:每个哈希表节点都有一个next指针,多个哈希表节点可以用next指针构成一个单向链<br>表，被分配到同一个索引上的多个节点可以用这个单向链表进行存储.</li><li>开放定址法:一旦发生了冲突,就去寻找下一个空的散列地址,只要散列表足够大,空的散列地址总<br>能找到,并将记录存入</li><li>再哈希:又叫双哈希法,有多个不同的Hash函数.当发生冲突时,使用第二个,第三个….等哈希函数<br>计算地址,直到无冲突</li></ul><h2 id="10-深拷贝和浅拷贝的区别是什么"><a href="#10-深拷贝和浅拷贝的区别是什么" class="headerlink" title="10.深拷贝和浅拷贝的区别是什么?"></a>10.深拷贝和浅拷贝的区别是什么?</h2><p>原型模式：设计模式 –&gt; Spring bean的Scope</p><p><strong>浅拷贝</strong>:被复制对象的所有变量都含有与原来的对象相同的值,而所有的对其他对象的引用仍然指<br>向原来的对象.换言之,浅拷贝仅仅复制所考虑的对象,而不复制它所引用的对象.</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1675489386042/d063a0a305a34ea18fcfb8c1aeb80b66.png" alt="image.png"></p><p><strong>深拷贝</strong>:被复制对象的所有变量都含有与原来的对象相同的值.而那些引用其他对象的变量将指向<br>被复制过的新对象.而不再是原有的那些被引用的对象.换言之.深拷贝把要复制的对象所引用的<br>对象都复制了一遍.</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1675489386042/2c56eb2723ee4cec85b2b36a8b77d167.png" alt="image.png"></p><h2 id="11-static都有哪些用法"><a href="#11-static都有哪些用法" class="headerlink" title="11.static都有哪些用法?"></a>11.static都有哪些用法?</h2><p>&emsp;&emsp;所有的人都知道static关键字这两个基本的用法:静态变量和静态方法.也就是被static所修饰的变量&#x2F;<br>方法都属于类的静态资源,类实例所共享.<br>&emsp;&emsp;除了静态变量和静态方法之外,static也用于静态块,多用于初始化操作:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> calss PreCache&#123;<br> <span class="hljs-keyword">static</span>&#123;<br> <span class="hljs-comment">//执行相关操作</span><br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>&emsp;&emsp;此外static也多用于修饰内部类,此时称之为静态内部类.<br>&emsp;&emsp;最后一种用法就是静态导包,即 import static .import static是在JDK 1.5之后引入的新特性,可以用<br>来指定导入某个类中的静态资源,并且不需要使用类名,可以直接使用资源名,比如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> java.lang.Math.*;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br> <span class="hljs-comment">//System.out.println(Math.sin(20));传统做法</span><br> System.out.println(sin(<span class="hljs-number">20</span>));<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="12-介绍下Object中的常用方法"><a href="#12-介绍下Object中的常用方法" class="headerlink" title="12. 介绍下Object中的常用方法"></a>12. 介绍下Object中的常用方法</h2><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1675489386042/33ec904f252a4c149d45179b99477395.png" alt="image.png"></p><p><strong>clone 方法</strong><br>&emsp;&emsp;保护方法，实现对象的浅复制，只有实现了 Cloneable 接口才可以调用该方法，否则抛出<br>CloneNotSupportedException 异常，深拷贝也需要实现 Cloneable，同时其成员变量为引用类型<br>的也需要实现 Cloneable，然后重写 clone 方法。</p><p><strong>finalize 方法</strong></p><p>&emsp;&emsp;该方法和垃圾收集器有关系，判断一个对象是否可以被回收的最后一步就是判断是否重写了此方<br>法。</p><p><strong>equals 方法</strong><br>&emsp;&emsp;该方法使用频率非常高。一般 equals 和 &#x3D;&#x3D; 是不一样的，但是在 Object 中两者是一样的。子类一<br>般都要重写这个方法。</p><p><strong>hashCode 方法</strong><br>&emsp;&emsp;该方法用于哈希查找，重写了 equals 方法一般都要重写 hashCode 方法，这个方法在一些具有哈<br>希功能的 Collection 中用到。<br>&emsp;&emsp;一般必须满足 obj1.equals(obj2)&#x3D;&#x3D;true 。可以推出 obj1.hashCode()&#x3D;&#x3D;obj2.hashCode() ，但是<br>hashCode 相等不一定就满足 equals。不过为了提高效率，应该尽量使上面两个条件接近等价。</p><ul><li>JDK 1.6、1.7 默认是返回随机数；</li><li>JDK 1.8 默认是通过和当前线程有关的一个随机数 + 三个确定值，运用 Marsaglia’s xorshift<br>scheme 随机数算法得到的一个随机数。</li></ul><p><strong>wait 方法</strong></p><p>&emsp;&emsp;配合 synchronized 使用，wait 方法就是使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。wait() 方法一直等待，直到获得锁或者被中断。wait(long timeout)设定一个超时间隔，如果在规定时间内没有获得锁就返回。<br>调用该方法后当前线程进入睡眠状态，直到以下事件发生。</p><ol><li>其他线程调用了该对象的 notify 方法；</li><li>其他线程调用了该对象的 notifyAll 方法；</li><li>其他线程调用了 interrupt 中断该线程；</li><li>时间间隔到了。<br>此时该线程就可以被调度了，如果是被中断的话就抛出一个 InterruptedException 异常。</li></ol><p><strong>notify 方法</strong><br>&emsp;&emsp;配合 synchronized 使用，该方法唤醒在该对象上等待队列中的某个线程（同步队列中的线程是给抢占 CPU 的线程，等待队列中的线程指的是等待唤醒的线程）。<br><strong>notifyAll 方法</strong><br>&emsp;&emsp;配合 synchronized 使用，该方法唤醒在该对象上等待队列中的所有线程。<br><strong>总结</strong><br>&emsp;&emsp;只要把上面几个方法熟悉就可以了，toString 和 getClass 方法可以不用去讨论它们。该题目考察的是对 Object 的熟悉程度，平时用的很多方法并没看其定义但是也在用，比如说：wait() 方法，equals() 方法等。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">Class Object is the root of the class hierarchy.Every class has Object as a<br>superclass. All objects, including arrays, implement the methods of this class.<br></code></pre></td></tr></table></figure><p>大致意思：Object 是所有类的根，是所有类的父类，所有对象包括数组都实现了 Object 的方法。</p><h2 id="13-Java-创建对象有几种方式？"><a href="#13-Java-创建对象有几种方式？" class="headerlink" title="13.Java 创建对象有几种方式？"></a>13.Java 创建对象有几种方式？</h2><p><strong>new 关键字</strong></p><p>&emsp;&emsp;平时使用的最多的创建对象方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">User user=<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br></code></pre></td></tr></table></figure><p><strong>反射方式</strong></p><p>&emsp;&emsp;使用 newInstance()，但是得处理两个异常 InstantiationException、IllegalAccessException：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">User user=User.class.newInstance();<br>Object object=(Object)Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>).newInstance()<br></code></pre></td></tr></table></figure><p><strong>clone方法</strong></p><p>&emsp;&emsp;Object对象中的clone方法来完成这个操作</p><p><strong>反序列化操作</strong></p><p>&emsp;&emsp;调用 ObjectInputStream 类的 readObject() 方法。我们反序列化一个对象，JVM 会给我们创建一个单独的对象。JVM 创建对象并不会调用任何构造函数。一个对象实现了 Serializable 接口，就可以把对象写入到文中，并通过读取文件来创建对象。</p><p><strong>总结</strong><br>&emsp;&emsp;创建对象的方式关键字：new、反射、clone 拷贝、反序列化。</p><h2 id="14-有了数组为什么还要再搞一个ArrayList呢？"><a href="#14-有了数组为什么还要再搞一个ArrayList呢？" class="headerlink" title="14.有了数组为什么还要再搞一个ArrayList呢？"></a>14.有了数组为什么还要再搞一个ArrayList呢？</h2><p>&emsp;&emsp;通常我们在使用的时候，如果在不明确要插入多少数据的情况下，普通数组就很尴尬了，因为你不知道需要初始化数组大小为多少，而 ArrayList 可以使用默认的大小，当元素个数到达一定程度后，会自动扩容。<br>&emsp;&emsp;可以这么来理解：我们常说的数组是定死的数组，ArrayList 却是动态数组。</p><h2 id="15-说说什么是-fail-fast？"><a href="#15-说说什么是-fail-fast？" class="headerlink" title="15. 说说什么是 fail-fast？"></a>15. 说说什么是 fail-fast？</h2><p><strong>&emsp;&emsp;fail-fast</strong> 机制是 Java 集合（Collection）中的一种错误机制。当多个线程对同一个集合的内容进行操作时，就可能会产生 fail-fast 事件。<br>&emsp;&emsp;例如：当某一个线程 A 通过 iterator 去遍历某集合的过程中，若该集合的内容被其他线程所改变了，那么线程 A 访问集合时，就会抛出 ConcurrentModificationException 异常，产生 fail-fast 事件。这里的操作主要是指 add、remove 和 clear，对集合元素个数进行修改。<br><strong>&emsp;&emsp;解决办法</strong>：建议使用“java.util.concurrent 包下的类”去取代“java.util 包下的类”。可以这么理解：在遍历之前，把 modCount 记下来 expectModCount，后面 expectModCount 去和 modCount 进行比较，如果不相等了，证明已并发了，被修改了，于是抛出ConcurrentModificationException 异常。</p><h2 id="16-介绍下你对Java集合的理解"><a href="#16-介绍下你对Java集合的理解" class="headerlink" title="16.介绍下你对Java集合的理解"></a>16.介绍下你对Java集合的理解</h2><p>&emsp;&emsp;集合是我们在工作中使用频率非常高的组件了。下面的两张图是集合框架的类图结构。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1675489386042/78abc041848d4ac0ab959ae32cea7598.png" alt="image.png"></p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1675489386042/b4ee8f50d3d448adbcde7e3ad4dd72dd.png" alt="image.png"></p><p>TreeSet的本质是TreeMap</p><p>HashSet的本质是HashMap</p><h2 id="17-介绍下你对红黑树的理解"><a href="#17-介绍下你对红黑树的理解" class="headerlink" title="17.介绍下你对红黑树的理解"></a>17.介绍下你对红黑树的理解</h2><p>红黑树的特点：</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1675489386042/fc0214f69d974e18bfa466511efe2f2e.png" alt="image.png"></p><p>红黑色的本质：2-3-4树</p><p>红黑树保证黑节点平衡的方式:左旋&#x2F;右旋+变色 来保证</p><h2 id="18-try-finally中的return关键字"><a href="#18-try-finally中的return关键字" class="headerlink" title="18. try-finally中的return关键字"></a>18. try-finally中的return关键字</h2><p>return语句的本质：</p><ol><li>return语句获取到变量的地址</li><li>return将获取的地址返回，也就是return本质是传地址</li></ol><p>测试案例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Too too=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Too</span>();<br>        StringBuilder t1=test(too);<br>        System.out.println(<span class="hljs-string">&quot;return语句返回的:&quot;</span>+t1+<span class="hljs-string">&quot;\t返回值的hashCode:&quot;</span>+t1.hashCode());<br>        System.out.println(<span class="hljs-string">&quot;finaly里面修改的:&quot;</span>+too.num+<span class="hljs-string">&quot;\tfinaly的hashCode:&quot;</span>+too.num.hashCode());<br><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> StringBuilder <span class="hljs-title function_">test</span><span class="hljs-params">(Too too)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            too.num=<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;try&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;try字符串的hashcode:&quot;</span>+(<span class="hljs-string">&quot;try&quot;</span>).hashCode());<br>            System.out.println(<span class="hljs-string">&quot;StringBuilder里的try的hashCode:&quot;</span>+too.num.hashCode());<span class="hljs-comment">//--语句1</span><br>            <span class="hljs-keyword">return</span> too.num; <span class="hljs-comment">//语句2</span><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            too.num=<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;finaly&quot;</span>);<span class="hljs-comment">//语句3</span><br>            System.out.println(<span class="hljs-string">&quot;finaly的hashCode:&quot;</span>+too.num.hashCode());<span class="hljs-comment">//语句4</span><br>        &#125;&#125;&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Too</span>&#123;<br>    StringBuilder num=<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;你好&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs txt">try字符串的hashcode:115131<br>StringBuilder里的try的hashCode:460141958<br>finaly的hashCode:1163157884<br>return语句返回的:try返回值的hashCode:460141958<br>finaly里面修改的:finalyfinaly的hashCode:1163157884<br></code></pre></td></tr></table></figure><h2 id="19-异常处理影响性能吗"><a href="#19-异常处理影响性能吗" class="headerlink" title="19.异常处理影响性能吗"></a>19.异常处理影响性能吗</h2><p>&emsp;&emsp;异常处理的性能成本非常高，每个 Java 程序员在开发时都应牢记这句话。创建一个异常非常慢，抛出一个异常又会消耗1~5ms，当一个异常在应用的多个层级之间传递时，会拖累整个应用的性能。<br>&emsp;&emsp;仅在异常情况下使用异常；在可恢复的异常情况下使用异常；尽管使用异常有利于 Java 开发，但是在应用中最好不要捕获太多的调用栈，因为在很多情况下都不需要打印调用栈就知道哪里出错了。因此，异常消息应该提供恰到好处的信息。</p><h2 id="20-介绍下try-with-resource语法"><a href="#20-介绍下try-with-resource语法" class="headerlink" title="20.介绍下try-with-resource语法"></a>20.介绍下try-with-resource语法</h2><p>&emsp;&emsp;try-with-resources 是 JDK 7 中一个新的异常处理机制，它能够很容易地关闭在 try-catch 语句块中使用的资源。所谓的资源（resource）是指在程序完成后，必须关闭的对象。try-with-resources 语句确保了每个资源在语句结束时关闭。所有实现了 java.lang.AutoCloseable 接口（其中，它包括实现了 java.io.Closeable 的所有对象），可以使用作为资源。</p><p><strong>关闭单个资源</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo03</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span>(<span class="hljs-type">Resource</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Resource</span>()) &#123;<br>            res.doSome();<br>        &#125; <span class="hljs-keyword">catch</span>(Exception ex) &#123;<br>            ex.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Resource</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AutoCloseable</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSome</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;do something&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;resource is closed&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>查看编译后的代码</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1675489386042/f39af94001064f6bb857f1c5fca6c32e.png" alt="image.png"></p><p><strong>关闭多个资源</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo04</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span>(<span class="hljs-type">ResourceSome</span> <span class="hljs-variable">some</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResourceSome</span>();<br>            <span class="hljs-type">ResourceOther</span> <span class="hljs-variable">other</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResourceOther</span>()) &#123;<br>            some.doSome();<br>            other.doOther();<br>        &#125; <span class="hljs-keyword">catch</span>(Exception ex) &#123;<br>            ex.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ResourceSome</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AutoCloseable</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSome</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;do something&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;some resource is closed&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ResourceOther</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AutoCloseable</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">doOther</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;do other things&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;other resource is closed&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译后的代码</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1675489386042/2d3e6eb530034c90a25452afdbc3c094.png" alt="image.png"></p><p>处理规则</p><ol><li>凡是实现了AutoCloseable接口的类，在try()里声明该类实例的时候，在try结束后，close方法都会被调用</li><li>try结束后自动调用的close方法，这个动作会早于finally里调用的方法。</li><li>不管是否出现异常（int i&#x3D;1&#x2F;0会抛出异常），try()里的实例都会被调用close方法</li><li>越晚声明的对象，会越早被close掉。</li></ol><p><strong>JDK9中的改进</strong></p><p>&emsp;&emsp;在 JDK 9 已得到改进。如果你已经有一个资源是 final 或等效于 final 变量,您可以在 try-with-resources 语句中直接使用该变量，而无需在 try-with-resources 语句中声明一个新变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// A final resource</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">Resource</span> <span class="hljs-variable">resource1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Resource</span>(<span class="hljs-string">&quot;resource1&quot;</span>);<br><span class="hljs-comment">// An effectively final resource</span><br><span class="hljs-type">Resource</span> <span class="hljs-variable">resource2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Resource</span>(<span class="hljs-string">&quot;resource2&quot;</span>);<br><span class="hljs-keyword">try</span> (resource1;<br>     resource2) &#123;<br>    <span class="hljs-comment">// 直接使用 resource1 and resource 2.</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="一、IO和多线程专题"><a href="#一、IO和多线程专题" class="headerlink" title="一、IO和多线程专题"></a>一、IO和多线程专题</h1><h2 id="1-介绍下进程和线程的关系"><a href="#1-介绍下进程和线程的关系" class="headerlink" title="1.介绍下进程和线程的关系"></a>1.介绍下进程和线程的关系</h2><p><strong>进程</strong>：一个独立的正在执行的程序</p><p><strong>线程</strong>：一个进程的最基本的执行单位，执行路径</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1675489410098/9e9ec3ca030d4c229a7f76ce5fdf650d.png" alt="image.png"></p><p><strong>多进程</strong>：在操作系统中，同时运行多个程序</p><p>多进程的好处：可以充分利用CPU，提高CPU的使用率</p><p><strong>多线程：在同一个进程(应用程序)中同时执行多个线程</strong></p><p>多线程的好处：提高进程的执行使用率，提高了CPU的使用率</p><p><strong>注意：</strong></p><ol><li>在同一个时间点一个CPU中只可能有一个线程在执行</li><li>多线程不能提高效率、反而会降低效率，但是可以提高CPU的使用率</li><li>一个进程如果有多条执行路径，则称为多线程程序</li><li>Java虚拟机的启动至少开启了两条线程，主线程和垃圾回收线程</li><li>一个线程可以理解为进程的子任务</li></ol><h2 id="2-说说Java中实现多线程的几种方法"><a href="#2-说说Java中实现多线程的几种方法" class="headerlink" title="2.说说Java中实现多线程的几种方法"></a>2.说说Java中实现多线程的几种方法</h2><p>Thread对象就是一个线程</p><p>创建线程的常用三种方式：</p><ol><li>继承Thread类</li><li>实现Runnable接口</li><li>实现Callable接口（JDK1.5&gt;&#x3D;）</li><li>线程池方式创建</li></ol><p>&emsp;&emsp;通过继承Thread类或者实现Runnable接口、Callable接口都可以实现多线程，不过实现Runnable<br>接口与实现Callable接口的方式基本相同，只是Callable接口里定义的方法返回值，可以声明抛出异<br>常而已。因此将实现Runnable接口和实现Callable接口归为一种方式。这种方式与继承Thread方式<br>之间的主要差别如下。</p><p><strong>继承Thread类</strong></p><p>实现的步骤：</p><ol><li>创建Thread类的子类</li><li>重写run方法</li><li>创建线程对象</li><li>启动线程</li></ol><p>案例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.thread;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadDemo02</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 线程的第一种实现方式</span><br><span class="hljs-comment">     *     通过创建Thread类的子类来实现</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> args</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;main方法执行了1...&quot;</span>);<br>        <span class="hljs-comment">// Java中的线程 本质上就是一个Thread对象</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadTest01</span>();<br>        <span class="hljs-comment">// 启动一个新的线程</span><br>        t1.start();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i&lt; <span class="hljs-number">100</span> ; i++)&#123;<br>            System.out.println(<span class="hljs-string">&quot;main方法的循环...&quot;</span>+i);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;main方法执行结束了3...&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 第一个自定义的线程类</span><br><span class="hljs-comment"> *    继承Thread父类</span><br><span class="hljs-comment"> *    重写run方法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadTest01</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;我们的第一个线程执行了2....&quot;</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">10</span> ; i ++)&#123;<br>            System.out.println(<span class="hljs-string">&quot;子线程：&quot;</span>+i);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>注意点：</strong></p><ol><li>启动线程是使用start方法而不是run方法</li><li>线程不能启动多次，如果要创建多个线程，那么就需要创建多个Thread对象</li></ol><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1675489410098/f67f195218b34242a452df52c27a8db0.png" alt="image.png"></p><p><strong>实现Runnable接口</strong></p><p>&emsp;&emsp;在第一种实现方式中，我们是将线程的创建和线程执行的业务都封装在了Thread对象中，我们可以通过Runable接口来实现线程程序代码和数据有效的分离。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Thread(Runnable target)<br><span class="hljs-comment">// 分配一个新的 Thread对象。</span><br></code></pre></td></tr></table></figure><p>实现的步骤：</p><ol><li>创建Runable的实现类</li><li>重写run方法</li><li>创建Runable实例对象(通过实现类来实现)</li><li>创建Thread对象，并把第三部的Runable实现作为Thread构造方法的参数</li><li>启动线程</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.runable;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RunableDemo01</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 线程的第二种方式</span><br><span class="hljs-comment">     *     本质是创建Thread对象的时候传递了一个Runable接口实现</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> args</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;main执行了...&quot;</span>);<br>        <span class="hljs-comment">// 创建一个新的线程  Thread对象</span><br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">r1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RunableTest</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r1);<br>        <span class="hljs-comment">// 启动线程</span><br>        t1.start();<br>        System.out.println(<span class="hljs-string">&quot;main结束了...&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 线程的第二种创建方式</span><br><span class="hljs-comment"> *   创建一个Runable接口的实现类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RunableTest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;子线程执行了...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现Runable接口的好处：</p><ol><li>可以避免Java单继承带来的局限性</li><li>适合多个相同的程序代码处理同一个资源的情况，把线程同程序的代码和数据有效的分离，较好的体现了面向对象的设计思想</li></ol><p><strong>Callable的方式</strong></p><p>&emsp;&emsp;前面我们介绍的两种创建线程的方式都是重写run方法，而且run方法是没有返回结果的，也就是main方法是不知道开启的线程什么时候开始执行，什么时候结束执行，也获取不到对应的返回结果。而且run方法也不能把可能产生的异常抛出。在JDK1.5之后推出了通过实现Callable接口的方式来创建新的线程，这种方式可以获取对应的返回结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.callable;<br><br><span class="hljs-keyword">import</span> java.util.concurrent.Callable;<br><span class="hljs-keyword">import</span> java.util.concurrent.FutureTask;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CallableDemo01</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建线程的第三种实现方式：</span><br><span class="hljs-comment">     *    Callable方式</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span>  Exception &#123;<br>        <span class="hljs-comment">// 创建一个Callable实例</span><br>        Callable&lt;Integer&gt; callable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>();<br>        FutureTask&lt;Integer&gt; futureTask = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(callable);<br>        <span class="hljs-comment">// 获取一个线程 肯定是要先创建一个Thread对象  futureTask本质上是Runable接口的实现</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(futureTask);<br>        System.out.println(<span class="hljs-string">&quot;main方法start....&quot;</span>);<br>        t1.start(); <span class="hljs-comment">// 本质还是执行的 Runable中的run方法，只是 run方法调用了call方法罢了</span><br>        <span class="hljs-comment">// 获取返回的结果</span><br>        System.out.println(futureTask.get()); <span class="hljs-comment">// 获取开启的线程执行完成后返回的结果</span><br>        System.out.println(<span class="hljs-string">&quot;main方法end ....&quot;</span>);<br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 创建Callable的实现类</span><br><span class="hljs-comment"> *    我们需要指定Callable的泛型，这个泛型是返回结果的类型</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;Integer&gt;&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 线程自动后会执行的方法</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> ; i &lt;= <span class="hljs-number">100</span> ; i ++)&#123;<br>            sum += i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>实现Runnable接口和实现Callable接口的区别:</p><ol><li>Runnable是自从java1.1就有了，而Callable是1.5之后才加上去的</li><li>Callable规定的方法是call(),Runnable规定的方法是run()</li><li>Callable的任务执行后可返回值，而Runnable的任务是不能返回值(是void)</li><li>call方法可以抛出异常，run方法不可以</li><li>运行Callable任务可以拿到一个Future对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。</li><li>加入线程池运行，Runnable使用ExecutorService的execute方法，Callable使用submit方法。</li></ol><p>其实Callable接口底层的实现就是对Runable接口实现的封装，线程启动执行的也是Runable接口实现中的run方法，只是在run方法中有调用call方法罢了</p><h2 id="3-如何停止一个正在运行的线程"><a href="#3-如何停止一个正在运行的线程" class="headerlink" title="3.如何停止一个正在运行的线程"></a>3.如何停止一个正在运行的线程</h2><p><strong>设置标志位</strong>：如果线程的run方法中执行的是一个重复执行的循环，可以提供一个标记来控制循环是否继续</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FunDemo02</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 练习2：设计一个线程：运行10秒后被终止(掌握线程的终止方法)</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> args</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>  <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">MyRunable02</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunable02</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(runnable).start();<br>        Thread.sleep(<span class="hljs-number">10000</span>); <span class="hljs-comment">// 主线程休眠10秒钟</span><br>        runnable.flag = <span class="hljs-literal">false</span>;<br>        System.out.println(<span class="hljs-string">&quot;main、  end ...&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunable02</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span>(flag)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>                System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 执行完成&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>利用中断标志位</strong>： 在线程中有个中断的标志位，默认是false，当我们显示的调用 interrupted方法或者isInterrupted方法是会修改标志位为true。我们可以利用此来中断运行的线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.fundemo;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FunDemo07</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FunDemo07</span>();<br>        t1.start();<br>        Thread.sleep(<span class="hljs-number">3000</span>);<br>         t1.interrupt(); <span class="hljs-comment">// 中断线程 将中断标志由false修改为了true</span><br>        <span class="hljs-comment">// t1.stop(); // 直接就把线程给kill掉了</span><br>        System.out.println(<span class="hljs-string">&quot;main .... &quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-built_in">this</span>.getName() + <span class="hljs-string">&quot; start...&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ;<br>        <span class="hljs-comment">// Thread.interrupted() 如果没有被中断 那么是false 如果显示的执行了interrupt 方法就会修改为 true</span><br>        <span class="hljs-keyword">while</span>(!Thread.interrupted())&#123;<br>            System.out.println(<span class="hljs-built_in">this</span>.getName() + <span class="hljs-string">&quot; &quot;</span> + i);<br>            i++;<br>        &#125;<br><br>        System.out.println(<span class="hljs-built_in">this</span>.getName()+ <span class="hljs-string">&quot; end .... &quot;</span>);<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>利用InterruptedException：</strong> 如果线程因为执行join(),sleep()或者wait()而进入阻塞状态，此时要想停止它，可以让他调用interrupt(),程序会抛出InterruptedException异常。我们利用这个异常可以来终止线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FunDemo08</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FunDemo08</span>();<br>        t1.start();<br>        Thread.sleep(<span class="hljs-number">3000</span>);<br>         t1.interrupt(); <span class="hljs-comment">// 中断线程 将中断标志由false修改为了true</span><br>        <span class="hljs-comment">// t1.stop(); // 直接就把线程给kill掉了</span><br>        System.out.println(<span class="hljs-string">&quot;main .... &quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-built_in">this</span>.getName() + <span class="hljs-string">&quot; start...&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ;<br>        <span class="hljs-comment">// Thread.interrupted() 如果没有被中断 那么是false 如果显示的执行了interrupt 方法就会修改为 true</span><br>         <span class="hljs-keyword">while</span>(!Thread.interrupted())&#123;<br>        <span class="hljs-comment">//while(!Thread.currentThread().isInterrupted())&#123;</span><br>             <span class="hljs-keyword">try</span> &#123;<br>                 Thread.sleep(<span class="hljs-number">10000</span>);<br>             &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                 e.printStackTrace();<br> <span class="hljs-keyword">break</span>;<br>             &#125;<br>             System.out.println(<span class="hljs-built_in">this</span>.getName() + <span class="hljs-string">&quot; &quot;</span> + i);<br>            i++;<br>        &#125;<br><br>        System.out.println(<span class="hljs-built_in">this</span>.getName()+ <span class="hljs-string">&quot; end .... &quot;</span>);<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="4-介绍下线程中的常用方法"><a href="#4-介绍下线程中的常用方法" class="headerlink" title="4.介绍下线程中的常用方法"></a>4.介绍下线程中的常用方法</h2><h3 id="1-start方法"><a href="#1-start方法" class="headerlink" title="1.start方法"></a>1.start方法</h3><p>start方法是我们开启一个新的线程的方法，但是并不是直接开启，而是告诉CPU我已经准备好了，快点运行我，这是启动一个线程的唯一入口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span><span class="hljs-title function_">start</span><span class="hljs-params">()</span><br><span class="hljs-comment">// 导致此线程开始执行; Java虚拟机调用此线程的run方法。</span><br></code></pre></td></tr></table></figure><h3 id="2-run方法"><a href="#2-run方法" class="headerlink" title="2.run方法"></a>2.run方法</h3><p>线程的线程体，当一个线程开始运行后，执行的就是run方法里面的代码，我们不能直接通过线程对象来调用run方法。因为这并没有产生一个新的线程。仅仅只是一个普通对象的方法调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span><span class="hljs-title function_">run</span><span class="hljs-params">()</span><br><span class="hljs-comment">// 如果这个线程使用单独的Runnable运行对象构造，则调用该Runnable对象的run方法; 否则，此方法不执行任何操作并返回。</span><br></code></pre></td></tr></table></figure><h3 id="3-getName方法"><a href="#3-getName方法" class="headerlink" title="3.getName方法"></a>3.getName方法</h3><p>获取线程名称的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">String<span class="hljs-title function_">getName</span><span class="hljs-params">()</span><br>返回此线程的名称。<br></code></pre></td></tr></table></figure><h3 id="4-优先级"><a href="#4-优先级" class="headerlink" title="4.优先级"></a>4.优先级</h3><p>我们创建的多个线程的执行顺序是由CPU决定的。Java中提供了一个线程调度器来监控程序中启动后进入就绪状态的所有的线程，优先级高的线程会获取到比较多</p><p><strong>运行机会</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 最小的优先级是 1</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">MIN_PRIORITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 默认的优先级都是5</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">NORM_PRIORITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br><br> <span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 最大的优先级是10</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_PRIORITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>大家会发现，设置了优先级后输出的结果和我们预期的并不一样，这是为什么呢？优先级在CPU调动线程执行的时候会是一个参考因数，但不是决定因数，</p><h3 id="5-sleep方法"><a href="#5-sleep方法" class="headerlink" title="5.sleep方法"></a>5.sleep方法</h3><p>将当前线程暂定指定的时间，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span><span class="hljs-title function_">sleep</span><span class="hljs-params">(<span class="hljs-type">long</span> millis)</span><br><span class="hljs-comment">// 使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行），具体取决于系统定时器和调度程序的精度和准确性。</span><br></code></pre></td></tr></table></figure><h3 id="6-isAlive"><a href="#6-isAlive" class="headerlink" title="6.isAlive"></a>6.isAlive</h3><p>获取线程的状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.fundemo;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FunDemo04</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * isAlive方法</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> args</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        System.out.println(<span class="hljs-string">&quot;main  start ...&quot;</span>);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; .... &quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">100</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;);<br>        System.out.println(<span class="hljs-string">&quot;线程的状态：&quot;</span>+t1.isAlive());<br>        t1.start();<br>        System.out.println(<span class="hljs-string">&quot;线程的状态：&quot;</span>+t1.isAlive());<br>        System.out.println(<span class="hljs-string">&quot;main  end ...&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs txt">main  start ...<br>线程的状态：false<br>线程的状态：true<br>main  end ...<br>Thread-0 .... <br></code></pre></td></tr></table></figure><h3 id="7-join"><a href="#7-join" class="headerlink" title="7.join"></a>7.join</h3><p>调用某线程的该方法，将当前线程和该线程合并，即等待该线程结束，在恢复当前线程的运行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.fundemo;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FunDemo05</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 线程的合并</span><br><span class="hljs-comment">     *     join方法</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> args</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;main  start ...&quot;</span>);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">10</span>; i++)&#123;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 子线程执行了...&quot;</span>);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(<span class="hljs-number">100</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br><br>            &#125;<br>        &#125;);<br>        t1.start();<br>        <span class="hljs-keyword">try</span> &#123;<br>            t1.join(); <span class="hljs-comment">// 线程的合并，和主线程合并  相当于我们直接调用了run方法</span><br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;main end ...&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs txt">main  start ...<br>Thread-0 子线程执行了...<br>Thread-0 子线程执行了...<br>Thread-0 子线程执行了...<br>Thread-0 子线程执行了...<br>Thread-0 子线程执行了...<br>Thread-0 子线程执行了...<br>Thread-0 子线程执行了...<br>Thread-0 子线程执行了...<br>Thread-0 子线程执行了...<br>Thread-0 子线程执行了...<br>main end ...<br><br></code></pre></td></tr></table></figure><h3 id="8-yield"><a href="#8-yield" class="headerlink" title="8.yield"></a>8.yield</h3><p>让出CPU，当前线程进入就绪状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bobo.fundemo;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FuneDemo06</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">FuneDemo06</span><span class="hljs-params">(String threadName)</span>&#123;<br>        <span class="hljs-built_in">super</span>(threadName);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * yield方法  礼让</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> args</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">FuneDemo06</span> <span class="hljs-variable">f1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FuneDemo06</span>(<span class="hljs-string">&quot;A1&quot;</span>);<br>        <span class="hljs-type">FuneDemo06</span> <span class="hljs-variable">f2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FuneDemo06</span>(<span class="hljs-string">&quot;A2&quot;</span>);<br>        <span class="hljs-type">FuneDemo06</span> <span class="hljs-variable">f3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FuneDemo06</span>(<span class="hljs-string">&quot;A3&quot;</span>);<br><br>        f1.start();<br>        f2.start();<br>        f3.start();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> ; i &lt; <span class="hljs-number">100</span>; i ++)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">10</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(i%<span class="hljs-number">10</span> == <span class="hljs-number">0</span> &amp;&amp; i != <span class="hljs-number">0</span>)&#123;<br>                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot; 礼让：&quot;</span> + i);<br>                Thread.currentThread().<span class="hljs-keyword">yield</span>(); <span class="hljs-comment">// 让出CPU</span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                System.out.println(<span class="hljs-built_in">this</span>.getName() + <span class="hljs-string">&quot;:&quot;</span> + i);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="9-wait和notify-notifyAll"><a href="#9-wait和notify-notifyAll" class="headerlink" title="9.wait和notify&#x2F;notifyAll"></a>9.wait和notify&#x2F;notifyAll</h3><p>阻塞和唤醒的方法，是Object中的方法，我们在数据同步的时候会介绍到</p><h2 id="5-介绍下线程的生命周期"><a href="#5-介绍下线程的生命周期" class="headerlink" title="5.介绍下线程的生命周期"></a>5.介绍下线程的生命周期</h2><p>生命周期：对象从创建到销毁的全过程</p><p>线程的生命周期：线程对象(Thread)从开始到销毁的全过程</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1675489410098/1980f488416e4f27873341478f928eda.png" alt="image.png"></p><p><strong>线程的状态：</strong></p><ol><li>创建  Thread对象</li><li>就绪状态  执行start方法后线程进入可运行的状态</li><li>运行状态 CPU运行</li><li>阻塞状态  运行过程中被中断(等待阻塞，对象锁阻塞，其他阻塞)</li><li>终止状态  线程执行完成</li></ol><h2 id="6-为什么wait-notify和notifyAll这些方法不在thread类里面？"><a href="#6-为什么wait-notify和notifyAll这些方法不在thread类里面？" class="headerlink" title="6.为什么wait, notify和notifyAll这些方法不在thread类里面？"></a>6.为什么wait, notify和notifyAll这些方法不在thread类里面？</h2><p>&emsp;&emsp;明显的原因是JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。如果wait()方法定义在Thread类中，线程正在等待的是哪个锁就不明显了。简单的说，由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象。</p><h2 id="7-为什么wait和notify方法要在同步块中调用？"><a href="#7-为什么wait和notify方法要在同步块中调用？" class="headerlink" title="7.为什么wait和notify方法要在同步块中调用？"></a>7.为什么wait和notify方法要在同步块中调用？</h2><p>1.只有在调用线程拥有某个对象的独占锁时，才能够调用该对象的wait(),notify()和notifyAll()方法。<br>2.如果你不这么做，你的代码会抛出IllegalMonitorStateException异常。<br>3.还有一个原因是为了避免wait和notify之间产生竞态条件。<br>&emsp;&emsp;wait()<strong>方法强制当前线程释放对象锁。这意味着在调用某对象的wait()方法之前，当前线程必须已经获得该对象的锁。因此，线程必须在某个对象的同步方法或同步代码块中才能调用该对象的wait()方法。<br>&emsp;&emsp;在调用对象的</strong>notify()<strong>和</strong>notifyAll()方法之前，调用线程必须已经得到该对象的锁。因此，必须在某个对象的同步方法或同步代码块中才能调用该对象的notify()或notifyAll()方法。<br>&emsp;&emsp;调用wait()方法的原因通常是，调用线程希望某个特殊的状态(或变量)被设置之后再继续执行。调用notify() 或notifyAll()方法的原因通常是，调用线程希望告诉其他等待中的线程:”特殊状态已经被设置”。这个状态作为线程间通信的通道，它必须是一个可变的共享状态(或变量)。</p><h2 id="8-synchronized和ReentrantLock的区别"><a href="#8-synchronized和ReentrantLock的区别" class="headerlink" title="8.synchronized和ReentrantLock的区别"></a>8.synchronized和ReentrantLock的区别</h2><p><strong>相似点</strong>：<br>&emsp;&emsp;这两种同步方式有很多相似之处，它们都是加锁方式同步，而且都是阻塞式的同步，也就是说当如果一个线程获得了对象锁，进入了同步块，其他访问该同步块的线程都必须阻塞在同步块外面等待，而进行线程阻塞和唤醒的代价是比较高的.<br><strong>区别</strong>：<br>&emsp;&emsp;这两种方式最大区别就是对于Synchronized来说，它是java语言的关键字，是原生语法层面的互斥，需要jvm实现。而ReentrantLock它是JDK 1.5之后提供的API层面的互斥锁，需要lock()和unlock()方法配合try&#x2F;finally语句块来完成。</p><p>&emsp;&emsp;Synchronized进过编译，会在同步块的前后分别形成<strong>monitorenter</strong>和<strong>monitorexit</strong>这个两个字节码指令。在执行<strong>monitorenter</strong>指令时，首先要尝试获取对象锁。如果这个对象没被锁定，或者当前线程已经拥有了那个对象锁，把锁的计算器加1，相应的，在执行monitorexit指令时会将锁计算器就减1，当计算器为0时，锁就被释放了。如果获取对象锁失败，那当前线程就要阻塞，直到对象锁被另一个线程释放为止。</p><p>由于ReentrantLock是java.util.concurrent包下提供的一套互斥锁，相比Synchronized，ReentrantLock类提供了一些高级功能，主要有以下3项：</p><p>1.等待可中断，持有锁的线程长期不释放的时候，正在等待的线程可以选择放弃等待，这相当于Synchronized来说可以避免出现死锁的情况。</p><p>2.公平锁，多个线程等待同一个锁时，必须按照申请锁的时间顺序获得锁，Synchronized锁非公平锁，ReentrantLock默认的构造函数是创建的非公平锁，可以通过参数true设为公平锁，但公平锁表现的性能不是很好。</p><p>3.锁绑定多个条件，一个ReentrantLock对象可以同时绑定对个对象</p><h2 id="9-什么是线程安全"><a href="#9-什么是线程安全" class="headerlink" title="9.什么是线程安全"></a>9.什么是线程安全</h2><p>&emsp;&emsp;线程安全就是说多线程访问同一段代码，不会产生不确定的结果。<br>&emsp;&emsp;如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么你的代码就是线程安全的。这个问题有值得一提的地方，就是线程安全也是有几个级别的：<br>（1）不可变<br>&emsp;&emsp;像String、Integer、Long这些，都是final类型的类，任何一个线程都改变不了它们的值，要改变除非新创建一个，因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用<br>（2）绝对线程安全<br>&emsp;&emsp;不管运行时环境如何，调用者都不需要额外的同步措施。要做到这一点通常需要付出许多额外的代价，Java中标注自己是线程安全的类，实际上绝大多数都不是线程安全的，不过绝对线程安全的类，Java中也有，比方说CopyOnWriteArrayList、CopyOnWriteArraySet<br>（3）相对线程安全<br>&emsp;&emsp;相对线程安全也就是我们通常意义上所说的线程安全，像Vector这种，add、remove方法都是原子操作，不会被打断，但也仅限于此，如果有个线程在遍历某个Vector、有个线程同时在add这个Vector，99%的情况下都会出现ConcurrentModificationException，也就是fail-fast机制。<br>（4）线程非安全<br>&emsp;&emsp;这个就没什么好说的了，ArrayList、LinkedList、HashMap等都是线程非安全的类</p><h2 id="10-Thread类中yield方法的作用"><a href="#10-Thread类中yield方法的作用" class="headerlink" title="10.Thread类中yield方法的作用"></a>10.Thread类中yield方法的作用</h2><p>&emsp;&emsp;yield方法可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执行。它是一个静态方法而且只保证当前线程放弃CPU占用而不能保证使其它线程一定能占用CPU，执行yield()的线程有可能在进入到暂停状态后马上又被执行。</p><h2 id="11-常用的线程池有哪些"><a href="#11-常用的线程池有哪些" class="headerlink" title="11.常用的线程池有哪些"></a>11.常用的线程池有哪些</h2><p><strong>new SingleThreadExecutor</strong>：创建一个单线程的线程池，此线程池保证所有任务的执行顺序按照任务的提交顺序执行。<br><strong>new FixedThreadPool</strong>：创建固定大小的线程池，每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。<br><strong>new CachedThreadPool</strong>：创建一个可缓存的线程池，此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。<br><strong>new ScheduledThreadPool</strong>：创建一个大小无限的线程池，此线程池支持定时以及周期性执行任务的求。</p><h2 id="12-简述一下你对线程池的理解"><a href="#12-简述一下你对线程池的理解" class="headerlink" title="12. 简述一下你对线程池的理解"></a>12. 简述一下你对线程池的理解</h2><p>如果问到了这样的问题，可以展开的说一下线程池如何用、线程池的好处、线程池的启动策略<br>合理利用线程池能够带来三个好处。<br>第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</p><p>第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。<br>第三：提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                               <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">                               <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">                               TimeUnit unit,</span><br><span class="hljs-params">                               BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="hljs-params">                               RejectedExecutionHandler handler)</span> <br><br></code></pre></td></tr></table></figure><p>参数含义：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs txt">corePoolSize：线程池核心线程数量<br>maximumPoolSize:线程池最大线程数量<br>keepAliverTime：当活跃线程数大于核心线程数时，空闲的多余线程最大存活时间<br>unit：存活时间的单位<br>workQueue：存放任务的队列<br>handler：超出线程范围和队列容量的任务的处理程序<br></code></pre></td></tr></table></figure><p>线程池工作原理：</p><p>提交一个任务到线程池中，线程池的处理流程如下：</p><ol><li>判断线程池里的核心线程是否都在执行任务，如果不是（核心线程空闲或者还有核心线程没有被创建）则创建一个新的工作线程来执行任务。如果核心线程都在执行任务，则进入下个流程。</li><li>线程池判断工作队列是否已满，如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。</li><li>判断线程池里的线程是否都处于工作状态，如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。</li></ol><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1675489410098/fc312a088d814b8ca72e855bca0d9cea.png" alt="image.png"></p><h2 id="13-线程池的拒绝策略有哪些"><a href="#13-线程池的拒绝策略有哪些" class="headerlink" title="13.线程池的拒绝策略有哪些?"></a>13.线程池的拒绝策略有哪些?</h2><p>主要有4种拒绝策略：</p><ol><li>AbortPolicy：直接丢弃任务，抛出异常，这是默认策略</li><li>CallerRunsPolicy：只用调用者所在的线程来处理任务</li><li>DiscardOldestPolicy：丢弃等待队列中最旧的任务，并执行当前任务</li><li>DiscardPolicy：直接丢弃任务，也不抛出异常</li></ol><h2 id="14-线程安全需要保证几个基本特性"><a href="#14-线程安全需要保证几个基本特性" class="headerlink" title="14.线程安全需要保证几个基本特性?"></a>14.线程安全需要保证几个基本特性?</h2><p><strong>原子性</strong>，简单说就是相关操作不会中途被其他线程干扰，一般通过同步机制实现。<br><strong>可见性</strong>，是一个线程修改了某个共享变量，其状态能够立即被其他线程知晓，通常被解释为将线程本地状态反映到主内存上，volatile就是负责保证可见性的。<br><strong>有序性</strong>，是保证线程内串行语义，避免指令重排等。</p><h2 id="15-说下线程间是如何通信的"><a href="#15-说下线程间是如何通信的" class="headerlink" title="15.说下线程间是如何通信的?"></a>15.说下线程间是如何通信的?</h2><p>线程之间的通信有两种方式：共享内存和消息传递。</p><p><strong>共享内存</strong><br>&emsp;&emsp;在共享内存的并发模型里，线程之间共享程序的公共状态，线程之间通过写-读内存中的公共状态来隐式进行通信。典型的共享内存通信方式，就是通过共享对象进行通信。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1675489410098/b106c218386d4caa9fd623a7bf3d4ef9.png" alt="image.png"></p><p>例如线程A与线程B之间如果要通信的话，那么就必须经历下面两个步骤：<br>1.线程A把本地内存A更新过得共享变量刷新到主内存中去。<br>2.线程B到主内存中去读取线程A之前更新过的共享变量。<br><strong>消息传递</strong><br>&emsp;&emsp;在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过明确的发送消息来显式进行<br>通信。在Java中典型的消息传递方式，就是wait()和notify()，或者BlockingQueue</p><h2 id="16-说说ThreadLocal的原理"><a href="#16-说说ThreadLocal的原理" class="headerlink" title="16.说说ThreadLocal的原理"></a>16.说说ThreadLocal的原理</h2><p>&emsp;&emsp;ThreadLocal可以理解为线程本地变量，他会在每个线程都创建一个副本，那么在线程之间访问内部副本变量就行了，做到了线程之间互相隔离，相比于synchronized的做法是用空间来换时间。</p><p>&emsp;&emsp;ThreadLocal有一个静态内部类ThreadLocalMap，ThreadLocalMap又包含了一个Entry数组，Entry本身是一个弱引用，他的key是指向ThreadLocal的弱引用，Entry具备了保存key value键值对的能力。</p><p>&emsp;&emsp;弱引用的目的是为了防止内存泄露，如果是强引用那么ThreadLocal对象除非线程结束否则始终无法被回收，弱引用则会在下一次GC的时候被回收。</p><p>&emsp;&emsp;但是这样还是会存在内存泄露的问题，假如key和ThreadLocal对象被回收之后，entry中就存在key为null，但是value有值的entry对象，但是永远没办法被访问到，同样除非线程结束运行。</p><p>&emsp;&emsp;但是只要ThreadLocal使用恰当，在使用完之后调用remove方法删除Entry对象，实际上是不会出现这个问题的。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1675489410098/b4f18c4a52ce4b2aa5cd2abfa9d46d4f.png" alt="image.png"></p><h2 id="17-解释下：同步、异步、阻塞、非阻塞"><a href="#17-解释下：同步、异步、阻塞、非阻塞" class="headerlink" title="17.解释下：同步、异步、阻塞、非阻塞"></a>17.解释下：同步、异步、阻塞、非阻塞</h2><p>同步和异步指的是：当前线程是否需要等待方法调用执行完毕。</p><p>阻塞和非阻塞指的是：当前接口数据还未准备就绪时，线程是否被阻塞挂起</p><p>同步&amp;异步其实是处于框架这种高层次维度来看待的，而阻塞&amp;非阻塞往往针对底层的系统调用方面来抉择，也就是说两者是从不同维度来考虑的。</p><p>这四个概念两两组合，会形成4个新的概念，如下：</p><p><strong>同步阻塞</strong>：客户端发送请求给服务端，此时服务端处理任务时间很久，则客户端则被服务端堵塞了，所以客户端会一直等待服务端的响应，此时客户端不能做其他任何事，服务端也不会接受其他客户端的请求。这种通信机制比较简单粗暴，但是效率不高。</p><p><strong>同步非阻塞</strong>：客户端发送请求给服务端，此时服务端处理任务时间很久，这个时候虽然客户端会一直等待响应，但是服务端可以处理其他的请求，过一会回来处理原先的。这种方式很高效，一个服务端可以处理很多请求，不会在因为任务没有处理完而堵着，所以这是非阻塞的。</p><p><strong>异步阻塞</strong>：客户端发送请求给服务端，此时服务端处理任务时间很久，但是客户端不会等待服务器响应，它可以做其他的任务，等服务器处理完毕后再把结果响应给客户端，客户端得到回调后再处理服务端的响应。这种方式可以避免客户端一直处于等待的状态，优化了用户体验，其实就是类似于网页里发起的ajax异步请求。</p><p><strong>异步非阻塞</strong>：客户端发送请求给服务端，此时服务端处理任务时间很久，这个时候的任务虽然处理时间会很久，但是客户端可以做其他的任务，因为他是异步的，可以在回调函数里处理响应；同时服务端是非阻塞的，所以服务端可以去处理其他的任务，如此，这个模式就显得非常的高效了。<img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1675489410098/425e2e707b7a4ba9924e7ed3acafaa6b.png" alt="image.png"></p><h2 id="18-什么是BIO"><a href="#18-什么是BIO" class="headerlink" title="18.什么是BIO?"></a>18.什么是BIO?</h2><p><strong>BIO</strong> ： <strong>同步并阻塞</strong> ，服务器实现一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，没处理完之前此线程不能做其他操作（如果是单线程的情况下，我传输的文件很大呢？），当然可以通过线程池机制改善。</p><p>BIO方式 <strong>适用于连接数目比较小且固定的架构</strong> ，这种方式对服务器资源要求比较高，并发局限于应用中JDK1.4以前的唯一选择，但程序直观简单易理解。</p><h2 id="19-什么是NIO？"><a href="#19-什么是NIO？" class="headerlink" title="19.什么是NIO？"></a>19.什么是NIO？</h2><p><strong>NIO</strong> ： <strong>同步非阻塞</strong> ，服务器实现一个连接一个线程，即客户端发送的连接请求都会注册到多路复用器上，多复用器轮询到连接有I&#x2F;O请求时才启动一个线程进行处理。</p><p>NIO方式 <strong>适用于连接数目多且连接比较短（轻操作）的架构</strong> ，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4之后开始支持。</p><h2 id="20-什么是AIO？"><a href="#20-什么是AIO？" class="headerlink" title="20.什么是AIO？"></a>20.什么是AIO？</h2><p><strong>AIO</strong> ： <strong>异步非阻塞</strong> ，服务器实现模式为一个有效请求一个线程，客户端的I&#x2F;O请求都是由操作系统先完成了再通知服务器应用去启动线程进行处理，AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用操作系统参与并发操作，编程比较复杂，JDK1.7之后开始支持。</p><p>AIO属于NIO包中的类实现，其实 <strong>IO主要分为BIO和NIO</strong> ，AIO只是附加品，解决IO不能异步的实现在以前很少有Linux系统支持AIO，Windows的IOCP就是该AIO模型。但是现在的服务器一般都是支持AIO操作</p><h2 id="21-介绍下IO流的分类"><a href="#21-介绍下IO流的分类" class="headerlink" title="21.介绍下IO流的分类"></a>21.介绍下IO流的分类</h2><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1675489410098/41ec0a93b407448f9c591a7a3645bb3a.png" alt="image.png"></p><p>1：<a href="https://cloud.fynote.com/share/d/qPGzAVr5">https://cloud.fynote.com/share/d/qPGzAVr5</a></p><p>2：<a href="https://cloud.fynote.com/share/d/MPG9AVsAG">https://cloud.fynote.com/share/d/MPG9AVsAG</a></p><p>3：<a href="https://cloud.fynote.com/share/d/qPGHKVsM">https://cloud.fynote.com/share/d/qPGHKVsM</a></p><h1 id="一、JavaWeb专题"><a href="#一、JavaWeb专题" class="headerlink" title="一、JavaWeb专题"></a>一、JavaWeb专题</h1><h2 id="1-HTTP响应码有哪些"><a href="#1-HTTP响应码有哪些" class="headerlink" title="1.HTTP响应码有哪些"></a>1.HTTP响应码有哪些</h2><p>1、1xx（临时响应）<br>2、2xx（成功）<br>3、3xx（重定向）：表示要完成请求需要进一步操作<br>4、4xx（错误）：表示请求可能出错，妨碍了服务器的处理<br>5、5xx（服务器错误）：表示服务器在尝试处理请求时发生内部错误</p><p>举例：</p><p>200：成功，Web服务器成功处理了客户端的请求。<br>301：永久重定向，当客户端请求一个网址的时候，Web服务器会将当前请求重定向到另一个网址，搜索引擎会抓取重定向后网页的内容并且将旧的网址替换为重定向后的网址。<br>302：临时重定向，搜索引擎会抓取重定向后网页的内容而保留旧的网址，因为搜索引擎认为重定向后的网址是暂时的。<br>400：客户端请求错误，多为参数不合法导致Web服务器验参失败。<br>404：未找到，Web服务器找不到资源。<br>500：Web服务器错误，服务器处理客户端请求的时候发生错误。<br>503：服务不可用，服务器停机。<br>504：网关超时</p><h2 id="2-Forward和Redirect的区别？"><a href="#2-Forward和Redirect的区别？" class="headerlink" title="2.Forward和Redirect的区别？"></a>2.Forward和Redirect的区别？</h2><ol><li>浏览器URL地址：Forward是服务器内部的重定向，服务器内部请求某个servlet，然后获取响应的内容，浏览器的URL地址是不会变化的；Redirect是客户端请求服务器，然后服务器给客户端返回了一个302状态码和新的location，客户端重新发起HTTP请求，服务器给客户端响应location对应的URL地址，浏览器的URL地址发生了变化。</li><li>数据的共享：Forward是服务器内部的重定向，request在整个重定向过程中是不变的，request中的信息在servlet间是共享的。Redirect发起了两次HTTP请求分别使用不同的request。</li><li>请求的次数：Forward只有一次请求；Redirect有两次请求。</li></ol><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1675489425009/fba756c1b94e439ab2dec986650a7117.png" alt="image.png"></p><h2 id="3-Get和Post请求的区别"><a href="#3-Get和Post请求的区别" class="headerlink" title="3.Get和Post请求的区别"></a>3.Get和Post请求的区别</h2><p>用途：</p><ul><li>get请求用来从服务器获取资源</li><li>post请求用来向服务器提交数据</li></ul><p>表单的提交方式：</p><ul><li>get请求直接将表单数据以name1&#x3D;value1&amp;name2&#x3D;value2的形式拼接到URL上（<a href="http://www.baidu.com/action?name1=value1&name2=value2%EF%BC%89%EF%BC%8C%E5%A4%9A%E4%B8%AA%E5%8F%82%E6%95%B0%E5%8F%82%E6%95%B0%E5%80%BC%E9%9C%80%E8%A6%81%E7%94%A8&%E8%BF%9E%E6%8E%A5%E8%B5%B7%E6%9D%A5%E5%B9%B6%E4%B8%94%E7%94%A8?%E6%8B%BC%E6%8E%A5%E5%88%B0action%E5%90%8E%E9%9D%A2%EF%BC%9B">http://www.baidu.com/action?name1=value1&amp;name2=value2），多个参数参数值需要用&amp;连接起来并且用?拼接到action后面；</a></li><li>post请求将表单数据放到请求头或者请求的消息体中。</li></ul><p>传输数据的大小限制：</p><ul><li>get请求传输的数据受到URL长度的限制，而URL长度是由浏览器决定的；</li><li>post请求传输数据的大小理论上来说是没有限制的。</li></ul><p>参数的编码：</p><ul><li>get请求的参数会在地址栏明文显示，使用URL编码的文本格式传递参数；</li><li>post请求使用二进制数据多重编码传递参数。</li></ul><p>缓存处理：</p><ul><li>get请求可以被浏览器缓存被收藏为标签；</li><li>post请求不会被缓存也不能被收藏为标签</li></ul><h2 id="4-介绍下OSI七层和TCP-IP四层的关系"><a href="#4-介绍下OSI七层和TCP-IP四层的关系" class="headerlink" title="4.介绍下OSI七层和TCP&#x2F;IP四层的关系"></a>4.介绍下OSI七层和TCP&#x2F;IP四层的关系</h2><p>为了更好地促进互联网的研究和发展，国际标准化组织ISO在1985 年指定了网络互联模型。OSI 参考模型（Open System Interconnect Reference <a href="https://so.csdn.net/so/search?q=Model&spm=1001.2101.3001.7020">Model</a>），具有 7 层结构</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1675489425009/8b05a5e5ca8f45f6adfe5a2473797a6e.png" alt="image.png"></p><p><strong>应用层</strong>：各种应用程序协议，比如HTTP、HTTPS、FTP、SOCKS安全套接字协议、DNS域名系统、GDP网关发现协议等等。<br><strong>表示层</strong>：加密解密、转换翻译、压缩解压缩，比如LPP轻量级表示协议。<br><strong>会话层</strong>：不同机器上的用户建立和管理会话，比如SSL安全套接字层协议、TLS传输层安全协议、RPC远程过程调用协议等等。</p><p><strong>传输层</strong>：接受上一层的数据，在必要的时候对数据进行分割，并将这些数据交给网络层，保证这些数据段有效到达对端，比如TCP传输控制协议、UDP数据报协议。<br><strong>网络层</strong>：控制子网的运行：逻辑编址、分组传输、路由选择，比如IP、IPV6、SLIP等等。<br><strong>数据链路层</strong>：物理寻址，同时将原始比特流转变为逻辑传输路线，比如XTP压缩传输协议、PPTP点对点隧道协议等等。<br><strong>物理层</strong>：机械、电子、定时接口通信信道上的原始比特流传输，比如IEEE802.2等等。</p><p>而且在消息通信的过程中具体的执行流程为：</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1675489425009/62a425220acc40b6b53cf2c34a4331a6.png" alt="image.png"></p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1675489425009/933af2e7173942319f49900f5ce9ae49.png" alt="image.png"></p><p>网络传输的数据其实会通过这七层协议来进行数据的封装和拆解</p><h2 id="5-说说TCP和UDP的区别"><a href="#5-说说TCP和UDP的区别" class="headerlink" title="5.说说TCP和UDP的区别"></a>5.说说TCP和UDP的区别</h2><p>1、TCP面向连接（如打电话要先拨号建立连接）：UDP是无连接的，即发送数据之前不需要建立连接。<br>2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付。tcp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。<br>3、UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。<br>4.每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信</p><p>5、TCP对系统资源要求较多，UDP对系统资源要求较少。</p><h2 id="6-说下HTTP和HTTPS的区别"><a href="#6-说下HTTP和HTTPS的区别" class="headerlink" title="6. 说下HTTP和HTTPS的区别"></a>6. 说下HTTP和HTTPS的区别</h2><p>端口不同：HTTP和HTTPS的连接方式不同没用的端口也不一样，HTTP是80，HTTPS用的是443<br>消耗资源：和HTTP相比，HTTPS通信会因为加解密的处理消耗更多的CPU和内存资源。<br>开销：HTTPS通信需要证书，这类证书通常需要向认证机构申请或者付费购买。</p><h2 id="7-说下HTTP、TCP、Socket的关系是什么？"><a href="#7-说下HTTP、TCP、Socket的关系是什么？" class="headerlink" title="7.说下HTTP、TCP、Socket的关系是什么？"></a>7.说下HTTP、TCP、Socket的关系是什么？</h2><ul><li>TCP&#x2F;IP代表传输控制协议&#x2F;网际协议，指的是一系列协议族。</li><li>HTTP本身就是一个协议，是从Web服务器传输超文本到本地浏览器的传送协议。</li><li>Socket是TCP&#x2F;IP网络的API，其实就是一个门面模式，它把复杂的TCP&#x2F;IP协议族隐藏在Socket接口后面。对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。</li></ul><p>综上所述：</p><ul><li>需要IP协议来连接网络</li><li>TCP是一种允许我们安全传输数据的机制，使用TCP协议来传输数据的HTTP是Web服务器和客户端使用的特殊协议。</li><li>HTTP基于TCP协议，所以可以使用Socket去建立一个TCP连接。</li></ul><h2 id="8-说下HTTP的长链接和短连接的区别"><a href="#8-说下HTTP的长链接和短连接的区别" class="headerlink" title="8. 说下HTTP的长链接和短连接的区别"></a>8. 说下HTTP的长链接和短连接的区别</h2><p>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</p><p><strong>短连接</strong><br>&emsp;&emsp;在HTTP&#x2F;1.0中默认使用短链接,也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。如果客户端访问的某个HTML或其他类型的Web资源，如JavaScript文件、图像文件、CSS文件等。当浏览器每遇到这样一个Web资源，就会建立一个HTTP会话.<br><strong>长连接</strong><br>&emsp;&emsp;从HTTP&#x2F;1.1起，默认使用长连接，用以保持连接特性。在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭。如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。</p><h2 id="9-TCP原理"><a href="#9-TCP原理" class="headerlink" title="9.TCP原理"></a>9.TCP原理</h2><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1675489425009/2c3e7415ef194f0a93fd91345ba9c0ac.png" alt="image.png"></p><p>三次握手：</p><p>1.第一次握手：客户端将标志位syn重置为1，随机产生seq&#x3D;a，并将数据包发送给服务端<br>2.第二次握手：服务端收到syn&#x3D;1知道客户端请求连接，服务端将syn和ACK都重置为1，ack&#x3D;a+1，随机产一个值seq&#x3D;b，并将数据包发送给客户端，服务端进入syn_RCVD状态。<br>3.第三次握手：客户端收到确认后，检查ack是否为a+1，ACK是否为1，若正确将ACK重置为1，将ack改为b+1，然后将数据包发送给服务端服务端检查ack与ACK,若都正确，就建立连接，进入ESTABLISHEN.</p><p>四次挥手：</p><p>1.开始双方都处于连接状态<br>2.客户端进程发出FIN报文，并停止发送数据，在报文中FIN结束标志为1，seq为a连接状态下发送给服务器的最后一个字节的序号+1，报文发送结束后，客户端进入FIN-WIT1状态。<br>3.服务端收到报文，向客户端发送确认报文，ACK&#x3D;1,seq为b服务端给客户端发送的最后字节的序号+1，ack&#x3D;a+1，发送后客户端进入close-wait状态，不再发送数据，但服务端发送数据客户端一九可以收到（城为半关闭状态）。<br>4.客户端收到服务器的确认报文后，客户端进入fin-wait2状态进行等待服务器发送第三次的挥手报文。<br>5.服务端向fin报文FIN&#x3D;1ACK&#x3D;1，seq&#x3D;c（服务器向客户端发送最后一个字节序号+1），ack&#x3D;b+1，发送结束后服务器进入last-ack状态等待最后的确认。<br>6.客户端收到是释放报文后，向服务器发送确认报文进入time-wait状态，后进入close<br>7.服务端收到确认报文进入close状态。</p><h2 id="10-Cookie和Session的区别"><a href="#10-Cookie和Session的区别" class="headerlink" title="10. Cookie和Session的区别"></a>10. Cookie和Session的区别</h2><p>&emsp;&emsp;cookie是由Web服务器保存在用户浏览器上的文件（key-value格式），可以包含用户相关的信息。客户端向服务器发起请求，就提取浏览器中的用户信息由http发送给服务器</p><p>&emsp;&emsp;session是浏览器和服务器会话过程中，服务器会分配的一块储存空间给session。服务器默认为客户浏览器的cookie中设置sessionid，这个sessionid就和cookie对应，浏览器在向服务器请求过程中传输的cookie包含sessionid，服务器根据传输cookie中的sessionid获取出会话中存储的信息，然后确定会话的身份信息。</p><p>1、Cookie数据存放在客户端上，安全性较差，Session数据放在服务器上，安全性相对更高<br>2、单个cookie保存的数据不能超过4K，session无此限制<br>3、session一定时间内保存在服务器上，当访问增多，占用服务器性能，考虑到服务器性能方面，应当<br>使用cookie。</p><h2 id="11-Tomcat是什么？"><a href="#11-Tomcat是什么？" class="headerlink" title="11.Tomcat是什么？"></a>11.Tomcat是什么？</h2><p>Tomcat服务器Apache软件基金会项目中的一个核心项目，是一个免费的开放源代码的Web应用服<br>务器（Servlet容器），属于轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被<br>普遍使用，是开发和调试JSP程序的首选。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1675489425009/cc3c3c6020d54b098e862692bada4302.png" alt="image.png"></p><h2 id="12-Tomcat有几种部署方式"><a href="#12-Tomcat有几种部署方式" class="headerlink" title="12.Tomcat有几种部署方式"></a>12.Tomcat有几种部署方式</h2><ol><li>利用Tomcat的自动部署：把web应用拷贝到webapps目录（生产环境不建议放在该目录中）。Tomcat在启动时会加载目录下的应用，并将编译后的结果放入work目录下。</li><li>使用Manager App控制台部署：在tomcat主页点击“Manager App”进入应用管理控制台，可以指定一个web应用的路径或war文件。</li><li>修改conf&#x2F;server.xml文件部署：在server.xml文件中，增加Context节点可以部署应用。</li><li>增加自定义的Web部署文件：在conf&#x2F;Catalina&#x2F;localhost&#x2F;路径下增加xyz.xml文件，内容是Context节点，可以部署应用。</li></ol><h2 id="13-什么是Servlet"><a href="#13-什么是Servlet" class="headerlink" title="13.什么是Servlet"></a>13.什么是Servlet</h2><p>&emsp;&emsp;Servlet是JavaEE规范的一种，主要是为了扩展Java作为Web服务的功能，统一接口。由其他内部厂<br>商如tomcat，jetty内部实现web的功能。如一个http请求到来：容器将请求封装为servlet中的<br>HttpServletRequest对象，调用init()，service()等方法输出response,由容器包装为httpresponse<br>返回给客户端的过程。</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1675489425009/f1f331019c8b41519bd49a588d413ffc.png" alt="image.png"></p><h2 id="14-什么是Servlet规范"><a href="#14-什么是Servlet规范" class="headerlink" title="14. 什么是Servlet规范?"></a>14. 什么是Servlet规范?</h2><ul><li>从Jar包上来说，Servlet规范就是两个Jar文件。servlet-api.jar和jsp-api.jar，Jsp也是一种Servlet。</li><li>从package上来说，就是javax.servlet和javax.servlet.http两个包。</li><li>从接口来说，就是规范了Servlet接口、Filter接口、Listener接口、ServletRequest接口、ServletResponse接口等。类图如下：</li></ul><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1675489425009/5605477c3db841e7824a0432e4a6c2a9.png" alt="image.png"></p><h2 id="15-为什么我们将tomcat称为Web容器或者Servlet容器？"><a href="#15-为什么我们将tomcat称为Web容器或者Servlet容器？" class="headerlink" title="15.为什么我们将tomcat称为Web容器或者Servlet容器？"></a>15.为什么我们将tomcat称为Web容器或者Servlet容器？</h2><p>我们用一张图来表示他们之间的关系:</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1675489425009/5e137f734ac540ed9aaee12704166ec0.png" alt="image.png"></p><p>简单的理解：启动一个ServerSocket，监听8080端口。Servlet容器用来装我们开发的Servlet。</p><h2 id="16-Servlet的生命周期"><a href="#16-Servlet的生命周期" class="headerlink" title="16.Servlet的生命周期"></a>16.Servlet的生命周期</h2><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1675489425009/b6757fdbc638457daebd04fd83a9d0f7.png" alt="image.png"></p><h2 id="17-jsp和Servlet的区别"><a href="#17-jsp和Servlet的区别" class="headerlink" title="17. jsp和Servlet的区别"></a>17. jsp和Servlet的区别</h2><ul><li>本质都是servlet</li><li>servlet侧重于逻辑处理</li><li>jsp侧重于视图显示</li></ul><h2 id="18-九大内置对象"><a href="#18-九大内置对象" class="headerlink" title="18. 九大内置对象"></a>18. 九大内置对象</h2><ol><li>page页面对象</li><li>config配置对象</li><li>request请求对象</li><li>response响应对象</li><li>session会话对象</li><li>application全局对象</li><li>out输出对象</li><li>pageContext页面上下文对象</li><li>exception异常对象</li></ol><h2 id="19-JSP的四大作用域"><a href="#19-JSP的四大作用域" class="headerlink" title="19. JSP的四大作用域"></a>19. JSP的四大作用域</h2><p>page：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">只在当前页面有效<br></code></pre></td></tr></table></figure><p>request：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">它在当前请求中有效<br></code></pre></td></tr></table></figure><p>session：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">它在当前会话中有效<br></code></pre></td></tr></table></figure><p>application：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">他在所有的应用程序中都有效<br></code></pre></td></tr></table></figure><p>注意：当4个作用域对象都有相同的name属性时,默认按照最小的顺序查找</p><h2 id="20-GenericServlet和HttpServlet有什么区别？"><a href="#20-GenericServlet和HttpServlet有什么区别？" class="headerlink" title="20. GenericServlet和HttpServlet有什么区别？"></a>20. <strong>GenericServlet和HttpServlet有什么区别？</strong></h2><p>GenericServlet 为抽象类，定义了一个通用的、独立于底层协议的servlet，实现了Servlet 和 ServletConfig接口，ServletConfig接口定义了在Servlet初始化的过程中由Servlet容器传递给Servlet得配置信息对象。OK，这个类可能我们不是那么熟悉，但是他的子类相信大家都知道，也就是HttpServlet，HttpServlet 继承自抽象类GenericServlet 具有其所有的特性并拓展了一些其他的方法,如doGet、doPost等</p><p><img src="https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/fyfile/1462/1675489425009/12c9c504a75243bba4aec073404bdc5e.png" alt="image.png"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/04/08/hello-world/"/>
    <url>/2024/04/08/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>业务-关于订单服务</title>
    <link href="/2024/03/01/%E4%B8%9A%E5%8A%A1-%E5%85%B3%E4%BA%8E%E8%AE%A2%E5%8D%95%E6%9C%8D%E5%8A%A1/"/>
    <url>/2024/03/01/%E4%B8%9A%E5%8A%A1-%E5%85%B3%E4%BA%8E%E8%AE%A2%E5%8D%95%E6%9C%8D%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<p>欢迎来到我的博客！很多业务都需要订单服务, 所以先举例子再抽取是这篇文章要做的事情,后续也会迭代版本。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>首先是背景 当前例子下是一个网约车的项目  我们做一个基础版本的订单服务 然后后续会去迭代这个版本。<br><img src="/images/%E6%80%BB%E6%B5%81%E7%A8%8B.jpg" alt="大概流程"><br><img src="/images/%E7%BD%91%E7%BA%A6%E8%BD%A6.jpg" alt="草图"></p><h2 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h2><p><img src="/images/09-%E8%AE%A1%E4%BB%B7.jpg" alt="价格预估及扩展"></p><p><img src="/images/orderTime.jpg" alt="订单时序图"></p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>画时序图 -&gt; 接口设计 -&gt; 项目创建 -&gt; 魔法值测试 -&gt; 订单表创建 -&gt; 添加计价规则</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><h3 id="设计接口"><a href="#设计接口" class="headerlink" title="设计接口:"></a><strong>设计接口</strong>:</h3><p>  我们应该养成抱着APIFOX或者POSTMAN进行开发,这应该是我们的习惯之一,那么关于订单接口的设计 我们应该这么干。根据网络预约出租车协议来编写当前接口的返回值（就是去查看相应的返回报文） 这里用APIFOX举例子<br>  1、首先我们填写接口  eg: localhost:8080&#x2F;order&#x2F;placing-order  然后我们用json的格式编写Response </p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;address&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;departTime&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;orderTime&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;departure&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;depLongitude&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;deplatitude&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;destination&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;destLongitude&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;deplatitude&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;encrypt&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;fareType&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>大概就是这个样子 简略写一些，根据具体业务具体的去写返回属性,让后我们就去编写对应的OrderRequest.java。</p><h3 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写:"></a><strong>代码编写</strong>:</h3><p>  姑且把这个OrderRequest写进二方库里(common)<br>  <strong><code>好习惯:先简单测试 写一个add去Test一下  看看能否正常的db 在apiFox使用魔法数据先填充一波</code></strong></p><p>   <strong>三步走:</strong><br>   ① 写依赖<br>   ② 配置yml文件<br>   ③ 写对应的注解</p><p>  然后比如注册 注册中心啊 这些如果想起来我就写，基操就不多赘述了。</p><p>  到这里我们应该是正常的实现了 order服务的基本操作 crud 或者说 就是一个add就可以了</p><p>  然后我们在API-passenger（客户端）通过Feign去 调用我们service-order中的add方法  返回值的就是成功与否啊？<br>  <em>这里我们添加一个图片后续</em><br>  <img src="/images/" alt="乘客端远程调用图"></p><p>  因为我们是魔法值所以下一步 设计表 -&gt;<br>  先说答案: 就是上面的json 然后加一个id、车辆经度、车辆纬度、机动车驾驶证编码、驾驶员手机号、车辆号牌、派单成功时间 就是表里的所有字段了 最好添加一下desc（描述）以免后续忘记。<br>  思路:<br>        就是需要一个整体的考虑  范式与反范式的考虑 是根据我们上面订单时序图和接口报文综合来考虑需要啥不需要啥。<br>        其实我第一建表也没健全 后续补充了一下。。。</p><h4 id="自动生成数据库代码实现"><a href="#自动生成数据库代码实现" class="headerlink" title="自动生成数据库代码实现"></a><strong>自动生成数据库代码实现</strong></h4><pre><code class="hljs">三步走！1 添加依赖 &#123;    一个 mybatis-plus-generator  # 这个是苞米兜下面的    一个 freemarker  # org包下的        &lt;!-- MyBatis-Plus Generator --&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.baomidou&lt;/groupId&gt;        &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt;        &lt;version&gt;最新版本&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- Freemarker --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.freemarker&lt;/groupId&gt;        &lt;artifactId&gt;freemarker&lt;/artifactId&gt;        &lt;version&gt;最新版本&lt;/version&gt;    &lt;/dependency&gt;&#125;</code></pre><p><strong>代码自动生成</strong></p><pre><code class="hljs">2 写自动生产包的代码   &#123;        package com.xinwen.demodoutoken.test;        import com.baomidou.mybatisplus.core.exceptions.MybatisPlusException;        import com.baomidou.mybatisplus.core.toolkit.StringUtils;        import com.baomidou.mybatisplus.generator.AutoGenerator;        import com.baomidou.mybatisplus.generator.config.*;        import com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;        import com.baomidou.mybatisplus.generator.engine.FreemarkerTemplateEngine;    import java.util.Scanner;    public class CodeGenerator &#123;        private static final String JDBC_URL = &quot;jdbc:mysql://localhost:3306/数据库?useSSL=false&amp;characterEncoding=utf8&amp;serverTimezone=UTC&quot;;        private static final String JDBC_DRIVER_NAME = &quot;com.mysql.cj.jdbc.Driver&quot;;        private static final String JDBC_USERNAME = &quot;root&quot;;        private static final String JDBC_PASSWORD = &quot;root&quot;;        public static String scanner(String tip) &#123;            Scanner scanner = new Scanner(System.in);            System.out.println(&quot;请输入&quot; + tip + &quot;：&quot;);            if (scanner.hasNext()) &#123;                String ipt = scanner.next();                if (StringUtils.isNotBlank(ipt)) &#123;                    return ipt;                &#125;            &#125;            throw new MybatisPlusException(&quot;请输入正确的&quot; + tip + &quot;！&quot;);        &#125;        public static void main(String[] args) &#123;            AutoGenerator mpg = new AutoGenerator();            GlobalConfig gc = new GlobalConfig();            String projectPath = System.getProperty(&quot;user.dir&quot;);            gc.setOutputDir(projectPath + &quot;/src/main/java&quot;);            gc.setAuthor(&quot;Xin-Wen&quot;);            gc.setOpen(false);            mpg.setGlobalConfig(gc);            DataSourceConfig dsc = new DataSourceConfig();            dsc.setUrl(JDBC_URL);            dsc.setDriverName(JDBC_DRIVER_NAME);            dsc.setUsername(JDBC_USERNAME);            dsc.setPassword(JDBC_PASSWORD);            mpg.setDataSource(dsc);            PackageConfig pc = new PackageConfig();            pc.setModuleName(scanner(&quot;模块名&quot;));            pc.setParent(&quot;com.xinwen&quot;);            mpg.setPackageInfo(pc);            // 注意这里的设置，确保不要以斜杠开头            TemplateConfig templateConfig = new TemplateConfig()                    .setController(&quot;templates/controller.java&quot;); // 这里提供模板带ftl 但是在这里不要填写tfl            mpg.setTemplate(templateConfig);            StrategyConfig strategy = new StrategyConfig();            strategy.setNaming(NamingStrategy.underline_to_camel);            strategy.setColumnNaming(NamingStrategy.underline_to_camel);            strategy.setEntityLombokModel(true);            strategy.setRestControllerStyle(true);            strategy.setInclude(scanner(&quot;表名，多个英文逗号分割&quot;).split(&quot;,&quot;));            mpg.setStrategy(strategy);            mpg.setTemplateEngine(new FreemarkerTemplateEngine());            mpg.execute();        &#125;    &#125;&#125;</code></pre><h3 id="添加计价规则"><a href="#添加计价规则" class="headerlink" title="添加计价规则"></a><strong>添加计价规则</strong></h3><p>动作  api-passenger 调用 service-price 进行计价的动作 然后service-price去调用 service-map 拉取到经纬度 回去计算 然后 reurn给api-passenger</p><p>目的: 这里是之前在预估价格操作的时候是写死了的 在这个位置我们会对之前预估价格的服务进行一个简单的翻新 把城市编码和车型参数做一个传递<br>    之前返回给前端的值就是一个 price 预估价  此时我们做一个修改就是  把这个 city_code  和 vehicleType 也给他塞进去  这是为了方便后续下订单操作的参数预备</p><p><img src="/images/%E8%AE%A1%E4%BB%B7%E8%A7%84%E5%88%99%E4%BC%A0%E9%80%92%E6%89%A9%E5%B1%95%E5%9B%BE.jpg" alt="计价规则传递扩展图"></p><pre><code class="hljs">这里就是 我们预估价格的操作 流程就是这样的 为什么要多次判断呢  举例子说明  : 一个人  8点  拿着我当时的计价规则 根据(城市  车型  计价规则  里程数 时间 ) 算出来一个价格然后拉到了价格之后 没下单 ！  干别的事去了 9点回来的下的单子 ok 不巧的是 我们 8点30 改了计价规则了  那么我们就要在用户下单的时候提醒他 计价发生改变  你接受不接受新计价规则 如果接受ok 那就去下单 不接受就没事了 </code></pre><p>记忆点: 司机有总流程中的1234567条 是不允许下单的  （订单开始  司机接单 去接乘客  司机到达 乘客上车司机启程 到达地点 未支付）</p><h2 id="派单业务"><a href="#派单业务" class="headerlink" title="派单业务"></a><strong>派单业务</strong></h2><p><img src="/images/%E6%B4%BE%E5%8D%95%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg" alt="派单业务图"></p><h3 id="针对于用户自身合法性的校验"><a href="#针对于用户自身合法性的校验" class="headerlink" title="针对于用户自身合法性的校验"></a><strong>针对于用户自身合法性的校验</strong></h3><h4 id="乘客下单业务校验"><a href="#乘客下单业务校验" class="headerlink" title="乘客下单业务校验"></a><strong>乘客下单业务校验</strong></h4><pre><code class="hljs">下单流程 : if 订单表中 有一个字段叫订单状态  如果状态是1-7不能继续下单 （constants）else 可以下单  </code></pre><h4 id="黑名单校验业务"><a href="#黑名单校验业务" class="headerlink" title="黑名单校验业务"></a><strong>黑名单校验业务</strong></h4><pre><code class="hljs"> 背景 网约车项目 : 1分钱乘车活动   下单时判断设备号 是否在1h内下多次订单  if是 提醒不允许下单 else  操作redis: （key）设备号 （value）次数 , TTL     在HttpServletRequest的header中 拉去 deviceCode 这就是设备号了</code></pre><h3 id="基于业务实际展开情况的校验"><a href="#基于业务实际展开情况的校验" class="headerlink" title="基于业务实际展开情况的校验"></a><strong>基于业务实际展开情况的校验</strong></h3><pre><code class="hljs">1、当前城市和车型是否开通业务？（通过城市编号和车型 这两个字段 去计价规则表中 查询如果有拿过来或者不拿 看后续需求  返回true 否则 false）</code></pre><h3 id="查询城市可用司机"><a href="#查询城市可用司机" class="headerlink" title="查询城市可用司机"></a><strong>查询城市可用司机</strong></h3><pre><code class="hljs">司机信息表 查看司机状态 通过城市 拉去到 当前城市信息 然后查看状态</code></pre><h2 id="派单逻辑"><a href="#派单逻辑" class="headerlink" title="派单逻辑"></a><strong>派单逻辑</strong></h2><pre><code class="hljs">service-order端 通过循环调用 周边所搜 每次扩大半径就ok了 然后通过定时任务调用就行了 优化把2000 4000 5000 塞进list 然后循环的拉去附近终端 拉取到后解析 出tid和carid 看看司机能不能接单  然后进行后续操作</code></pre><h1 id="派单流程前置流程整体联调"><a href="#派单流程前置流程整体联调" class="headerlink" title="派单流程前置流程整体联调"></a><strong>派单流程前置流程整体联调</strong></h1><pre><code class="hljs">测试流程:1. 乘客发送验证码2. 乘客登录成功3. 获取乘客信息 (测试accessToken)4. 添加计价规则5. 乘客预估价格此时乘客就要下单了  就需要司机的出现了6. boss端录入司机信息   (启动API-boss 和 service-dirver-user) 添加司机    6.1 添加车辆 (在创建车辆信息的同时 去创建车辆的终端 调用接口 还有创建轨迹 然后把车辆和轨迹进行绑定)7. 绑定车辆和司机-  司机获取验证码 8. 司机登录             (api-driver 功能包含:                 维护司机信息                  司机获取验证码                  司机验证验证码                 上传车辆位置信息                 需要带token和不需要带token            )9. 司机出车 (service-dirver-user 做一个司机出车的动作  就是修改司机表中的工作状态 从0 改成和 1    然后通过feign远程调用 在api-dirver端)           (service-dirver-user的功能有                 插入司机信息                修改司机信息                插入车辆信息                司机车辆绑定                司机车辆解绑                检查手机号对应的司机是否正在工作                修改司机工作状态                根据车辆id查询车辆信息                根据citycode查询当前城市车辆                根据车辆ID查询可以派单的车辆信息           )10. 司机上传地理位置信息 就是调用api-driver的上传车辆位置信息             (api-passenger功能                 乘客获取验证码                 乘客校验验证码                 测试auth                 双token刷新接口                 查询乘客用户信息                 预估价格                 乘客下单             )tips: 当用户下订单时 就开始2km 4km 6km(5km  因为高德限制 我们说是6km实际上只到5km)的周围所搜11. 乘客搜索车辆 搜索到会返回 carId 和 tid 12. 根据拿到的车辆ID, 查询可分配的司机13. 司机准备校验        当拉取到附近的司机后 查看司机状态 两步  第一步 work_status 司机是不是正在出车？  第二步 order_status 司机当前有没有订单14. 订单司机匹配(tips: 其实是有两种 实时订单 和 预约订单 理论上这两种单子都可以抢  但是我们目前基础实现 直接对实时订单进行系统派单操作了)匹配操作: 订单表中有 司机id 司机电话 车辆id 接单时车辆经度  接单时车辆纬度  接单时间 订单状态  车牌号 车型啊 品牌 还有给国家监管平台上传的机动车驾驶证LicenseID 等等优化: 经纬度存储建议 1 dobule 2 字符串  我们经纬度需要计算 那就double  如果不需要运算我们就要string类型这样最大化保证精度 高德传回来的是double类型 我就把他们转化成string类型了 15. 并发压测    &#123;      并发测试目标: 多个订单 派到一个司机时的异常情况       具体操作: 准备了是个 订单然后 并发派单  理论上 此时此刻只能有一个单子记录会被更新 会拿到我的那个司机 因为我就准备了 一个司机      但是 实际上我竟然有八个订单同时派给了一个司机       此时加上synchronized关键字  锁住整个订单的方法 然后测试 通过！ 然后优化缩小范围 锁住填充表中位置的代码 ok 成功！      但是这是单机模式下的 集群模式下呢 我们发现集群模式下 会出现有两个订单同时抢到一个司机       so      启用 Redisson 然后我们解决我们集群的问题  大概率是一个单机分配到5个订单 然后最终只有一个订单拉到司机    &#125;16. 司机客户端模拟    &#123;      现在我们的订单已经填充完毕了 就是已经完成了 订单抢司机的操作 。      但是司机端不知道啊 所以我们得写一个通知 让司机客户端也知道      他被人抢到了 该执行这个订单了    &#125;17. (前后端监听模拟 后续补充 )   阿里大佬教育: 先把单机做出来然后在平移到项目中 18. 消息服务推送(前置知识 长连接)      &#123;        1. 连接服务     司机客户端 source = new  EventSource(&quot;http://localhost:8080/connect/&quot;+dirverId);   后端接口url /connect/&#123;driverId&#125;  使用SseEmitter            2. 发送消息                 流程解释        这个实现涉及前端和后端的交云通讯，使用了Server-Sent Events (SSE)技术。流程如下：        前端初始化SSE连接：当页面加载完毕后，JavaScript代码尝试通过EventSource与服务器建立连接，使用的是/connect/&#123;driverId&#125;这个URL，&#123;driverId&#125;是司机的ID。        后端接收连接请求：SpringBoot应用的DriverEventController控制器中定义了处理/connect/&#123;driverId&#125;请求的方法。当该请求到达时，会为对应的司机ID创建一个新的SseEmitter实例，并立即返回给客户端保持连接。        后端发送消息：在后端，handleDriverConnect方法通过向map中存入司机ID和Sseemitter实力。        然后push方法会通过传进来司机ID和Content 向 这个id的司机推送content  通过send  。                前端接收并展示消息：前端通过监听EventSource上的message事件来接收从后端发送的消息，并将其显示在页面上。        结束连接：发送完消息后，后端调用emitter.complete()结束连接。        ---------------------------------------------        然后就是下订单后 把消息推送给司机端然后再推送给用户端  操作是一样的 但是就是 信息是不一样的       &#125;19. 定时任务设置  2 4 6 公里循环找车 设置返回值 如果2公里搜到了就不继续后面的内容了 订单变化流程[1. 订单开始 2. 司机接单 3.去接乘客 4. 司机到达指定起点 5.乘客上车 司机开始行程 6. 到达目的地 行程结束 未支付 7. 发起收款 8. 支付完成  9. 订单取消]20. 司机去接乘客(首先是 司机出发的时间 出发的经度纬度 然后是修改订单状态 变为 3 正在接取 )21. 司机到达目的地 (修改 司机到达时间  和  订单状态 修改为 4)22. 接到乘客 (修改  获取当前上车的经度纬度 前端传输过来 写入db 和  订单状态 修改为 5)23. 到达目的地 (行进中的里程和时长【用地图 高德的接口】 乘客下车的经度纬度  和  订单状态 修改为6)                                      👇👇👇👇                        调用地图的api 猎鹰服务的轨迹查询纠偏 24. 客户端整合api-driver (service-order 去接乘客 到达乘客上车点 司机接到乘客 形成结束 乘客下车 到达目的地 这是service-order的功能但是这些应该整合到我们的api-driver服务中去 因为这些司机要去使用的 所以 搞起)25. 实际价格计算 （实际价格 = 距离和时长加计价规则 （润色一个早晚高峰 db字段）。       计价规则依托于（城市code 车型 还有 计价规则的版本  -&gt; 计价规则是什么？？ 后续补充））      service-price 计算价格 然后整合发送给 service-order 26. 发起收款  （客户支付流程 - 沙箱   司机端发送收款请求  给到 用户端 弹出提示 点击支付  所以接口就是司机端调用第三方支付服务 ）27. 订单取消   （修改单子状态 但是是有角色区分 客户取消 司机取消 和 平台取消用的switch（orderstatus） case 就是订单的状态 只有在特定状态才能修改 并且还要讨论关于司机和乘客 责任问题 比如接单1min之后谁取消就是谁违约）28. 订单无效（就是下订单之后走了一圈没有司机 这里就是基于循环的扩大范围搜索司机 ） </code></pre><p><img src="/images/%E5%8F%96%E6%B6%88%E8%AE%A2%E5%8D%95.jpg" alt="取消订单"></p><hr><p>写的比较乱只能提供参考 一写提示作用 </p>]]></content>
    
    
    <categories>
      
      <category>技术博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网约车</tag>
      
      <tag>分布式</tag>
      
      <tag>订单服务全流程</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
