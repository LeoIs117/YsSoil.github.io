<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>业务-关于订单服务</title>
    <link href="/2024/04/01/%E4%B8%9A%E5%8A%A1-%E5%85%B3%E4%BA%8E%E8%AE%A2%E5%8D%95%E6%9C%8D%E5%8A%A1/"/>
    <url>/2024/04/01/%E4%B8%9A%E5%8A%A1-%E5%85%B3%E4%BA%8E%E8%AE%A2%E5%8D%95%E6%9C%8D%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<p>欢迎来到我的博客！很多业务都需要订单服务, 所以先举例子再抽取是这篇文章要做的事情,后续也会迭代版本。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>首先是背景 当前例子下是一个网约车的项目  我们做一个基础版本的订单服务 然后后续会去迭代这个版本。<br><img src="/images/%E6%80%BB%E6%B5%81%E7%A8%8B.jpg" alt="大概流程"></p><h2 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h2><p><img src="/images/09-%E8%AE%A1%E4%BB%B7.jpg" alt="价格预估及扩展"></p><p><img src="/images/orderTime.jpg" alt="订单时序图"></p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>画时序图 -&gt; 接口设计 -&gt; 项目创建 -&gt; 魔法值测试 -&gt; 订单表创建 -&gt; 添加计价规则</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><h3 id="设计接口"><a href="#设计接口" class="headerlink" title="设计接口:"></a><strong>设计接口</strong>:</h3><p>  我们应该养成抱着APIFOX或者POSTMAN进行开发,这应该是我们的习惯之一,那么关于订单接口的设计 我们应该这么干。根据网络预约出租车协议来编写当前接口的返回值（就是去查看相应的返回报文） 这里用APIFOX举例子<br>  1、首先我们填写接口  eg: localhost:8080&#x2F;order&#x2F;placing-order  然后我们用json的格式编写Response </p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;address&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;departTime&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;orderTime&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;departure&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;depLongitude&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;deplatitude&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;destination&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;destLongitude&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;deplatitude&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;encrypt&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;fareType&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>大概就是这个样子 简略写一些，根据具体业务具体的去写返回属性,让后我们就去编写对应的OrderRequest.java。</p><h3 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写:"></a><strong>代码编写</strong>:</h3><p>  姑且把这个OrderRequest写进二方库里(common)<br>  <strong><code>好习惯:先简单测试 写一个add去Test一下  看看能否正常的db 在apiFox使用魔法数据先填充一波</code></strong></p><p>   <strong>三步走:</strong><br>   ① 写依赖<br>   ② 配置yml文件<br>   ③ 写对应的注解</p><p>  然后比如注册 注册中心啊 这些如果想起来我就写，基操就不多赘述了。</p><p>  到这里我们应该是正常的实现了 order服务的基本操作 crud 或者说 就是一个add就可以了</p><p>  然后我们在API-passenger（客户端）通过Feign去 调用我们service-order中的add方法  返回值的就是成功与否啊？<br>  <em>这里我们添加一个图片后续</em><br>  <img src="/images/" alt="乘客端远程调用图"></p><p>  因为我们是魔法值所以下一步 设计表 -&gt;<br>  先说答案: 就是上面的json 然后加一个id、车辆经度、车辆纬度、机动车驾驶证编码、驾驶员手机号、车辆号牌、派单成功时间 就是表里的所有字段了 最好添加一下desc（描述）以免后续忘记。<br>  思路:<br>        就是需要一个整体的考虑  范式与反范式的考虑 是根据我们上面订单时序图和接口报文综合来考虑需要啥不需要啥。<br>        其实我第一建表也没健全 后续补充了一下。。。</p><h4 id="自动生成数据库代码实现"><a href="#自动生成数据库代码实现" class="headerlink" title="自动生成数据库代码实现"></a><strong>自动生成数据库代码实现</strong></h4><pre><code class="hljs">三步走！1 添加依赖 &#123;    一个 mybatis-plus-generator  # 这个是苞米兜下面的    一个 freemarker  # org包下的        &lt;!-- MyBatis-Plus Generator --&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.baomidou&lt;/groupId&gt;        &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt;        &lt;version&gt;最新版本&lt;/version&gt;    &lt;/dependency&gt;    &lt;!-- Freemarker --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.freemarker&lt;/groupId&gt;        &lt;artifactId&gt;freemarker&lt;/artifactId&gt;        &lt;version&gt;最新版本&lt;/version&gt;    &lt;/dependency&gt;&#125;</code></pre><p><strong>代码自动生成</strong></p><pre><code class="hljs">2 写自动生产包的代码   &#123;        package com.xinwen.demodoutoken.test;        import com.baomidou.mybatisplus.core.exceptions.MybatisPlusException;        import com.baomidou.mybatisplus.core.toolkit.StringUtils;        import com.baomidou.mybatisplus.generator.AutoGenerator;        import com.baomidou.mybatisplus.generator.config.*;        import com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;        import com.baomidou.mybatisplus.generator.engine.FreemarkerTemplateEngine;    import java.util.Scanner;    public class CodeGenerator &#123;        private static final String JDBC_URL = &quot;jdbc:mysql://localhost:3306/数据库?useSSL=false&amp;characterEncoding=utf8&amp;serverTimezone=UTC&quot;;        private static final String JDBC_DRIVER_NAME = &quot;com.mysql.cj.jdbc.Driver&quot;;        private static final String JDBC_USERNAME = &quot;root&quot;;        private static final String JDBC_PASSWORD = &quot;root&quot;;        public static String scanner(String tip) &#123;            Scanner scanner = new Scanner(System.in);            System.out.println(&quot;请输入&quot; + tip + &quot;：&quot;);            if (scanner.hasNext()) &#123;                String ipt = scanner.next();                if (StringUtils.isNotBlank(ipt)) &#123;                    return ipt;                &#125;            &#125;            throw new MybatisPlusException(&quot;请输入正确的&quot; + tip + &quot;！&quot;);        &#125;        public static void main(String[] args) &#123;            AutoGenerator mpg = new AutoGenerator();            GlobalConfig gc = new GlobalConfig();            String projectPath = System.getProperty(&quot;user.dir&quot;);            gc.setOutputDir(projectPath + &quot;/src/main/java&quot;);            gc.setAuthor(&quot;Xin-Wen&quot;);            gc.setOpen(false);            mpg.setGlobalConfig(gc);            DataSourceConfig dsc = new DataSourceConfig();            dsc.setUrl(JDBC_URL);            dsc.setDriverName(JDBC_DRIVER_NAME);            dsc.setUsername(JDBC_USERNAME);            dsc.setPassword(JDBC_PASSWORD);            mpg.setDataSource(dsc);            PackageConfig pc = new PackageConfig();            pc.setModuleName(scanner(&quot;模块名&quot;));            pc.setParent(&quot;com.xinwen&quot;);            mpg.setPackageInfo(pc);            // 注意这里的设置，确保不要以斜杠开头            TemplateConfig templateConfig = new TemplateConfig()                    .setController(&quot;templates/controller.java&quot;); // 这里提供模板带ftl 但是在这里不要填写tfl            mpg.setTemplate(templateConfig);            StrategyConfig strategy = new StrategyConfig();            strategy.setNaming(NamingStrategy.underline_to_camel);            strategy.setColumnNaming(NamingStrategy.underline_to_camel);            strategy.setEntityLombokModel(true);            strategy.setRestControllerStyle(true);            strategy.setInclude(scanner(&quot;表名，多个英文逗号分割&quot;).split(&quot;,&quot;));            mpg.setStrategy(strategy);            mpg.setTemplateEngine(new FreemarkerTemplateEngine());            mpg.execute();        &#125;    &#125;&#125;</code></pre><h3 id="添加计价规则"><a href="#添加计价规则" class="headerlink" title="添加计价规则"></a><strong>添加计价规则</strong></h3><p>动作  api-passenger 调用 service-price 进行计价的动作 然后service-price去调用 service-map 拉取到经纬度 回去计算 然后 reurn给api-passenger</p><p>目的: 这里是之前在预估价格操作的时候是写死了的 在这个位置我们会对之前预估价格的服务进行一个简单的翻新 把城市编码和车型参数做一个传递<br>    之前返回给前端的值就是一个 price 预估价  此时我们做一个修改就是  把这个 city_code  和 vehicleType 也给他塞进去  这是为了方便后续下订单操作的参数预备</p><p><img src="/images/%E8%AE%A1%E4%BB%B7%E8%A7%84%E5%88%99%E4%BC%A0%E9%80%92%E6%89%A9%E5%B1%95%E5%9B%BE.jpg" alt="计价规则传递扩展图"></p><pre><code class="hljs">这里就是 我们预估价格的操作 流程就是这样的 为什么要多次判断呢  举例子说明  : 一个人  8点  拿着我当时的计价规则 根据(城市  车型  计价规则  里程数 时间 ) 算出来一个价格然后拉到了价格之后 没下单 ！  干别的事去了 9点回来的下的单子 ok 不巧的是 我们 8点30 改了计价规则了  那么我们就要在用户下单的时候提醒他 计价发生改变  你接受不接受新计价规则 如果接受ok 那就去下单 不接受就没事了 </code></pre><p>记忆点: 司机有总流程中的1234567条 是不允许下单的  （订单开始  司机接单 去接乘客  司机到达 乘客上车司机启程 到达地点 未支付）</p><h2 id="派单业务"><a href="#派单业务" class="headerlink" title="派单业务"></a><strong>派单业务</strong></h2><p><img src="/images/%E6%B4%BE%E5%8D%95%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg" alt="派单业务图"></p><h3 id="针对于用户自身合法性的校验"><a href="#针对于用户自身合法性的校验" class="headerlink" title="针对于用户自身合法性的校验"></a><strong>针对于用户自身合法性的校验</strong></h3><h4 id="乘客下单业务校验"><a href="#乘客下单业务校验" class="headerlink" title="乘客下单业务校验"></a><strong>乘客下单业务校验</strong></h4><pre><code class="hljs">下单流程 : if 订单表中 有一个字段叫订单状态  如果状态是1-7不能继续下单 （constants）else 可以下单  </code></pre><h4 id="黑名单校验业务"><a href="#黑名单校验业务" class="headerlink" title="黑名单校验业务"></a><strong>黑名单校验业务</strong></h4><pre><code class="hljs"> 背景 网约车项目 : 1分钱乘车活动   下单时判断设备号 是否在1h内下多次订单  if是 提醒不允许下单 else  操作redis: （key）设备号 （value）次数 , TTL     在HttpServletRequest的header中 拉去 deviceCode 这就是设备号了</code></pre><h3 id="基于业务实际展开情况的校验"><a href="#基于业务实际展开情况的校验" class="headerlink" title="基于业务实际展开情况的校验"></a><strong>基于业务实际展开情况的校验</strong></h3><pre><code class="hljs">1、当前城市和车型是否开通业务？（通过城市编号和车型 这两个字段 去计价规则表中 查询如果有拿过来或者不拿 看后续需求  返回true 否则 false）</code></pre><h3 id="查询城市可用司机"><a href="#查询城市可用司机" class="headerlink" title="查询城市可用司机"></a><strong>查询城市可用司机</strong></h3><pre><code class="hljs">司机信息表 查看司机状态 通过城市 拉去到 当前城市信息 然后查看状态</code></pre><h2 id="派单逻辑"><a href="#派单逻辑" class="headerlink" title="派单逻辑"></a><strong>派单逻辑</strong></h2><pre><code class="hljs">service-order端 通过循环调用 周边所搜 每次扩大半径就ok了 然后通过定时任务调用就行了 优化把2000 4000 5000 塞进list 然后循环的拉去附近终端 拉取到后解析 出tid和carid 看看司机能不能接单  然后进行后续操作</code></pre><h1 id="派单流程前置流程整体联调"><a href="#派单流程前置流程整体联调" class="headerlink" title="派单流程前置流程整体联调"></a><strong>派单流程前置流程整体联调</strong></h1><p>有点乱后续会完善 ！</p><hr>]]></content>
    
    
    <categories>
      
      <category>技术博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网约车</tag>
      
      <tag>订单</tag>
      
      <tag>分布式</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
